{"01-ES6-intro":{"00-intro":{"body":"<h2 id=\"what-s-es6-\">What&#39;s ES6?</h2>\n<ul>\n<li>new Standard for JavaScript</li>\n<li>different names: ES2015, Harmony.</li>\n</ul>\n"},"01-transpiling":{"body":"<h2 id=\"transpiling\">Transpiling</h2>\n<p>Made even worse by the rapid evolution of features, a problem arises for JS developers who at once may both strongly desire to use new features while at the same time being slapped with the reality that their sites/apps may need to support older browsers without such support.</p>\n<p>The way ES5 appears to have played out in the broader industry, the typical mindset was that code bases waited to adopt ES5 until most if not all pre-ES5 environments had fallen out of their support spectrum. As a result, many are just recently (at the time of this writing) starting to adopt things like <code>strict</code> mode, which landed in ES5 over five years ago.</p>\n<p>It&#39;s widely considered to be a harmful approach for the future of the JS ecosystem to wait around and trail the specification by so many years. All those responsible for evolving the language desire for developers to begin basing their code on the new features and patterns as soon as they stabilize in specification form and browsers have a chance to implement them.</p>\n<p>So how do we resolve this seeming contradiction? The answer is tooling, specifically a technique called <em>transpiling</em> (transformation + compiling). Roughly, the idea is to use a special tool to transform your ES6 code into equivalent (or close!) matches that work in ES5 environments.</p>\n<p>For example, consider shorthand property definitions (see &quot;Object Literal Extensions&quot; in Chapter 2). Here&#39;s the ES6 form:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> foo</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> obj</span> = {\n    foo        <span class=\"hljs-comment\">// means `foo: foo`</span>\n};\n\nobj.foo;    <span class=\"hljs-comment\">// [1,2,3]</span>\n</code></pre>\n<p>But (roughly) here&#39;s how that transpiles:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> foo</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> obj</span> = {\n    foo: foo\n};\n\nobj.foo;    <span class=\"hljs-comment\">// [1,2,3]</span>\n</code></pre>\n<p>This is a minor but pleasant transformation that lets us shorten the <code>foo: foo</code> in an object literal declaration to just <code>foo</code>, if the names are the same.</p>\n<p>Transpilers perform these transformations for you, usually in a build workflow step similar to how you perform linting, minification, and other similar operations.</p>\n"},"02-shims":{"body":"<h3 id=\"shims-polyfills\">Shims/Polyfills</h3>\n<ul>\n<li>Not all new Features need a transpiler</li>\n<li>Syntax Cannot be ployfilled, but API can be.</li>\n<li>Example: <code>Object.is(..)</code> is a new utility for checking strict equality of two values but without the nuanced exceptions that <code>===</code> has for <code>NaN</code> and <code>-0</code> values. The polyfill for <code>Object.is(..)</code> is pretty easy:</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-label\">if</span> (!Object.is) {\n    Object.is = <span class=\"hljs-preprocessor\">function</span>(<span class=\"hljs-literal\">v1</span>, <span class=\"hljs-literal\">v2</span>) {\n        // test for `-<span class=\"hljs-number\">0</span>`\n        <span class=\"hljs-preprocessor\">if</span> (<span class=\"hljs-literal\">v1</span> === <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-literal\">v2</span> === <span class=\"hljs-number\">0</span>) {\n            return <span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">v1</span> === <span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">v2</span><span class=\"hljs-comment\">;</span>\n        }\n        // test for `NaN`\n        <span class=\"hljs-preprocessor\">if</span> (<span class=\"hljs-literal\">v1</span> !== <span class=\"hljs-literal\">v1</span>) {\n            return <span class=\"hljs-literal\">v2</span> !== <span class=\"hljs-literal\">v2</span><span class=\"hljs-comment\">;</span>\n        }\n        // everything <span class=\"hljs-preprocessor\">else</span>\n        return <span class=\"hljs-literal\">v1</span> === <span class=\"hljs-literal\">v2</span><span class=\"hljs-comment\">;</span>\n    }<span class=\"hljs-comment\">;</span>\n}\n</code></pre>\n<ul>\n<li>Collection of shims:  (<a href=\"https://github.com/paulmillr/es6-shim/\">https://github.com/paulmillr/es6-shim/</a>) </li>\n</ul>\n"}},"02-ES6-syntax":{"00-intro":{"body":"<h3 id=\"block-scoped-declarations\">Block-Scoped Declarations</h3>\n<ul>\n<li><p>The old way of creating a block scope: the immediately invoked function expression (IIFE):</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n\n  (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span>;\n  <span class=\"hljs-built_in\">console</span>.log( a );    <span class=\"hljs-comment\">// 3</span>\n  })();\n\n  <span class=\"hljs-built_in\">console</span>.log( a );        <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n</li>\n</ul>\n"},"01-let":{"body":"<h3 id=\"let-me-introduce-let-\">let me introduce: <code>let</code></h3>\n<ul>\n<li>Variables declared by let have as their scope the block in which they are defined, as well as in any contained sub-blocks . In this way, let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function</li>\n<li><p>When we say a block, we mean any <code>{ }</code></p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">varTest</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">31</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">71</span>;  <span class=\"hljs-comment\">// same variable!</span>\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 71</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 71</span>\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letTest</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">31</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">71</span>;  <span class=\"hljs-comment\">// different variable</span>\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 71</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 31</span>\n  }\n</code></pre>\n</li>\n</ul>\n"},"02-let-loops":{"body":"<h3 id=\"let-in-loops\">let in loops</h3>\n<ul>\n<li>You can use the let keyword to bind variables locally in the scope of loops instead of using a global variable (defined using var) for that.</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">10</span>; i++) {\n  console.<span class=\"hljs-built_in\">log</span>(i); <span class=\"hljs-comment\">// 0, 1, 2, 3, 4 ... 9</span>\n  }\n\n  console.<span class=\"hljs-built_in\">log</span>(i); <span class=\"hljs-comment\">// i is not defined</span>\n</code></pre>\n"},"03-const":{"body":"<h3 id=\"-const-declarations\"><code>const</code> Declarations</h3>\n<ul>\n<li><p>There&#39;s one other form of block-scoped declaration to consider: the <code>const</code>, which creates <em>constants</em>.</p>\n</li>\n<li><p>What exactly is a constant? It&#39;s a variable that&#39;s read-only after its initial value is set. Consider:</p>\n</li>\n</ul>\n<pre><code class=\"lang-js\">{\n<span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">2</span>;\nconsole.<span class=\"hljs-built_in\">log</span>( a );    <span class=\"hljs-comment\">// 2</span>\na = <span class=\"hljs-number\">3</span>;                <span class=\"hljs-comment\">// TypeError!</span>\n}\n</code></pre>\n<ul>\n<li>More complex types like objects can be changed. the variable a is holds a reference to the array, but the array itself is freely mutable.</li>\n</ul>\n<pre><code class=\"lang-js\">{\n<span class=\"hljs-keyword\">const</span> a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\na.push( <span class=\"hljs-number\">4</span> );\nconsole.<span class=\"hljs-built_in\">log</span>( a );        <span class=\"hljs-comment\">// [1,2,3,4]</span>\n\na = <span class=\"hljs-number\">42</span>;                    <span class=\"hljs-comment\">// TypeError!</span>\n}\n</code></pre>\n<ul>\n<li>Everything is explicitly defined, including undefined.</li>\n</ul>\n"},"04-block-scope-functions":{"body":"<h3 id=\"block-scoped-functions\">Block-scoped Functions</h3>\n<ul>\n<li>Functions implemented inside a block is bound to it</li>\n<li>Hoisting applies.</li>\n</ul>\n<pre><code class=\"lang-js\">{\nfoo();                    <span class=\"hljs-comment\">// works!</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-comment\">// ..</span>\n}\n}\n\nfoo();                        <span class=\"hljs-comment\">// ReferenceError</span>\n</code></pre>\n<ul>\n<li>Hoisting doesn&#39;t apply to let declarations</li>\n</ul>\n<pre><code class=\"lang-js\">{\nfoo();   <span class=\"hljs-comment\">//ERROR</span>\n<span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ <span class=\"hljs-comment\">//.. };                    </span>\n}\n</code></pre>\n<ul>\n<li>Guess what foo would return in ES5 or ES6. HINT: Block scoping and hoisting.</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (something) {\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"1\"</span> );\n}\n}\n<span class=\"hljs-keyword\">else</span> {\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"2\"</span> );\n}\n}\n\nfoo();        <span class=\"hljs-comment\">// ??</span>\n</code></pre>\n"},"05-spread-rest":{"body":"<h2 id=\"spread-rest\">Spread/Rest</h2>\n<ul>\n<li>Spread or Rest operator<code>...</code> </li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y,z)</span> </span>{\nconsole.<span class=\"hljs-built_in\">log</span>( x, y, z );\n}\n\nfoo( ...[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>] );                <span class=\"hljs-comment\">// 1 2 3</span>\n</code></pre>\n<ul>\n<li><p>When <code>...</code> is used in front of an array (actually, any <em>iterable</em>, which we cover in Chapter 3), it acts to &quot;spread&quot; it out into its individual values.</p>\n</li>\n<li><p>Another cool usage is to spread out/expand a value in other contexts as well, such as inside another array declaration:</p>\n</li>\n</ul>\n<pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\nvar b = [ <span class=\"hljs-number\">1</span>, ...a, <span class=\"hljs-number\">5</span> ];\n\nconsole.<span class=\"hljs-built_in\">log</span>( b );                    <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n</code></pre>\n<ul>\n<li>Another common usage is to <em>gather</em>.</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x, y, <span class=\"hljs-rest_arg\">...z</span>)</span> </span>{\nconsole.log( x, y, z );\n}\n\nfoo( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span> );            <span class=\"hljs-comment\">// 1 2 [3,4,5]</span>\n</code></pre>\n<ul>\n<li>if you don&#39;t have any named parameters, the <code>...</code> gathers all arguments:</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> </span>{\nconsole.log( args );\n}\n\nfoo( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);            <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n</code></pre>\n"},"06-default-param":{"body":"<h3 id=\"default-parameter-values\">Default Parameter Values</h3>\n<ul>\n<li>We used to do this</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y)</span> </span>{\nx = x || <span class=\"hljs-number\">11</span>;\ny = y || <span class=\"hljs-number\">31</span>;\n\nconsole.<span class=\"hljs-built_in\">log</span>( x + y );\n}\n\nfoo();                <span class=\"hljs-comment\">// 42</span>\nfoo( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span> );        <span class=\"hljs-comment\">// 11</span>\nfoo( <span class=\"hljs-number\">5</span> );            <span class=\"hljs-comment\">// 36</span>\nfoo( null, <span class=\"hljs-number\">6</span> );        <span class=\"hljs-comment\">// 17</span>\n</code></pre>\n<ul>\n<li>There&#39;s a gotcha: </li>\n</ul>\n<pre><code class=\"lang-js\">foo( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">42</span> );        <span class=\"hljs-comment\">// 53 &lt;-- Oops, not 42</span>\n</code></pre>\n<ul>\n<li>Why? </li>\n</ul>\n<ul>\n<li>With all this in mind, we can now examine a nice helpful syntax added as of ES6 to streamline the assignment of default values to missing arguments:</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x = <span class=\"hljs-number\">11</span>, y = <span class=\"hljs-number\">31</span>)</span> </span>{\nconsole.<span class=\"hljs-built_in\">log</span>( x + y );\n}\n\nfoo();                    <span class=\"hljs-comment\">// 42</span>\nfoo( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span> );            <span class=\"hljs-comment\">// 11</span>\nfoo( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">42</span> );            <span class=\"hljs-comment\">// 42</span>\n\nfoo( <span class=\"hljs-number\">5</span> );                <span class=\"hljs-comment\">// 36</span>\nfoo( <span class=\"hljs-number\">5</span>, undefined );    <span class=\"hljs-comment\">// 36 &lt;-- `undefined` is missing</span>\nfoo( <span class=\"hljs-number\">5</span>, null );            <span class=\"hljs-comment\">// 5  &lt;-- null coerces to `0`</span>\n\nfoo( undefined, <span class=\"hljs-number\">6</span> );    <span class=\"hljs-comment\">// 17 &lt;-- `undefined` is missing</span>\nfoo( null, <span class=\"hljs-number\">6</span> );            <span class=\"hljs-comment\">// 6  &lt;-- null coerces to `0`</span>\n</code></pre>\n<ul>\n<li>Final Gotchas: <strong>Note:</strong> A rest/gather parameter (see &quot;Spread/Rest&quot;) cannot have a default value. So, while <code>function foo(...vals=[1,2,3]) {</code> might seem an intriguing capability, it&#39;s not valid syntax. You&#39;ll need to continue to apply that sort of logic manually if necessary.</li>\n</ul>\n<ul>\n<li>Default value expression.</li>\n</ul>\n"},"07-destructuring":{"body":""},"08-concise":{"body":"<h3 id=\"concise-properties\">Concise Properties</h3>\n<p>You&#39;re certainly familiar with declaring object literals in this form:</p>\n<pre><code class=\"lang-js\">var <span class=\"hljs-built_in\">x</span> = <span class=\"hljs-number\">2</span>, <span class=\"hljs-built_in\">y</span> = <span class=\"hljs-number\">3</span>,\no = {\n<span class=\"hljs-label\">x:</span> <span class=\"hljs-built_in\">x</span>,\n<span class=\"hljs-label\">y:</span> <span class=\"hljs-built_in\">y</span>\n}<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>If it&#39;s always felt redundant to say <code>x: x</code> all over, there&#39;s good news. If you need to define a property that is the same name as a lexical identifier, you can shorten it from <code>x: x</code> to <code>x</code>. Consider:</p>\n<pre><code class=\"lang-js\">var x = <span class=\"hljs-number\">2</span>, y = <span class=\"hljs-number\">3</span>,\no = {\nx,\ny\n};\n</code></pre>\n<h3 id=\"concise-methods\">Concise Methods</h3>\n<p>In a similar spirit to concise properties we just examined, functions attached to properties in object literals also have a concise form, for convenience.</p>\n<p>The old way:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o = {\nx: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n},\ny: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n}\n}\n</code></pre>\n<p>And as of ES6:</p>\n<pre><code class=\"lang-js\">var o = {\nx<span class=\"hljs-comment\">()</span> {\n<span class=\"hljs-comment\">// ..</span>\n},\ny<span class=\"hljs-comment\">()</span> {\n<span class=\"hljs-comment\">// ..</span>\n}\n}\n</code></pre>\n<p><strong>Warning:</strong> While <code>x() { .. }</code> seems to just be shorthand for <code>x: function(){ .. }</code>, concise methods have special behaviors that their older counterparts don&#39;t; specifically, the allowance for <code>super</code> (see &quot;Object <code>super</code>&quot; later in this chapter).</p>\n<p>Generators (see Chapter 4) also have a concise method form:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o</span> = {\n*foo() { .. }\n};\n</code></pre>\n<h4 id=\"concisely-unnamed\">Concisely Unnamed</h4>\n<p>While that convenience shorthand is quite attractive, there&#39;s a subtle gotcha to be aware of. To illustrate, let&#39;s examine pre-ES6 code like the following, which you might try to refactor to use concise methods:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runSomething</span>(<span class=\"hljs-params\">o</span>) </span>{\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-built_in\">Math</span>.random(),\ny = <span class=\"hljs-built_in\">Math</span>.random();\n\n<span class=\"hljs-keyword\">return</span> o.something( x, y );\n}\n\nrunSomething( {\nsomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">something</span>(<span class=\"hljs-params\">x,y</span>) </span>{\n<span class=\"hljs-keyword\">if</span> (x &gt; y) {\n<span class=\"hljs-comment\">// recursively call with `x`</span>\n<span class=\"hljs-comment\">// and `y` swapped</span>\n<span class=\"hljs-keyword\">return</span> something( y, x );\n}\n\n<span class=\"hljs-keyword\">return</span> y - x;\n}\n} );\n</code></pre>\n<p>This obviously silly code just generates two random numbers and subtracts the smaller from the bigger. But what&#39;s important here isn&#39;t what it does, but rather how it&#39;s defined. Let&#39;s focus on the object literal and function definition, as we see here:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">runSomething</span>( {\n<span class=\"hljs-tag\">something</span>: <span class=\"hljs-tag\">function</span> <span class=\"hljs-tag\">something</span>(x,y) {\n<span class=\"hljs-comment\">// ..</span>\n}\n} );\n</code></pre>\n<p>Why do we say both <code>something:</code> and <code>function something</code>? Isn&#39;t that redundant? Actually, no, both are needed for different purposes. The property <code>something</code> is how we can call <code>o.something(..)</code>, sort of like its public name. But the second <code>something</code> is a lexical name to refer to the function from inside itself, for recursion purposes.</p>\n<p>Can you see why the line <code>return something(y,x)</code> needs the name <code>something</code> to refer to the function? There&#39;s no lexical name for the object, such that it could have said <code>return o.something(y,x)</code> or something of that sort.</p>\n<p>That&#39;s actually a pretty common practice when the object literal does have an identifying name, such as:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-comment\">// ..</span>\ncontroller.makeRequest(..);\n}\n};\n</code></pre>\n<p>Is this a good idea? Perhaps, perhaps not. You&#39;re assuming that the name <code>controller</code> will always point to the object in question. But it very well may not -- the <code>makeRequest(..)</code> function doesn&#39;t control the outer code and so can&#39;t force that to be the case. This could come back to bite you.</p>\n<p>Others prefer to use <code>this</code> to define such things:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n<span class=\"hljs-keyword\">this</span>.makeRequest(..);\n}\n};\n</code></pre>\n<p>That looks fine, and should work if you always invoke the method as <code>controller.makeRequest(..)</code>. But you now have a <code>this</code> binding gotcha if you do something like:</p>\n<pre><code class=\"lang-js\">btn.addEventListener( <span class=\"hljs-string\">\"click\"</span>, controller.makeRequest, <span class=\"hljs-literal\">false</span> );\n</code></pre>\n<p>Of course, you can solve that by passing <code>controller.makeRequest.bind(controller)</code> as the handler reference to bind the event to. But yuck -- it isn&#39;t very appealing.</p>\n<p>Or what if your inner <code>this.makeRequest(..)</code> call needs to be made from a nested function? You&#39;ll have another <code>this</code> binding hazard, which people will often solve with the hacky <code>var self = this</code>, such as:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">self</span> = this;\n\nbtn.addEventListener( <span class=\"hljs-string\">\"click\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n<span class=\"hljs-keyword\">self</span>.makeRequest(..);\n}, <span class=\"hljs-keyword\">false</span> );\n}\n};\n</code></pre>\n<p>More yuck.</p>\n<p><strong>Note:</strong> For more information on <code>this</code> binding rules and gotchas, see Chapters 1-2 of the <em>this &amp; Object Prototypes</em> title of this series.</p>\n<p>OK, what does all this have to do with concise methods? Recall our <code>something(..)</code> method definition:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">runSomething</span>( {\n<span class=\"hljs-tag\">something</span>: <span class=\"hljs-tag\">function</span> <span class=\"hljs-tag\">something</span>(x,y) {\n<span class=\"hljs-comment\">// ..</span>\n}\n} );\n</code></pre>\n<p>The second <code>something</code> here provides a super convenient lexical identifier that will always point to the function itself, giving us the perfect reference for recursion, event binding/unbinding, and so on -- no messing around with <code>this</code> or trying to use an untrustable object reference.</p>\n<p>Great!</p>\n<p>So, now we try to refactor that function reference to this ES6 concise method form:</p>\n<pre><code class=\"lang-js\">runSomething<span class=\"hljs-list\">( {\nsomething<span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span>,y)</span> {\nif <span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span> &gt; y)</span> {\nreturn something<span class=\"hljs-list\">( <span class=\"hljs-keyword\">y</span>, x )</span><span class=\"hljs-comment\">;</span>\n}\n\nreturn y - x<span class=\"hljs-comment\">;</span>\n}\n} )</span><span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>Seems fine at first glance, except this code will break. The <code>return something(..)</code> call will not find a <code>something</code> identifier, so you&#39;ll get a <code>ReferenceError</code>. Oops. But why?</p>\n<p>The above ES6 snippet is interpreted as meaning:</p>\n<pre><code class=\"lang-js\">runSomething<span class=\"hljs-list\">( {\nsomething: function<span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span>,y)</span>{\nif <span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span> &gt; y)</span> {\nreturn something<span class=\"hljs-list\">( <span class=\"hljs-keyword\">y</span>, x )</span><span class=\"hljs-comment\">;</span>\n}\n\nreturn y - x<span class=\"hljs-comment\">;</span>\n}\n} )</span><span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>Look closely. Do you see the problem? The concise method definition implies <code>something: function(x,y)</code>. See how the second <code>something</code> we were relying on has been omitted? In other words, concise methods imply anonymous function expressions.</p>\n<p>Yeah, yuck.</p>\n<p><strong>Note:</strong> You may be tempted to think that <code>=&gt;</code> arrow functions are a good solution here, but they&#39;re equally insufficient, as they&#39;re also anonymous function expressions. We&#39;ll cover them in &quot;Arrow Functions&quot; later in this chapter.</p>\n<p>The partially redeeming news is that our <code>something(x,y)</code> concise method won&#39;t be totally anonymous. See &quot;Function Names&quot; in Chapter 7 for information about ES6 function name inference rules. That won&#39;t help us for our recursion, but it helps with debugging at least.</p>\n<p>So what are we left to conclude about concise methods? They&#39;re short and sweet, and a nice convenience. But you should only use them if you&#39;re never going to need them to do recursion or event binding/unbinding. Otherwise, stick to your old-school <code>something: function something(..)</code> method definitions.</p>\n<p>A lot of your methods are probably going to benefit from concise method definitions, so that&#39;s great news! Just be careful of the few where there&#39;s an un-naming hazard.</p>\n"},"09-template-literals":{"body":""},"10-the-this":{"body":"<h3 id=\"arrow-functions\">Arrow Functions</h3>\n<ul>\n<li><p>A function shorthand or Lambda using the fat-arrow &quot; =&gt; &quot; syntax.</p>\n</li>\n<li><p>No constructor!</p>\n</li>\n<li><p>Not just syntax sugar. Arrow functions automatically bind &quot;this&quot; from the containing scope.</p>\n</li>\n</ul>\n"}},"03-ES6-iterators":{"00-intro":{"body":"<h3 id=\"generators\">Generators</h3>\n<ul>\n<li>Iterators are a way of organizing ordered, sequential, pull-based consumption of data.</li>\n</ul>\n"}},"06-ES6-not-covered":{"00-intro":{"body":"<h3 id=\"what-s-not-covered\">What&#39;s not covered</h3>\n<ul>\n<li>Meta Programming</li>\n<li>Reflect API</li>\n</ul>\n"}},"README":{"body":"<hr> <p><strong><a href=\"http://shop.oreilly.com/product/0636920033769.do\">Purchase digital/print copy from O&#39;Reilly</a></strong></p> <hr> <p><a href=\"toc.md\">Table of Contents</a></p> <ul> <li><a href=\"foreword.md\">Foreword</a> (by <a href=\"http://bocoup.com/weblog/author/rick-waldron/\">Rick Waldron</a>)</li> <li><a href=\"../preface.md\">Preface</a></li> <li><a href=\"ch1.md\">Chapter 1: ES? Now &amp; Future</a></li> <li><a href=\"ch2.md\">Chapter 2: Syntax</a></li> <li><a href=\"ch3.md\">Chapter 3: Organization</a></li> <li><a href=\"ch4.md\">Chapter 4: Async Flow Control</a></li> <li><a href=\"ch5.md\">Chapter 5: Collections</a></li> <li><a href=\"ch6.md\">Chapter 6: API Additions</a></li> <li><a href=\"ch7.md\">Chapter 7: Meta Programming</a></li> <li><a href=\"ch8.md\">Chapter 8: Beyond ES6</a></li> <li><a href=\"apA.md\">Appendix A: Thank You&#39;s!</a></li> </ul> ","title":"You Don't Know JS: ES6 & Beyond"}}