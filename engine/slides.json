{"ES6-intro":{"00-intro":{"body":"<h2 id=\"what-s-es6-\">What&#39;s ES6?</h2>\n<ul>\n<li>new Standard for JavaScript</li>\n<li>different names: ES2015, Harmony.</li>\n</ul>\n"},"01-transpiling":{"body":"<h2 id=\"transpiling\">Transpiling</h2>\n<p>Made even worse by the rapid evolution of features, a problem arises for JS developers who at once may both strongly desire to use new features while at the same time being slapped with the reality that their sites/apps may need to support older browsers without such support.</p>\n<p>The way ES5 appears to have played out in the broader industry, the typical mindset was that code bases waited to adopt ES5 until most if not all pre-ES5 environments had fallen out of their support spectrum. As a result, many are just recently (at the time of this writing) starting to adopt things like <code>strict</code> mode, which landed in ES5 over five years ago.</p>\n<p>It&#39;s widely considered to be a harmful approach for the future of the JS ecosystem to wait around and trail the specification by so many years. All those responsible for evolving the language desire for developers to begin basing their code on the new features and patterns as soon as they stabilize in specification form and browsers have a chance to implement them.</p>\n<p>So how do we resolve this seeming contradiction? The answer is tooling, specifically a technique called <em>transpiling</em> (transformation + compiling). Roughly, the idea is to use a special tool to transform your ES6 code into equivalent (or close!) matches that work in ES5 environments.</p>\n<p>For example, consider shorthand property definitions (see &quot;Object Literal Extensions&quot; in Chapter 2). Here&#39;s the ES6 form:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> foo</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> obj</span> = {\n    foo        <span class=\"hljs-comment\">// means `foo: foo`</span>\n};\n\nobj.foo;    <span class=\"hljs-comment\">// [1,2,3]</span>\n</code></pre>\n<p>But (roughly) here&#39;s how that transpiles:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> foo</span> = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> obj</span> = {\n    foo: foo\n};\n\nobj.foo;    <span class=\"hljs-comment\">// [1,2,3]</span>\n</code></pre>\n<p>This is a minor but pleasant transformation that lets us shorten the <code>foo: foo</code> in an object literal declaration to just <code>foo</code>, if the names are the same.</p>\n<p>Transpilers perform these transformations for you, usually in a build workflow step similar to how you perform linting, minification, and other similar operations.</p>\n"},"02-shims":{"body":"<h3 id=\"shims-polyfills\">Shims/Polyfills</h3>\n<ul>\n<li>Not all new Features need a transpiler</li>\n<li>Syntax Cannot be ployfilled, but API can be.</li>\n<li>Example: <code>Object.is(..)</code> is a new utility for checking strict equality of two values but without the nuanced exceptions that <code>===</code> has for <code>NaN</code> and <code>-0</code> values. The polyfill for <code>Object.is(..)</code> is pretty easy:</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-label\">if</span> (!Object.is) {\n    Object.is = <span class=\"hljs-preprocessor\">function</span>(<span class=\"hljs-literal\">v1</span>, <span class=\"hljs-literal\">v2</span>) {\n        // test for `-<span class=\"hljs-number\">0</span>`\n        <span class=\"hljs-preprocessor\">if</span> (<span class=\"hljs-literal\">v1</span> === <span class=\"hljs-number\">0</span> &amp;&amp; <span class=\"hljs-literal\">v2</span> === <span class=\"hljs-number\">0</span>) {\n            return <span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">v1</span> === <span class=\"hljs-number\">1</span> / <span class=\"hljs-literal\">v2</span><span class=\"hljs-comment\">;</span>\n        }\n        // test for `NaN`\n        <span class=\"hljs-preprocessor\">if</span> (<span class=\"hljs-literal\">v1</span> !== <span class=\"hljs-literal\">v1</span>) {\n            return <span class=\"hljs-literal\">v2</span> !== <span class=\"hljs-literal\">v2</span><span class=\"hljs-comment\">;</span>\n        }\n        // everything <span class=\"hljs-preprocessor\">else</span>\n        return <span class=\"hljs-literal\">v1</span> === <span class=\"hljs-literal\">v2</span><span class=\"hljs-comment\">;</span>\n    }<span class=\"hljs-comment\">;</span>\n}\n</code></pre>\n<ul>\n<li>Collection of shims:  (<a href=\"https://github.com/paulmillr/es6-shim/\">https://github.com/paulmillr/es6-shim/</a>) </li>\n</ul>\n"}},"ES6-syntax":{"00-intro":{"body":"<h3 id=\"block-scoped-declarations\">Block-Scoped Declarations</h3>\n<ul>\n<li><p>The old way of creating a block scope: the immediately invoked function expression (IIFE):</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">2</span>;\n\n  (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">IIFE</span>(<span class=\"hljs-params\"></span>)</span>{\n  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-number\">3</span>;\n  <span class=\"hljs-built_in\">console</span>.log( a );    <span class=\"hljs-comment\">// 3</span>\n  })();\n\n  <span class=\"hljs-built_in\">console</span>.log( a );        <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n</li>\n</ul>\n"},"01-let":{"body":"<h3 id=\"let-me-introduce-let-\">let me introduce: <code>let</code></h3>\n<ul>\n<li>Variables declared by let have as their scope the block in which they are defined, as well as in any contained sub-blocks . In this way, let works very much like var. The main difference is that the scope of a var variable is the entire enclosing function</li>\n<li><p>When we say a block, we mean any <code>{ }</code></p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">varTest</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">31</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">71</span>;  <span class=\"hljs-comment\">// same variable!</span>\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 71</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 71</span>\n  }\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">letTest</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">31</span>;\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) {\n  <span class=\"hljs-keyword\">let</span> x = <span class=\"hljs-number\">71</span>;  <span class=\"hljs-comment\">// different variable</span>\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 71</span>\n  }\n  <span class=\"hljs-built_in\">console</span>.log(x);  <span class=\"hljs-comment\">// 31</span>\n  }\n</code></pre>\n</li>\n</ul>\n"},"02-let-loops":{"body":"<h3 id=\"let-in-loops\">let in loops</h3>\n<ul>\n<li>You can use the let keyword to bind variables locally in the scope of loops instead of using a global variable (defined using var) for that.</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">for</span> (let i = <span class=\"hljs-number\">0</span>; i&lt;<span class=\"hljs-number\">10</span>; i++) {\n  console.<span class=\"hljs-built_in\">log</span>(i); <span class=\"hljs-comment\">// 0, 1, 2, 3, 4 ... 9</span>\n  }\n\n  console.<span class=\"hljs-built_in\">log</span>(i); <span class=\"hljs-comment\">// i is not defined</span>\n</code></pre>\n"},"03-const":{"body":"<h3 id=\"-const-declarations\"><code>const</code> Declarations</h3>\n<ul>\n<li><p>There&#39;s one other form of block-scoped declaration to consider: the <code>const</code>, which creates <em>constants</em>.</p>\n</li>\n<li><p>What exactly is a constant? It&#39;s a variable that&#39;s read-only after its initial value is set. Consider:</p>\n</li>\n</ul>\n<pre><code class=\"lang-js\">{\n<span class=\"hljs-keyword\">const</span> a = <span class=\"hljs-number\">2</span>;\nconsole.<span class=\"hljs-built_in\">log</span>( a );    <span class=\"hljs-comment\">// 2</span>\na = <span class=\"hljs-number\">3</span>;                <span class=\"hljs-comment\">// TypeError!</span>\n}\n</code></pre>\n<ul>\n<li>More complex types like objects can be changed. the variable a is holds a reference to the array, but the array itself is freely mutable.</li>\n</ul>\n<pre><code class=\"lang-js\">{\n<span class=\"hljs-keyword\">const</span> a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\na.push( <span class=\"hljs-number\">4</span> );\nconsole.<span class=\"hljs-built_in\">log</span>( a );        <span class=\"hljs-comment\">// [1,2,3,4]</span>\n\na = <span class=\"hljs-number\">42</span>;                    <span class=\"hljs-comment\">// TypeError!</span>\n}\n</code></pre>\n<ul>\n<li>Everything is explicitly defined, including undefined.</li>\n</ul>\n"},"04-block-scope-functions":{"body":"<h3 id=\"block-scoped-functions\">Block-scoped Functions</h3>\n<ul>\n<li>Functions implemented inside a block is bound to it</li>\n<li>Hoisting applies.</li>\n</ul>\n<pre><code class=\"lang-js\">{\nfoo();                    <span class=\"hljs-comment\">// works!</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-comment\">// ..</span>\n}\n}\n\nfoo();                        <span class=\"hljs-comment\">// ReferenceError</span>\n</code></pre>\n<ul>\n<li>Hoisting doesn&#39;t apply to let declarations</li>\n</ul>\n<pre><code class=\"lang-js\">{\nfoo();   <span class=\"hljs-comment\">//ERROR</span>\n<span class=\"hljs-keyword\">let</span> foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ <span class=\"hljs-comment\">//.. };                    </span>\n}\n</code></pre>\n<ul>\n<li>Guess what foo would return in ES5 or ES6. HINT: Block scoping and hoisting.</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (something) {\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"1\"</span> );\n}\n}\n<span class=\"hljs-keyword\">else</span> {\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"2\"</span> );\n}\n}\n\nfoo();        <span class=\"hljs-comment\">// ??</span>\n</code></pre>\n"},"05-spread-rest":{"body":"<h2 id=\"spread-rest\">Spread/Rest</h2>\n<ul>\n<li>Spread or Rest operator<code>...</code> </li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y,z)</span> </span>{\nconsole.<span class=\"hljs-built_in\">log</span>( x, y, z );\n}\n\nfoo( ...[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>] );                <span class=\"hljs-comment\">// 1 2 3</span>\n</code></pre>\n<ul>\n<li><p>When <code>...</code> is used in front of an array (actually, any <em>iterable</em>, which we cover in Chapter 3), it acts to &quot;spread&quot; it out into its individual values.</p>\n</li>\n<li><p>Another cool usage is to spread out/expand a value in other contexts as well, such as inside another array declaration:</p>\n</li>\n</ul>\n<pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\nvar b = [ <span class=\"hljs-number\">1</span>, ...a, <span class=\"hljs-number\">5</span> ];\n\nconsole.<span class=\"hljs-built_in\">log</span>( b );                    <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n</code></pre>\n<ul>\n<li>Another common usage is to <em>gather</em>.</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x, y, <span class=\"hljs-rest_arg\">...z</span>)</span> </span>{\nconsole.log( x, y, z );\n}\n\nfoo( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span> );            <span class=\"hljs-comment\">// 1 2 [3,4,5]</span>\n</code></pre>\n<ul>\n<li>if you don&#39;t have any named parameters, the <code>...</code> gathers all arguments:</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(<span class=\"hljs-rest_arg\">...args</span>)</span> </span>{\nconsole.log( args );\n}\n\nfoo( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>);            <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n</code></pre>\n"},"06-default-param":{"body":"<h3 id=\"default-parameter-values\">Default Parameter Values</h3>\n<ul>\n<li>We used to do this</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y)</span> </span>{\nx = x || <span class=\"hljs-number\">11</span>;\ny = y || <span class=\"hljs-number\">31</span>;\n\nconsole.<span class=\"hljs-built_in\">log</span>( x + y );\n}\n\nfoo();                <span class=\"hljs-comment\">// 42</span>\nfoo( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span> );        <span class=\"hljs-comment\">// 11</span>\nfoo( <span class=\"hljs-number\">5</span> );            <span class=\"hljs-comment\">// 36</span>\nfoo( null, <span class=\"hljs-number\">6</span> );        <span class=\"hljs-comment\">// 17</span>\n</code></pre>\n<ul>\n<li>There&#39;s a gotcha: </li>\n</ul>\n<pre><code class=\"lang-js\">foo( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">42</span> );        <span class=\"hljs-comment\">// 53 &lt;-- Oops, not 42</span>\n</code></pre>\n<ul>\n<li>Why? </li>\n</ul>\n<ul>\n<li>With all this in mind, we can now examine a nice helpful syntax added as of ES6 to streamline the assignment of default values to missing arguments:</li>\n</ul>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x = <span class=\"hljs-number\">11</span>, y = <span class=\"hljs-number\">31</span>)</span> </span>{\nconsole.<span class=\"hljs-built_in\">log</span>( x + y );\n}\n\nfoo();                    <span class=\"hljs-comment\">// 42</span>\nfoo( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span> );            <span class=\"hljs-comment\">// 11</span>\nfoo( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">42</span> );            <span class=\"hljs-comment\">// 42</span>\n\nfoo( <span class=\"hljs-number\">5</span> );                <span class=\"hljs-comment\">// 36</span>\nfoo( <span class=\"hljs-number\">5</span>, undefined );    <span class=\"hljs-comment\">// 36 &lt;-- `undefined` is missing</span>\nfoo( <span class=\"hljs-number\">5</span>, null );            <span class=\"hljs-comment\">// 5  &lt;-- null coerces to `0`</span>\n\nfoo( undefined, <span class=\"hljs-number\">6</span> );    <span class=\"hljs-comment\">// 17 &lt;-- `undefined` is missing</span>\nfoo( null, <span class=\"hljs-number\">6</span> );            <span class=\"hljs-comment\">// 6  &lt;-- null coerces to `0`</span>\n</code></pre>\n<ul>\n<li>Final Gotchas: <strong>Note:</strong> A rest/gather parameter (see &quot;Spread/Rest&quot;) cannot have a default value. So, while <code>function foo(...vals=[1,2,3]) {</code> might seem an intriguing capability, it&#39;s not valid syntax. You&#39;ll need to continue to apply that sort of logic manually if necessary.</li>\n</ul>\n<ul>\n<li>Default value expression.</li>\n</ul>\n"},"07-destructuring":{"body":""},"08-concise":{"body":"<h3 id=\"concise-properties\">Concise Properties</h3>\n<p>You&#39;re certainly familiar with declaring object literals in this form:</p>\n<pre><code class=\"lang-js\">var <span class=\"hljs-built_in\">x</span> = <span class=\"hljs-number\">2</span>, <span class=\"hljs-built_in\">y</span> = <span class=\"hljs-number\">3</span>,\no = {\n<span class=\"hljs-label\">x:</span> <span class=\"hljs-built_in\">x</span>,\n<span class=\"hljs-label\">y:</span> <span class=\"hljs-built_in\">y</span>\n}<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>If it&#39;s always felt redundant to say <code>x: x</code> all over, there&#39;s good news. If you need to define a property that is the same name as a lexical identifier, you can shorten it from <code>x: x</code> to <code>x</code>. Consider:</p>\n<pre><code class=\"lang-js\">var x = <span class=\"hljs-number\">2</span>, y = <span class=\"hljs-number\">3</span>,\no = {\nx,\ny\n};\n</code></pre>\n<h3 id=\"concise-methods\">Concise Methods</h3>\n<p>In a similar spirit to concise properties we just examined, functions attached to properties in object literals also have a concise form, for convenience.</p>\n<p>The old way:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o = {\nx: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n},\ny: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n}\n}\n</code></pre>\n<p>And as of ES6:</p>\n<pre><code class=\"lang-js\">var o = {\nx<span class=\"hljs-comment\">()</span> {\n<span class=\"hljs-comment\">// ..</span>\n},\ny<span class=\"hljs-comment\">()</span> {\n<span class=\"hljs-comment\">// ..</span>\n}\n}\n</code></pre>\n<p><strong>Warning:</strong> While <code>x() { .. }</code> seems to just be shorthand for <code>x: function(){ .. }</code>, concise methods have special behaviors that their older counterparts don&#39;t; specifically, the allowance for <code>super</code> (see &quot;Object <code>super</code>&quot; later in this chapter).</p>\n<p>Generators (see Chapter 4) also have a concise method form:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o</span> = {\n*foo() { .. }\n};\n</code></pre>\n<h4 id=\"concisely-unnamed\">Concisely Unnamed</h4>\n<p>While that convenience shorthand is quite attractive, there&#39;s a subtle gotcha to be aware of. To illustrate, let&#39;s examine pre-ES6 code like the following, which you might try to refactor to use concise methods:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">runSomething</span>(<span class=\"hljs-params\">o</span>) </span>{\n<span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-built_in\">Math</span>.random(),\ny = <span class=\"hljs-built_in\">Math</span>.random();\n\n<span class=\"hljs-keyword\">return</span> o.something( x, y );\n}\n\nrunSomething( {\nsomething: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">something</span>(<span class=\"hljs-params\">x,y</span>) </span>{\n<span class=\"hljs-keyword\">if</span> (x &gt; y) {\n<span class=\"hljs-comment\">// recursively call with `x`</span>\n<span class=\"hljs-comment\">// and `y` swapped</span>\n<span class=\"hljs-keyword\">return</span> something( y, x );\n}\n\n<span class=\"hljs-keyword\">return</span> y - x;\n}\n} );\n</code></pre>\n<p>This obviously silly code just generates two random numbers and subtracts the smaller from the bigger. But what&#39;s important here isn&#39;t what it does, but rather how it&#39;s defined. Let&#39;s focus on the object literal and function definition, as we see here:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">runSomething</span>( {\n<span class=\"hljs-tag\">something</span>: <span class=\"hljs-tag\">function</span> <span class=\"hljs-tag\">something</span>(x,y) {\n<span class=\"hljs-comment\">// ..</span>\n}\n} );\n</code></pre>\n<p>Why do we say both <code>something:</code> and <code>function something</code>? Isn&#39;t that redundant? Actually, no, both are needed for different purposes. The property <code>something</code> is how we can call <code>o.something(..)</code>, sort of like its public name. But the second <code>something</code> is a lexical name to refer to the function from inside itself, for recursion purposes.</p>\n<p>Can you see why the line <code>return something(y,x)</code> needs the name <code>something</code> to refer to the function? There&#39;s no lexical name for the object, such that it could have said <code>return o.something(y,x)</code> or something of that sort.</p>\n<p>That&#39;s actually a pretty common practice when the object literal does have an identifying name, such as:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-comment\">// ..</span>\ncontroller.makeRequest(..);\n}\n};\n</code></pre>\n<p>Is this a good idea? Perhaps, perhaps not. You&#39;re assuming that the name <code>controller</code> will always point to the object in question. But it very well may not -- the <code>makeRequest(..)</code> function doesn&#39;t control the outer code and so can&#39;t force that to be the case. This could come back to bite you.</p>\n<p>Others prefer to use <code>this</code> to define such things:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n<span class=\"hljs-keyword\">this</span>.makeRequest(..);\n}\n};\n</code></pre>\n<p>That looks fine, and should work if you always invoke the method as <code>controller.makeRequest(..)</code>. But you now have a <code>this</code> binding gotcha if you do something like:</p>\n<pre><code class=\"lang-js\">btn.addEventListener( <span class=\"hljs-string\">\"click\"</span>, controller.makeRequest, <span class=\"hljs-literal\">false</span> );\n</code></pre>\n<p>Of course, you can solve that by passing <code>controller.makeRequest.bind(controller)</code> as the handler reference to bind the event to. But yuck -- it isn&#39;t very appealing.</p>\n<p>Or what if your inner <code>this.makeRequest(..)</code> call needs to be made from a nested function? You&#39;ll have another <code>this</code> binding hazard, which people will often solve with the hacky <code>var self = this</code>, such as:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">self</span> = this;\n\nbtn.addEventListener( <span class=\"hljs-string\">\"click\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n<span class=\"hljs-keyword\">self</span>.makeRequest(..);\n}, <span class=\"hljs-keyword\">false</span> );\n}\n};\n</code></pre>\n<p>More yuck.</p>\n<p><strong>Note:</strong> For more information on <code>this</code> binding rules and gotchas, see Chapters 1-2 of the <em>this &amp; Object Prototypes</em> title of this series.</p>\n<p>OK, what does all this have to do with concise methods? Recall our <code>something(..)</code> method definition:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">runSomething</span>( {\n<span class=\"hljs-tag\">something</span>: <span class=\"hljs-tag\">function</span> <span class=\"hljs-tag\">something</span>(x,y) {\n<span class=\"hljs-comment\">// ..</span>\n}\n} );\n</code></pre>\n<p>The second <code>something</code> here provides a super convenient lexical identifier that will always point to the function itself, giving us the perfect reference for recursion, event binding/unbinding, and so on -- no messing around with <code>this</code> or trying to use an untrustable object reference.</p>\n<p>Great!</p>\n<p>So, now we try to refactor that function reference to this ES6 concise method form:</p>\n<pre><code class=\"lang-js\">runSomething<span class=\"hljs-list\">( {\nsomething<span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span>,y)</span> {\nif <span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span> &gt; y)</span> {\nreturn something<span class=\"hljs-list\">( <span class=\"hljs-keyword\">y</span>, x )</span><span class=\"hljs-comment\">;</span>\n}\n\nreturn y - x<span class=\"hljs-comment\">;</span>\n}\n} )</span><span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>Seems fine at first glance, except this code will break. The <code>return something(..)</code> call will not find a <code>something</code> identifier, so you&#39;ll get a <code>ReferenceError</code>. Oops. But why?</p>\n<p>The above ES6 snippet is interpreted as meaning:</p>\n<pre><code class=\"lang-js\">runSomething<span class=\"hljs-list\">( {\nsomething: function<span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span>,y)</span>{\nif <span class=\"hljs-list\">(<span class=\"hljs-keyword\">x</span> &gt; y)</span> {\nreturn something<span class=\"hljs-list\">( <span class=\"hljs-keyword\">y</span>, x )</span><span class=\"hljs-comment\">;</span>\n}\n\nreturn y - x<span class=\"hljs-comment\">;</span>\n}\n} )</span><span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>Look closely. Do you see the problem? The concise method definition implies <code>something: function(x,y)</code>. See how the second <code>something</code> we were relying on has been omitted? In other words, concise methods imply anonymous function expressions.</p>\n<p>Yeah, yuck.</p>\n<p><strong>Note:</strong> You may be tempted to think that <code>=&gt;</code> arrow functions are a good solution here, but they&#39;re equally insufficient, as they&#39;re also anonymous function expressions. We&#39;ll cover them in &quot;Arrow Functions&quot; later in this chapter.</p>\n<p>The partially redeeming news is that our <code>something(x,y)</code> concise method won&#39;t be totally anonymous. See &quot;Function Names&quot; in Chapter 7 for information about ES6 function name inference rules. That won&#39;t help us for our recursion, but it helps with debugging at least.</p>\n<p>So what are we left to conclude about concise methods? They&#39;re short and sweet, and a nice convenience. But you should only use them if you&#39;re never going to need them to do recursion or event binding/unbinding. Otherwise, stick to your old-school <code>something: function something(..)</code> method definitions.</p>\n<p>A lot of your methods are probably going to benefit from concise method definitions, so that&#39;s great news! Just be careful of the few where there&#39;s an un-naming hazard.</p>\n"},"09-template-literals":{"body":""},"ch2":{"body":"<h2 id=\"destructuring\">Destructuring</h2>\n<p>ES6 introduces a new syntactic feature called <em>destructuring</em>, which may be a little less confusing if you instead think of it as <em>structured assignment</em>. To understand this meaning, consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-keyword\">return</span> [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\n}\n\nvar tmp = foo(),\na = tmp[<span class=\"hljs-number\">0</span>], b = tmp[<span class=\"hljs-number\">1</span>], c = tmp[<span class=\"hljs-number\">2</span>];\n\nconsole.<span class=\"hljs-built_in\">log</span>( a, b, c );                <span class=\"hljs-comment\">// 1 2 3</span>\n</code></pre>\n<p>As you can see, we created a manual assignment of the values in the array that <code>foo()</code> returns to individual variables <code>a</code>, <code>b</code>, and <code>c</code>, and to do so we (unfortunately) needed the <code>tmp</code> variable.</p>\n<p>Similarly, we can do the following with objects:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-keyword\">return</span> {\nx: <span class=\"hljs-number\">4</span>,\ny: <span class=\"hljs-number\">5</span>,\nz: <span class=\"hljs-number\">6</span>\n};\n}\n\nvar tmp = bar(),\nx = tmp.x, y = tmp.y, z = tmp.z;\n\nconsole.<span class=\"hljs-built_in\">log</span>( x, y, z );                <span class=\"hljs-comment\">// 4 5 6</span>\n</code></pre>\n<p>The <code>tmp.x</code> property value is assigned to the <code>x</code> variable, and likewise for <code>tmp.y</code> to <code>y</code> and <code>tmp.z</code> to <code>z</code>.</p>\n<p>Manually assigning indexed values from an array or properties from an object can be thought of as <em>structured assignment</em>. ES6 adds a dedicated syntax for <em>destructuring</em>, specifically <em>array destructuring</em> and <em>object destructuring</em>. This syntax eliminates the need for the <code>tmp</code> variable in the previous snippets, making them much cleaner. Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> [ a, b, c ] = foo();\n<span class=\"hljs-keyword\">var</span> { x: x, y: y, z: z } = bar();\n\n<span class=\"hljs-built_in\">console</span>.log( a, b, c );                <span class=\"hljs-comment\">// 1 2 3</span>\n<span class=\"hljs-built_in\">console</span>.log( x, y, z );                <span class=\"hljs-comment\">// 4 5 6</span>\n</code></pre>\n<p>You&#39;re likely more accustomed to seeing syntax like <code>[a,b,c]</code> on the righthand side of an <code>=</code> assignment, as the value being assigned.</p>\n<p>Destructuring symmetrically flips that pattern, so that <code>[a,b,c]</code> on the lefthand side of the <code>=</code> assignment is treated as a kind of &quot;pattern&quot; for decomposing the righthand side array value into separate variable assignments.</p>\n<p>Similarly, <code>{ x: x, y: y, z: z }</code> specifies a &quot;pattern&quot; to decompose the object value from <code>bar()</code> into separate variable assignments.</p>\n<h3 id=\"object-property-assignment-pattern\">Object Property Assignment Pattern</h3>\n<p>Let&#39;s dig into that <code>{ x: x, .. }</code> syntax from the previous snippet. If the property name being matched is the same as the variable you want to declare, you can actually shorten the syntax:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> { x, y, z } = bar();\n\n<span class=\"hljs-built_in\">console</span>.log( x, y, z );                <span class=\"hljs-comment\">// 4 5 6</span>\n</code></pre>\n<p>Pretty cool, right?</p>\n<p>But is <code>{ x, .. }</code> leaving off the <code>x:</code> part or leaving off the <code>: x</code> part? We&#39;re actually leaving off the <code>x:</code> part when we use the shorter syntax. That may not seem like an important detail, but you&#39;ll understand its importance in just a moment.</p>\n<p>If you can write the shorter form, why would you ever write out the longer form? Because that longer form actually allows you to assign a property to a different variable name, which can sometimes be quite useful:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-label\">var</span> { x: <span class=\"hljs-keyword\">bam, </span>y: <span class=\"hljs-keyword\">baz, </span>z: <span class=\"hljs-keyword\">bap </span>} = <span class=\"hljs-keyword\">bar();\n</span>\n<span class=\"hljs-label\">console.log</span>( <span class=\"hljs-keyword\">bam, </span><span class=\"hljs-keyword\">baz, </span><span class=\"hljs-keyword\">bap </span>)<span class=\"hljs-comment\">;        // 4 5 6</span>\n<span class=\"hljs-label\">console.log</span>( x, y, z )<span class=\"hljs-comment\">;                // ReferenceError</span>\n</code></pre>\n<p>There&#39;s a subtle but super-important quirk to understand about this variation of the object destructuring form. To illustrate why it can be a gotcha you need to be careful of, let&#39;s consider the &quot;pattern&quot; of how normal object literals are specified:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> X</span> = <span class=\"hljs-number\">10</span>, Y = <span class=\"hljs-number\">20</span>;\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o</span> = { a: X, b: Y };\n\nconsole.log( o.a, o.b );            <span class=\"hljs-comment\">// 10 20</span>\n</code></pre>\n<p>In <code>{ a: X, b: Y }</code>, we know that <code>a</code> is the object property, and <code>X</code> is the source value that gets assigned to it. In other words, the syntactic pattern is <code>target: source</code>, or more obviously, <code>property-alias: value</code>. We intuitively understand this because it&#39;s the same as <code>=</code> assignment, where the pattern is <code>target = source</code>.</p>\n<p>However, when you use object destructuring assignment -- that is, putting the <code>{ .. }</code> object literal-looking syntax on the lefthand side of the <code>=</code> operator -- you invert that <code>target: source</code> pattern.</p>\n<p>Recall:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">var</span> <span class=\"hljs-rules\">{ <span class=\"hljs-rule\"><span class=\"hljs-attribute\">x</span>:<span class=\"hljs-value\"> bam, y: baz, z: bap } = <span class=\"hljs-function\">bar</span>()</span></span>;</span>\n</code></pre>\n<p>The syntactic pattern here is <code>source: target</code> (or <code>value: variable-alias</code>). <code>x: bam</code> means the <code>x</code> property is the source value and <code>bam</code> is the target variable to assign to. In other words, object literals are <code>target &lt;-- source</code>, and object destructuring assignments are <code>source --&gt; target</code>. See how that&#39;s flipped?</p>\n<p>There&#39;s another way to think about this syntax though, which may help ease the confusion. Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> aa</span> = <span class=\"hljs-number\">10</span>, bb = <span class=\"hljs-number\">20</span>;\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o</span> = { x: aa, y: bb };\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span>     { x</span>: AA, y: BB } = o;\n\nconsole.log( AA, BB );                <span class=\"hljs-comment\">// 10 20</span>\n</code></pre>\n<p>In the <code>{ x: aa, y: bb }</code> line, the <code>x</code> and <code>y</code> represent the object properties. In the <code>{ x: AA, y: BB }</code> line, the <code>x</code> and the <code>y</code> <em>also</em> represent the object properties.</p>\n<p>Recall how earlier I asserted that <code>{ x, .. }</code> was leaving off the <code>x:</code> part? In those two lines, if you erase the <code>x:</code> and <code>y:</code> parts in that snippet, you&#39;re left only with <code>aa, bb</code> and <code>AA, BB</code>, which in effect -- only conceptually, not actually -- are assignments from <code>aa</code> to <code>AA</code> and from <code>bb</code> to <code>BB</code>.</p>\n<p>So, that symmetry may help to explain why the syntactic pattern was intentionally flipped for this ES6 feature.</p>\n<p><strong>Note:</strong> I would have preferred the syntax to be <code>{ AA: x , BB: y }</code> for the destructuring assignment, as that would have preserved consistency of the more familiar <code>target: source</code> pattern for both usages. Alas, I&#39;m having to train my brain for the inversion, as some readers may also have to do.</p>\n<h3 id=\"not-just-declarations\">Not Just Declarations</h3>\n<p>So far, we&#39;ve used destructuring assignment with <code>var</code> declarations (of course, they could also use <code>let</code> and <code>const</code>), but destructuring is a general assignment operation, not just a declaration.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a, b, <span class=\"hljs-built_in\">c</span>, x, y, z;\n\n[a,b,<span class=\"hljs-built_in\">c</span>] = foo();\n( { x, y, z } = bar() );\n\nconsole.log( a, b, <span class=\"hljs-built_in\">c</span> );                <span class=\"hljs-comment\">// 1 2 3</span>\nconsole.log( x, y, z );                <span class=\"hljs-comment\">// 4 5 6</span>\n</code></pre>\n<p>The variables can already be declared, and then the destructuring only does assignments, exactly as we&#39;ve already seen.</p>\n<p><strong>Note:</strong> For the object destructuring form specifically, when leaving off a <code>var</code>/<code>let</code>/<code>const</code> declarator, we had to surround the whole assignment expression in <code>( )</code>, because otherwise the <code>{ .. }</code> on the lefthand side as the first element in the statement is taken to be a block statement instead of an object.</p>\n<p>In fact, the assignment expressions (<code>a</code>, <code>y</code>, etc.) don&#39;t actually need to be just variable identifiers. Anything that&#39;s a valid assignment expression is allowed. For example:</p>\n<pre><code class=\"lang-js\">var o = {}<span class=\"hljs-comment\">;</span>\n\n[o.a, o.b, o.c] = foo()<span class=\"hljs-comment\">;</span>\n( { x: o.x, y: o.y, z: o.z } = bar() )<span class=\"hljs-comment\">;</span>\n\nconsole.log( o.a, o.b, o.c )<span class=\"hljs-comment\">;        // 1 2 3</span>\nconsole.log( o.x, o.y, o.z )<span class=\"hljs-comment\">;        // 4 5 6</span>\n</code></pre>\n<p>You can even use computed property expressions in the destructuring. Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">which</span> = <span class=\"hljs-string\">\"x\"</span>,\no = {};\n\n( { [<span class=\"hljs-keyword\">which</span>]: o[<span class=\"hljs-keyword\">which</span>] } = bar() );\n\nconsole.<span class=\"hljs-literal\">log</span>( o.x );                    <span class=\"hljs-comment\">// 4</span>\n</code></pre>\n<p>The <code>[which]:</code> part is the computed property, which results in <code>x</code> -- the property to destructure from the object in question as the source of the assignment. The <code>o[which]</code> part is just a normal object key reference, which equates to <code>o.x</code> as the target of the assignment.</p>\n<p>You can use the general assignments to create object mappings/transformations, such as:</p>\n<pre><code class=\"lang-js\">var o1 = { <span class=\"hljs-string\">a:</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">b:</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">c:</span> <span class=\"hljs-number\">3</span> },\no2 = {};\n\n( { <span class=\"hljs-string\">a:</span> o2.x, <span class=\"hljs-string\">b:</span> o2.y, <span class=\"hljs-string\">c:</span> o2.z } = o1 );\n\nconsole.log( o2.x, o2.y, o2.z );    <span class=\"hljs-comment\">// 1 2 3</span>\n</code></pre>\n<p>Or you can map an object to an array, such as:</p>\n<pre><code class=\"lang-js\">var o1 = { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span>, c: <span class=\"hljs-number\">3</span> },\na2 = [];\n\n( { a: a2[<span class=\"hljs-number\">0</span>], b: a2[<span class=\"hljs-number\">1</span>], c: a2[<span class=\"hljs-number\">2</span>] } = o1 );\n\nconsole.<span class=\"hljs-built_in\">log</span>( a2 );                    <span class=\"hljs-comment\">// [1,2,3]</span>\n</code></pre>\n<p>Or the other way around:</p>\n<pre><code class=\"lang-js\">var a1 = [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> ],\no2 = {};\n\n[ o2.a, o2.b, o2.c ] = a1;\n\nconsole.<span class=\"hljs-built_in\">log</span>( o2.a, o2.b, o2.c );    <span class=\"hljs-comment\">// 1 2 3</span>\n</code></pre>\n<p>Or you could reorder one array to another:</p>\n<pre><code class=\"lang-js\">var a1 = [ <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> ],\na2 = [];\n\n[ a2[<span class=\"hljs-number\">2</span>], a2[<span class=\"hljs-number\">0</span>], a2[<span class=\"hljs-number\">1</span>] ] = a1;\n\nconsole.<span class=\"hljs-built_in\">log</span>( a2 );                    <span class=\"hljs-comment\">// [2,3,1]</span>\n</code></pre>\n<p>You can even solve the traditional &quot;swap two variables&quot; task without a temporary variable:</p>\n<pre><code class=\"lang-js\">var x = <span class=\"hljs-number\">10</span>, y = <span class=\"hljs-number\">20</span>;\n\n[ y, x ] = [ x, y ];\n\nconsole.<span class=\"hljs-built_in\">log</span>( x, y );                <span class=\"hljs-comment\">// 20 10</span>\n</code></pre>\n<p><strong>Warning:</strong> Be careful: you shouldn&#39;t mix in declaration with assignment unless you want all of the assignment expressions <em>also</em> to be treated as declarations. Otherwise, you&#39;ll get syntax errors. That&#39;s why in the earlier example I had to do <code>var a2 = []</code> separately from the <code>[ a2[0], .. ] = ..</code> destructuring assignment. It wouldn&#39;t make any sense to try <code>var [ a2[0], .. ] = ..</code>, because <code>a2[0]</code> isn&#39;t a valid declaration identifier; it also obviously couldn&#39;t implicitly create a <code>var a2 = []</code> declaration to use.</p>\n<h3 id=\"repeated-assignments\">Repeated Assignments</h3>\n<p>The object destructuring form allows a source property (holding any value type) to be listed multiple times. For example:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-comment\">{ a: X, a: Y }</span> = <span class=\"hljs-comment\">{ a: 1 }</span>;\n\nX;    <span class=\"hljs-comment\">// 1</span>\nY;    <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>That also means you can both destructure a sub-object/array property and also capture the sub-object/array&#39;s value itself. Consider:</p>\n<pre><code class=\"lang-js\">var { a: { x: <span class=\"hljs-keyword\">X</span>, x: <span class=\"hljs-keyword\">Y</span> }, a } = { a: { x: <span class=\"hljs-number\">1</span> } };\n\n<span class=\"hljs-keyword\">X</span>;    <span class=\"hljs-comment\">// 1\nY;</span>    <span class=\"hljs-comment\">// 1\na;</span>    <span class=\"hljs-comment\">// { x: 1 }\n\n( { a: X, a: Y, a: [ Z ] } = { a: [ 1 ] } );</span>\n\n<span class=\"hljs-keyword\">X</span>.push( <span class=\"hljs-number\">2</span> );\n<span class=\"hljs-keyword\">Y</span>[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">10</span>;\n\n<span class=\"hljs-keyword\">X</span>;    <span class=\"hljs-comment\">// [10,2]\nY;</span>    <span class=\"hljs-comment\">// [10,2]\nZ;</span>    <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>A word of caution about destructuring: it may be tempting to list destructuring assignments all on a single line as has been done thus far in our discussion. However, it&#39;s a much better idea to spread destructuring assignment patterns over multiple lines, using proper indentation -- much like you would in JSON or with an object literal value -- for readability sake.</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// harder to read:</span>\n<span class=\"hljs-keyword\">var</span> { a: { b: [ c, <span class=\"hljs-keyword\">d</span> ], <span class=\"hljs-keyword\">e</span>: { f } }, <span class=\"hljs-keyword\">g</span> } = obj;\n\n<span class=\"hljs-comment\">// better:</span>\n<span class=\"hljs-keyword\">var</span> {\na: {\nb: [ c, <span class=\"hljs-keyword\">d</span> ],\n<span class=\"hljs-keyword\">e</span>: { f }\n},\n<span class=\"hljs-keyword\">g</span>\n} = obj;\n</code></pre>\n<p>Remember: <strong>the purpose of destructuring is not just less typing, but more declarative readability.</strong></p>\n<h4 id=\"destructuring-assignment-expressions\">Destructuring Assignment Expressions</h4>\n<p>The assignment expression with object or array destructuring has as its completion value the full righthand object/array value. Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o = { a:<span class=\"hljs-number\">1</span>, b:<span class=\"hljs-number\">2</span>, <span class=\"hljs-built_in\">c</span>:<span class=\"hljs-number\">3</span> },\na, b, <span class=\"hljs-built_in\">c</span>, p;\n\np = { a, b, <span class=\"hljs-built_in\">c</span> } = o;\n\nconsole.log( a, b, <span class=\"hljs-built_in\">c</span> );            <span class=\"hljs-comment\">// 1 2 3</span>\np === o;                        <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>In the previous snippet, <code>p</code> was assigned the <code>o</code> object reference, not one of the <code>a</code>, <code>b</code>, or <code>c</code> values. The same is true of array destructuring:</p>\n<pre><code class=\"lang-js\">var o = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>],\na, b, c, p;\n\np = [ a, b, c ] = o;\n\nconsole.<span class=\"hljs-built_in\">log</span>( a, b, c );            <span class=\"hljs-comment\">// 1 2 3</span>\np === o;                        <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>By carrying the object/array value through as the completion, you can chain destructuring assignment expressions together:</p>\n<pre><code class=\"lang-js\">var o = { a:<span class=\"hljs-number\">1</span>, b:<span class=\"hljs-number\">2</span>, c:<span class=\"hljs-number\">3</span> },\np = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>],\na, b, c, x, y, z;\n\n( {a} = {b,c} = o );\n[x,y] = [z] = p;\n\nconsole.<span class=\"hljs-built_in\">log</span>( a, b, c );            <span class=\"hljs-comment\">// 1 2 3</span>\nconsole.<span class=\"hljs-built_in\">log</span>( x, y, z );            <span class=\"hljs-comment\">// 4 5 4</span>\n</code></pre>\n<h3 id=\"too-many-too-few-just-enough\">Too Many, Too Few, Just Enough</h3>\n<p>With both array destructuring assignment and object destructuring assignment, you do not have to assign all the values that are present. For example:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> [,b]</span> = foo();\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> { x, z }</span> = bar();\n\nconsole.log( b, x, z );                <span class=\"hljs-comment\">// 2 4 6</span>\n</code></pre>\n<p>The <code>1</code> and <code>3</code> values that came back from <code>foo()</code> are discarded, as is the <code>5</code> value from <code>bar()</code>.</p>\n<p>Similarly, if you try to assign more values than are present in the value you&#39;re destructuring/decomposing, you get graceful fallback to <code>undefined</code>, as you&#39;d expect:</p>\n<pre><code class=\"lang-js\">var [,,c,d] = foo()<span class=\"hljs-comment\">;</span>\nvar { w, z } = bar()<span class=\"hljs-comment\">;</span>\n\nconsole.log( c, z )<span class=\"hljs-comment\">;                // 3 6</span>\nconsole.log( d, w )<span class=\"hljs-comment\">;                // undefined undefined</span>\n</code></pre>\n<p>This behavior follows symmetrically from the earlier stated &quot;<code>undefined</code> is missing&quot; principle.</p>\n<p>We examined the <code>...</code> operator earlier in this chapter, and saw that it can sometimes be used to spread an array value out into its separate values, and sometimes it can be used to do the opposite: to gather a set of values together into an array.</p>\n<p>In addition to the gather/rest usage in function declarations, <code>...</code> can perform the same behavior in destructuring assignments. To illustrate, let&#39;s recall a snippet from earlier in this chapter:</p>\n<pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\nvar b = [ <span class=\"hljs-number\">1</span>, ...a, <span class=\"hljs-number\">5</span> ];\n\nconsole.<span class=\"hljs-built_in\">log</span>( b );                    <span class=\"hljs-comment\">// [1,2,3,4,5]</span>\n</code></pre>\n<p>Here we see that <code>...a</code> is spreading <code>a</code> out, because it appears in the array <code>[ .. ]</code> value position. If <code>...a</code> appears in an array destructuring position, it performs the gather behavior:</p>\n<pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>];\nvar [ b, ...c ] = a;\n\nconsole.<span class=\"hljs-built_in\">log</span>( b, c );                <span class=\"hljs-comment\">// 2 [3,4]</span>\n</code></pre>\n<p>The <code>var [ .. ] = a</code> destructuring assignment spreads <code>a</code> out to be assigned to the pattern described inside the <code>[ .. ]</code>. The first part names <code>b</code> for the first value in <code>a</code> (<code>2</code>). But then <code>...c</code> gathers the rest of the values (<code>3</code> and <code>4</code>) into an array and calls it <code>c</code>.</p>\n<p><strong>Note:</strong> We&#39;ve seen how <code>...</code> works with arrays, but what about with objects? It&#39;s not an ES6 feature, but see Chapter 8 for discussion of a possible &quot;beyond ES6&quot; feature where <code>...</code> works with spreading or gathering objects.</p>\n<h3 id=\"nested-destructuring\">Nested Destructuring</h3>\n<p>If the values you&#39;re destructuring have nested objects or arrays, you can destructure those nested values as well:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a1 = [ 1, [2, 3, 4], 5 ];\n<span class=\"hljs-keyword\">var</span> o1 = { x: { y: { z: 6 } } };\n\n<span class=\"hljs-keyword\">var</span> [ a, [ b, c, <span class=\"hljs-keyword\">d</span> ], <span class=\"hljs-keyword\">e</span> ] = a1;\n<span class=\"hljs-keyword\">var</span> { x: { y: { z: w } } } = o1;\n\nconsole.<span class=\"hljs-literal\">log</span>( a, b, c, <span class=\"hljs-keyword\">d</span>, <span class=\"hljs-keyword\">e</span> );        <span class=\"hljs-comment\">// 1 2 3 4 5</span>\nconsole.<span class=\"hljs-literal\">log</span>( w );                    <span class=\"hljs-comment\">// 6</span>\n</code></pre>\n<p>Nested destructuring can be a simple way to flatten out object namespaces. For example:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> App = {\nmodel: {\nUser: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{ .. }\n}\n};\n\n<span class=\"hljs-comment\">// instead of:</span>\n<span class=\"hljs-comment\">// var User = App.model.User;</span>\n\n<span class=\"hljs-keyword\">var</span> { model: { User } } = App;\n</code></pre>\n<h3 id=\"destructuring-parameters\">Destructuring Parameters</h3>\n<p>In the following snippet, can you spot the assignment?</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x)</span> <span class=\"hljs-comment\">{\nconsole.log( x );\n}</span>\n\n<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">( 42 )</span>;</span>\n</code></pre>\n<p>The assignment is kinda hidden: <code>42</code> (the argument) is assigned to <code>x</code> (the parameter) when <code>foo(42)</code> is executed. If parameter/argument pairing is an assignment, then it stands to reason that it&#39;s an assignment that could be destructured, right? Of course!</p>\n<p>Consider array destructuring for parameters:</p>\n<pre><code class=\"lang-js\">function <span class=\"hljs-function\">foo</span>( <span class=\"hljs-attr_selector\">[ x, y ]</span> ) {\nconsole<span class=\"hljs-class\">.log</span>( x, y );\n}\n\n<span class=\"hljs-function\">foo</span>( <span class=\"hljs-attr_selector\">[ 1, 2 ]</span> );                    <span class=\"hljs-comment\">// 1 2</span>\n<span class=\"hljs-function\">foo</span>( <span class=\"hljs-attr_selector\">[ 1 ]</span> );                        <span class=\"hljs-comment\">// 1 undefined</span>\n<span class=\"hljs-function\">foo</span>( <span class=\"hljs-attr_selector\">[]</span> );                            <span class=\"hljs-comment\">// undefined undefined</span>\n</code></pre>\n<p>Object destructuring for parameters works, too:</p>\n<pre><code class=\"lang-js\">function <span class=\"hljs-function\">foo</span>( { x, y } ) {\nconsole<span class=\"hljs-class\">.log</span>( x, y );\n}\n\n<span class=\"hljs-function\">foo</span>( { y<span class=\"hljs-value\">: <span class=\"hljs-number\">1</span>, x: <span class=\"hljs-number\">2</span> } );</span>                <span class=\"hljs-comment\">// 2 1</span>\n<span class=\"hljs-function\">foo</span>( { y<span class=\"hljs-value\">: <span class=\"hljs-number\">42</span> } );</span>                    <span class=\"hljs-comment\">// undefined 42</span>\n<span class=\"hljs-function\">foo</span>( {} );                            <span class=\"hljs-comment\">// undefined undefined</span>\n</code></pre>\n<p>This technique is an approximation of named arguments (a long requested feature for JS!), in that the properties on the object map to the destructured parameters of the same names. That also means that we get optional parameters (in any position) for free, as you can see leaving off the <code>x</code> &quot;parameter&quot; worked as we&#39;d expect.</p>\n<p>Of course, all the previously discussed variations of destructuring are available to us with parameter destructuring, including nested destructuring, default values, and more. Destructuring also mixes fine with other ES6 function parameter capabilities, like default parameter values and rest/gather parameters.</p>\n<p>Consider these quick illustrations (certainly not exhaustive of the possible variations):</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f1</span><span class=\"hljs-params\">([ x=2, y=3, z ])</span> </span>{ .. }\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f2</span><span class=\"hljs-params\">([ x, y, <span class=\"hljs-rest_arg\">...z</span>], w)</span> </span>{ .. }\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">([ x, y, <span class=\"hljs-rest_arg\">...z</span>], <span class=\"hljs-rest_arg\">...w</span>)</span> </span>{ .. }\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f4</span><span class=\"hljs-params\">({ x: X, y })</span> </span>{ .. }\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f5</span><span class=\"hljs-params\">({ x: X = 10, y = 20 })</span> </span>{ .. }\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f6</span><span class=\"hljs-params\">({ x = 10 } = {}, { y } = { y: 10 })</span> </span>{ .. }\n</code></pre>\n<p>Let&#39;s take one example from this snippet and examine it, for illustration purposes:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f3</span><span class=\"hljs-params\">([ x, y, <span class=\"hljs-rest_arg\">...z</span>], <span class=\"hljs-rest_arg\">...w</span>)</span> </span>{\nconsole.log( x, y, z, w );\n}\n\nf3( [] );                            <span class=\"hljs-comment\">// undefined undefined [] []</span>\nf3( [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>], <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span> );                <span class=\"hljs-comment\">// 1 2 [3,4] [5,6]</span>\n</code></pre>\n<p>There are two <code>...</code> operators in use here, and they&#39;re both gathering values in arrays (<code>z</code> and <code>w</code>), though <code>...z</code> gathers from the rest of the values left over in the first array argument, while <code>...w</code> gathers from the rest of the main arguments left over after the first.</p>\n<h4 id=\"destructuring-defaults-parameter-defaults\">Destructuring Defaults + Parameter Defaults</h4>\n<p>There&#39;s one subtle point you should be particularly careful to notice -- the difference in behavior between a destructuring default value and a function parameter default value. For example:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">function</span> f6({ x = <span class=\"hljs-number\">10</span> } = {}, { y } = { y: <span class=\"hljs-number\">10</span> }) {\nconsole.log( x, y );\n}\n\nf6();                                // <span class=\"hljs-number\">10</span> <span class=\"hljs-number\">10</span>\n</code></pre>\n<p>At first, it would seem that we&#39;ve declared a default value of <code>10</code> for both the <code>x</code> and <code>y</code> parameters, but in two different ways. However, these two different approaches will behave differently in certain cases, and the difference is awfully subtle.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-tag\">f6</span>( {}, {} );                        <span class=\"hljs-comment\">// 10 undefined</span>\n</code></pre>\n<p>Wait, why did that happen? It&#39;s pretty clear that named parameter <code>x</code> is defaulting to <code>10</code> if not passed as a property of that same name in the first argument&#39;s object.</p>\n<p>But what about <code>y</code> being <code>undefined</code>? The <code>{ y: 10 }</code> value is an object as a function parameter default value, not a destructuring default value. As such, it only applies if the second argument is not passed at all, or is passed as <code>undefined</code>.</p>\n<p>In the previous snippet, we <em>are</em> passing a second argument (<code>{}</code>), so the default <code>{ y: 10 }</code> value is not used, and the <code>{ y }</code> destructuring occurs against the passed in <code>{}</code> empty object value.</p>\n<p>Now, compare <code>{ y } = { y: 10 }</code> to <code>{ x = 10 } = {}</code>.</p>\n<p>For the <code>x</code>&#39;s form usage, if the first function argument is omitted or <code>undefined</code>, the <code>{}</code> empty object default applies. Then, whatever value is in the first argument position -- either the default <code>{}</code> or whatever you passed in -- is destructured with the <code>{ x = 10 }</code>, which checks to see if an <code>x</code> property is found, and if not found (or <code>undefined</code>), the <code>10</code> default value is applied to the <code>x</code> named parameter.</p>\n<p>Deep breath. Read back over those last few paragraphs a couple of times. Let&#39;s review via code:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">f6</span>(<span class=\"hljs-params\">{ x = 10 } = {}, { y } = { y: 10 }</span>) </span>{\n<span class=\"hljs-built_in\">console</span>.log( x, y );\n}\n\nf6();                                <span class=\"hljs-comment\">// 10 10</span>\nf6( <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span> );            <span class=\"hljs-comment\">// 10 10</span>\nf6( {}, <span class=\"hljs-literal\">undefined</span> );                <span class=\"hljs-comment\">// 10 10</span>\n\nf6( {}, {} );                        <span class=\"hljs-comment\">// 10 undefined</span>\nf6( <span class=\"hljs-literal\">undefined</span>, {} );                <span class=\"hljs-comment\">// 10 undefined</span>\n\nf6( { x: <span class=\"hljs-number\">2</span> }, { y: <span class=\"hljs-number\">3</span> } );            <span class=\"hljs-comment\">// 2 3</span>\n</code></pre>\n<p>It would generally seem that the defaulting behavior of the <code>x</code> parameter is probably the more desirable and sensible case compared to that of <code>y</code>. As such, it&#39;s important to understand why and how <code>{ x = 10 } = {}</code> form is different from <code>{ y } = { y: 10 }</code> form.</p>\n<p>If that&#39;s still a bit fuzzy, go back and read it again, and play with this yourself. Your future self will thank you for taking the time to get this very subtle gotcha nuance detail straight.</p>\n<h4 id=\"nested-defaults-destructured-and-restructured\">Nested Defaults: Destructured and Restructured</h4>\n<p>Although it may at first be difficult to grasp, an interesting idiom emerges for setting defaults for a nested object&#39;s properties: using object destructuring along with what I&#39;d call <em>restructuring</em>.</p>\n<p>Consider a set of defaults in a nested object structure, like the following:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-comment\">// taken from: http://es-discourse.com/t/partial-default-arguments/120/7</span>\n\nvar defaults = {\n<span class=\"hljs-string\">options:</span> {\n<span class=\"hljs-string\">remove:</span> <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-string\">enable:</span> <span class=\"hljs-literal\">false</span>,\n<span class=\"hljs-string\">instance:</span> {}\n},\n<span class=\"hljs-string\">log:</span> {\n<span class=\"hljs-string\">warn:</span> <span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-string\">error:</span> <span class=\"hljs-literal\">true</span>\n}\n};\n</code></pre>\n<p>Now, let&#39;s say that you have an object called <code>config</code>, which has some of these applied, but perhaps not all, and you&#39;d like to set all the defaults into this object in the missing spots, but not override specific settings already present:</p>\n<pre><code class=\"lang-js\">var config = {\n<span class=\"hljs-string\">options:</span> {\n<span class=\"hljs-string\">remove:</span> <span class=\"hljs-literal\">false</span>,\n<span class=\"hljs-string\">instance:</span> <span class=\"hljs-literal\">null</span>\n}\n};\n</code></pre>\n<p>You can of course do so manually, as you might have done in the past:</p>\n<pre><code class=\"lang-js\">config.<span class=\"hljs-keyword\">options</span> = config.<span class=\"hljs-keyword\">options</span> || {};\nconfig.<span class=\"hljs-keyword\">options</span>.remove = (config.<span class=\"hljs-keyword\">options</span>.remove !== undefined) ?\nconfig.<span class=\"hljs-keyword\">options</span>.remove : defaults.<span class=\"hljs-keyword\">options</span>.remove;\nconfig.<span class=\"hljs-keyword\">options</span>.enable = (config.<span class=\"hljs-keyword\">options</span>.enable !== undefined) ?\nconfig.<span class=\"hljs-keyword\">options</span>.enable : defaults.<span class=\"hljs-keyword\">options</span>.enable;\n...\n</code></pre>\n<p>Yuck.</p>\n<p>Others may prefer the assign-overwrite approach to this task. You might be tempted by the ES6 <code>Object.assign(..)</code> utility (see Chapter 6) to clone the properties first from <code>defaults</code> and then overwritten with the cloned properties from <code>config</code>, as so:</p>\n<pre><code class=\"lang-js\">config = Object.<span class=\"hljs-built_in\">assign</span>( {}, defaults, config )<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>That looks way nicer, huh? But there&#39;s a major problem! <code>Object.assign(..)</code> is shallow, which means when it copies <code>defaults.options</code>, it just copies that object reference, not deep cloning that object&#39;s properties to a <code>config.options</code> object. <code>Object.assign(..)</code> would need to be applied (sort of &quot;recursively&quot;) at all levels of your object&#39;s tree to get the deep cloning you&#39;re expecting.</p>\n<p><strong>Note:</strong> Many JS utility libraries/frameworks provide their own option for deep cloning of an object, but those approaches and their gotchas are beyond our scope to discuss here.</p>\n<p>So let&#39;s examine if ES6 object destructuring with defaults can help at all:</p>\n<pre><code class=\"lang-js\">config.options = config.options || {};\nconfig.<span class=\"hljs-keyword\">log</span> = config.<span class=\"hljs-keyword\">log</span> || {};\n{\noptions: {\nremove: config.options.remove = <span class=\"hljs-keyword\">default</span>.options.remove,\nenable: config.options.enable = <span class=\"hljs-keyword\">default</span>.options.enable,\n<span class=\"hljs-keyword\">instance</span>: config.options.<span class=\"hljs-keyword\">instance</span> = <span class=\"hljs-keyword\">default</span>.options.<span class=\"hljs-keyword\">instance</span>\n} = {},\n<span class=\"hljs-keyword\">log</span>: {\nwarn: config.<span class=\"hljs-keyword\">log</span>.warn = <span class=\"hljs-keyword\">default</span>.<span class=\"hljs-keyword\">log</span>.warn,\n<span class=\"hljs-keyword\">error</span>: config.<span class=\"hljs-keyword\">log</span>.<span class=\"hljs-keyword\">error</span> = <span class=\"hljs-keyword\">default</span>.<span class=\"hljs-keyword\">log</span>.<span class=\"hljs-keyword\">error</span>\n} = {}\n} = config;\n</code></pre>\n<p>Not as nice as the false promise of <code>Object.assign(..)</code> (being that it&#39;s shallow only), but it&#39;s better than the manual approach by a fair bit, I think. It is still unfortunately verbose and repetitive, though.</p>\n<p>The previous snippet&#39;s approach works because I&#39;m hacking the destructuring and defaults mechansim to do the property <code>=== undefined</code> checks and assignment decisions for me. It&#39;s a trick in that I&#39;m destructuring <code>config</code> (see the <code>= config</code> at the end of the snippet), but I&#39;m reassigning all the destructured values right back into <code>config</code>, with the <code>config.options.enable</code> assignment references.</p>\n<p>Still too much, though. Let&#39;s see if we can make anything better.</p>\n<p>The following trick works best if you know that all the various properties you&#39;re destructuring are uniquely named. You can still do it even if that&#39;s not the case, but it&#39;s not as nice -- you&#39;ll have to do the destructuring in stages, or create unique local variables as temporary aliases.</p>\n<p>If we fully destructure all the properties into top-level variables, we can then immediately restructure to reconstitute the original nested object structure.</p>\n<p>But all those temporary variables hanging around would pollute scope. So, let&#39;s use block scoping (see &quot;Block-Scoped Declarations&quot; earlier in this chapter) with a general <code>{ }</code> enclosing block:</p>\n<pre><code class=\"lang-js\">// merge `defaults` into `config`\n{\n// destructure<span class=\"hljs-function\"> (</span>with default value assignments<span class=\"hljs-function\">)</span>\nlet {\noptions: {\nremove = defaults.options.remove,\nenable = defaults.options.enable,<span class=\"hljs-instruction\">\ninstance </span>= defaults.options.instance\n} = {},\nlog: {\nwarn = defaults.log.warn,\nerror = defaults.log.error\n} = {}\n} = config;\n\n// restructure\nconfig = {\noptions: { remove, enable,<span class=\"hljs-instruction\"> instance </span>},\nlog: { warn, error }\n};\n}\n</code></pre>\n<p>That seems a fair bit nicer, huh?</p>\n<p><strong>Note:</strong> You could also accomplish the scope enclosure with an arrow IIFE instead of the general <code>{ }</code> block and <code>let</code> declarations. Your destructuring assignments/defaults would be in the parameter list and your restructuring would be the <code>return</code> statement in the function body.</p>\n<p>The <code>{ warn, error }</code> syntax in the restructuring part may look new to you; that&#39;s called &quot;concise properties&quot; and we cover it in the next section!</p>\n<h2 id=\"object-literal-extensions\">Object Literal Extensions</h2>\n<p>ES6 adds a number of important convenience extensions to the humble <code>{ .. }</code> object literal.</p>\n<h4 id=\"es5-getter-setter\">ES5 Getter/Setter</h4>\n<p>Technically, ES5 defined getter/setter literals forms, but they didn&#39;t seem to get used much, mostly due to the lack of transpilers to handle that new syntax (the only major new syntax added in ES5, really). So while it&#39;s not a new ES6 feature, we&#39;ll briefly refresh on that form, as it&#39;s probably going to be much more useful with ES6 going forward.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\">var o = {\n__id: <span class=\"hljs-number\">10</span>,\n<span class=\"hljs-function\">get <span class=\"hljs-title\">id</span><span class=\"hljs-params\">()</span> </span>{ <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.__id++; },\n<span class=\"hljs-function\"><span class=\"hljs-built_in\">set</span> <span class=\"hljs-title\">id</span><span class=\"hljs-params\">(v)</span> </span>{ <span class=\"hljs-keyword\">this</span>.__id = v; }\n}\n\no.id;            <span class=\"hljs-comment\">// 10</span>\no.id;            <span class=\"hljs-comment\">// 11</span>\no.id = <span class=\"hljs-number\">20</span>;\no.id;            <span class=\"hljs-comment\">// 20</span>\n\n<span class=\"hljs-comment\">// and:</span>\no.__id;            <span class=\"hljs-comment\">// 21</span>\no.__id;            <span class=\"hljs-comment\">// 21 -- still!</span>\n</code></pre>\n<p>These getter and setter literal forms are also present in classes; see Chapter 3.</p>\n<p><strong>Warning:</strong> It may not be obvious, but the setter literal must have exactly one declared parameter; omitting it or listing others is illegal syntax. The single required parameter <em>can</em> use destructuring and defaults (e.g., <code>set id({ id: v = 0 }) { .. }</code>), but the gather/rest <code>...</code> is not allowed (<code>set id(...v) { .. }</code>).</p>\n<h3 id=\"computed-property-names\">Computed Property Names</h3>\n<p>You&#39;ve probably been in a situation like the following snippet, where you have one or more property names that come from some sort of expression and thus can&#39;t be put into the object literal:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> prefix = <span class=\"hljs-string\">\"user_\"</span>;\n\n<span class=\"hljs-keyword\">var</span> o = {\nbaz: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{ .. }\n};\n\no[ prefix + <span class=\"hljs-string\">\"foo\"</span> ] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{ .. };\no[ prefix + <span class=\"hljs-string\">\"bar\"</span> ] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{ .. };\n..\n</code></pre>\n<p>ES6 adds a syntax to the object literal definition which allows you to specify an expression that should be computed, whose result is the property name assigned. Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> prefix = <span class=\"hljs-string\">\"user_\"</span>;\n\n<span class=\"hljs-keyword\">var</span> o = {\nbaz: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{ .. },\n[ prefix + <span class=\"hljs-string\">\"foo\"</span> ]: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{ .. },\n[ prefix + <span class=\"hljs-string\">\"bar\"</span> ]: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{ .. }\n..\n};\n</code></pre>\n<p>Any valid expression can appear inside the <code>[ .. ]</code> that sits in the property name position of the object literal definition.</p>\n<p>Probably the most common use of computed property names will be with <code>Symbol</code>s (which we cover in &quot;Symbols&quot; later in this chapter), such as:</p>\n<pre><code class=\"lang-js\">var o = {\n[<span class=\"hljs-link_reference\">Symbol.toStringTag</span>]:<span class=\"hljs-link_url\"> \"really cool thing\",</span>\n..\n};\n</code></pre>\n<p><code>Symbol.toStringTag</code> is a special built-in value, which we evaluate with the <code>[ .. ]</code> syntax, so we can assign the <code>&quot;really cool thing&quot;</code> value to the special property name.</p>\n<p>Computed property names can also appear as the name of a concise method or a concise generator:</p>\n<pre><code class=\"lang-js\">var o = {\n[<span class=\"hljs-link_label\">\"f\" + \"oo\"</span>](<span class=\"hljs-link_url\"></span>) { .. }    // computed concise method\n*[<span class=\"hljs-link_label\">\"b\" + \"ar\"</span>](<span class=\"hljs-link_url\"></span>) { .. }    // computed concise generator\n};\n</code></pre>\n<h3 id=\"setting-prototype-\">Setting <code>[[Prototype]]</code></h3>\n<p>We won&#39;t cover prototypes in detail here, so for more information, see the <em>this &amp; Object Prototypes</em> title of this series.</p>\n<p>Sometimes it will be helpful to assign the <code>[[Prototype]]</code> of an object at the same time you&#39;re declaring its object literal. The following has been a nonstandard extension in many JS engines for a while, but is standardized as of ES6:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o1</span> = {\n<span class=\"hljs-comment\">// ..</span>\n};\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o2</span> = {\n__proto__: o1,\n<span class=\"hljs-comment\">// ..</span>\n};\n</code></pre>\n<p><code>o2</code> is declared with a normal object literal, but it&#39;s also <code>[[Prototype]]</code>-linked to <code>o1</code>. The <code>__proto__</code> property name here can also be a string <code>&quot;__proto__&quot;</code>, but note that it <em>cannot</em> be the result of a computed property name (see the previous section).</p>\n<p><code>__proto__</code> is controversial, to say the least. It&#39;s a decades-old proprietary extension to JS that is finally standardized, somewhat begrudgingly it seems, in ES6. Many developers feel it shouldn&#39;t ever be used. In fact, it&#39;s in &quot;Annex B&quot; of ES6, which is the section that lists things JS feels it has to standardize for compatibility reasons only.</p>\n<p><strong>Warning:</strong> Though I&#39;m narrowly endorsing <code>__proto__</code> as a key in an object literal definition, I definitely do not endorse using it in its object property form, like <code>o.__proto__</code>. That form is both a getter and setter (again for compatibility reasons), but there are definitely better options. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p>\n<p>For setting the <code>[[Prototype]]</code> of an existing object, you can use the ES6 utility <code>Object.setPrototypeOf(..)</code>. Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o1</span> = {\n<span class=\"hljs-comment\">// ..</span>\n};\n\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> o2</span> = {\n<span class=\"hljs-comment\">// ..</span>\n};\n\nObject.setPrototypeOf( o2, o1 );\n</code></pre>\n<p><strong>Note:</strong> We&#39;ll discuss <code>Object</code> again in Chapter 6. &quot;<code>Object.setPrototypeOf(..)</code> Static Function&quot; provides additional details on <code>Object.setPrototypeOf(..)</code>. Also see &quot;<code>Object.assign(..)</code> Static Function&quot; for another form that relates <code>o2</code> prototypically to <code>o1</code>.</p>\n<h3 id=\"object-super-\">Object <code>super</code></h3>\n<p><code>super</code> is typically thought of as being only related to classes. However, due to JS&#39;s classless-objects-with-prototypes nature, <code>super</code> is equally effective, and nearly the same in behavior, with plain objects&#39; concise methods.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o1 = {\nfoo() {\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"o1:foo\"</span> );\n}\n};\n\n<span class=\"hljs-keyword\">var</span> o2 = {\nfoo() {\n<span class=\"hljs-keyword\">super</span>.foo();\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"o2:foo\"</span> );\n}\n};\n\n<span class=\"hljs-built_in\">Object</span>.setPrototypeOf( o2, o1 );\n\no2.foo();        <span class=\"hljs-comment\">// o1:foo</span>\n<span class=\"hljs-comment\">// o2:foo</span>\n</code></pre>\n<p><strong>Warning:</strong> <code>super</code> is only allowed in concise methods, not regular function expression properties. It also is only allowed in <code>super.XXX</code> form (for property/method access), not in <code>super()</code> form.</p>\n<p>The <code>super</code> reference in the <code>o2.foo()</code> method is locked statically to <code>o2</code>, and specifically to the <code>[[Prototype]]</code> of <code>o2</code>. <code>super</code> here would basically be <code>Object.getPrototypeOf(o2)</code> -- resolves to <code>o1</code> of course -- which is how it finds and calls <code>o1.foo()</code>.</p>\n<p>For complete details on <code>super</code>, see &quot;Classes&quot; in Chapter 3.</p>\n<h2 id=\"template-literals\">Template Literals</h2>\n<p>At the very outset of this section, I&#39;m going to have to call out the name of this ES6 feature as being awfully... misleading, depending on your experiences with what the word <em>template</em> means.</p>\n<p>Many developers think of templates as being reusable renderable pieces of text, such as the capability provided by most template engines (Mustache, Handlebars, etc.). ES6&#39;s use of the word <em>template</em> would imply something similar, like a way to declare inline template literals that can be re-rendered. However, that&#39;s not at all the right way to think about this feature.</p>\n<p>So, before we go on, I&#39;m renaming to what it should have been called: <em>interpolated string literals</em> (or <em>interpoliterals</em> for short).</p>\n<p>You&#39;re already well aware of declaring string literals with <code>&quot;</code> or <code>&#39;</code> delimiters, and you also know that these are not <em>smart strings</em> (as some languages have), where the contents would be parsed for interpolation expressions.</p>\n<p>However, ES6 introduces a new type of string literal, using the <code>` </code> backtick as the delimiter. These string literals allow basic string interpolation expressions to be embedded, which are then automatically parsed and evaluated.</p>\n<p>Here&#39;s the old pre-ES6 way:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"Kyle\"</span>;\n\n<span class=\"hljs-keyword\">var</span> greeting = <span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\"!\"</span>;\n\n<span class=\"hljs-built_in\">console</span>.log( greeting );            <span class=\"hljs-comment\">// \"Hello Kyle!\"</span>\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-keyword\">typeof</span> greeting );        <span class=\"hljs-comment\">// \"string\"</span>\n</code></pre>\n<p>Now, consider the new ES6 way:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"Kyle\"</span>;\n\n<span class=\"hljs-keyword\">var</span> greeting = <span class=\"hljs-string\">`Hello <span class=\"hljs-subst\">${name}</span>!`</span>;\n\n<span class=\"hljs-built_in\">console</span>.log( greeting );            <span class=\"hljs-comment\">// \"Hello Kyle!\"</span>\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-keyword\">typeof</span> greeting );        <span class=\"hljs-comment\">// \"string\"</span>\n</code></pre>\n<p>As you can see, we used the <code>`..` </code> around a series of characters, which are interpreted as a string literal, but any expressions of the form <code>${..}</code> are parsed and evaluated inline immediately. The fancy term for such parsing and evaluating is <em>interpolation</em> (much more accurate than templating).</p>\n<p>The result of the interpolated string literal expression is just a plain old normal string, assigned to the <code>greeting</code> variable.</p>\n<p><strong>Warning:</strong> <code>typeof greeting == &quot;string&quot;</code> illustrates why it&#39;s important not to think of these entities as special template values, as you cannot assign the unevaluated form of the literal to something and reuse it. The <code>`..` </code> string literal is more like an IIFE in the sense that it&#39;s automatically evaluated inline. The result of a <code>`..` </code> string literal is, simply, just a string.</p>\n<p>One really nice benefit of interpolated string literals is they are allowed to split across multiple lines:</p>\n<pre><code class=\"lang-js\">var text =\n`Now <span class=\"hljs-keyword\">is</span> the <span class=\"hljs-typename\">time</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">all</span> good men\n<span class=\"hljs-keyword\">to</span> come <span class=\"hljs-keyword\">to</span> the aid <span class=\"hljs-keyword\">of</span> their\ncountry!`;\n\nconsole.log( text );\n// Now <span class=\"hljs-keyword\">is</span> the <span class=\"hljs-typename\">time</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">all</span> good men\n// <span class=\"hljs-keyword\">to</span> come <span class=\"hljs-keyword\">to</span> the aid <span class=\"hljs-keyword\">of</span> their\n// country!\n</code></pre>\n<p>The line breaks (newlines) in the interpolated string literal were preserved in the string value.</p>\n<p>Unless appearing as explicit escape sequences in the literal value, the value of the <code>\\r</code> carriage return character (code point <code>U+000D</code>) or the value of the <code>\\r\\n</code> carriage return + line feed sequence (code points <code>U+000D</code> and <code>U+000A</code>) are both normalized to a <code>\\n</code> line feed character (code point <code>U+000A</code>). Don&#39;t worry though; this normalization is rare and would likely only happen if copy-pasting text into your JS file.</p>\n<h3 id=\"interpolated-expressions\">Interpolated Expressions</h3>\n<p>Any valid expression is allowed to appear inside <code>${..}</code> in an interpolated string literal, including function calls, inline function expression calls, and even other interpolated string literals!</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\">function <span class=\"hljs-literal\">upper</span>(s) {\n<span class=\"hljs-keyword\">return</span> s.toUpperCase();\n}\n\n<span class=\"hljs-keyword\">var</span> who = <span class=\"hljs-string\">\"reader\"</span>;\n\n<span class=\"hljs-keyword\">var</span> text =\n`A very <span class=\"hljs-label\">${upper</span>( <span class=\"hljs-string\">\"warm\"</span> )} welcome\nto all of you <span class=\"hljs-label\">${upper</span>( `<span class=\"hljs-label\">${who}</span>s` )}!`;\n\nconsole.<span class=\"hljs-literal\">log</span>( text );\n<span class=\"hljs-comment\">// A very WARM welcome</span>\n<span class=\"hljs-comment\">// to all of you READERS!</span>\n</code></pre>\n<p>Here, the inner <code>`${who}s` </code> interpolated string literal was a little bit nicer convenience for us when combining the <code>who</code> variable with the <code>&quot;s&quot;</code> string, as opposed to <code>who + &quot;s&quot;</code>. There will be cases that nesting interpolated string literals is helpful, but be wary if you find yourself doing that kind of thing often, or if you find yourself nesting several levels deep.</p>\n<p>If that&#39;s the case, the odds are good that your string value production could benefit from some abstractions.</p>\n<p><strong>Warning:</strong> As a word of caution, be very careful about the readability of your code with such new found power. Just like with default value expressions and destructuring assignment expressions, just because you <em>can</em> do something doesn&#39;t mean you <em>should</em> do it. Never go so overboard with new ES6 tricks that your code becomes more clever than you or your other team members.</p>\n<h4 id=\"expression-scope\">Expression Scope</h4>\n<p>One quick note about the scope that is used to resolve variables in expressions. I mentioned earlier that an interpolated string literal is kind of like an IIFE, and it turns out thinking about it like that explains the scoping behavior as well.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">str</span>) </span>{\n<span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"foo\"</span>;\n<span class=\"hljs-built_in\">console</span>.log( str );\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{\n<span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"bar\"</span>;\nfoo( <span class=\"hljs-string\">`Hello from <span class=\"hljs-subst\">${name}</span>!`</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> name = <span class=\"hljs-string\">\"global\"</span>;\n\nbar();                    <span class=\"hljs-comment\">// \"Hello from bar!\"</span>\n</code></pre>\n<p>At the moment the <code>`..` </code> string literal is expressed, inside the <code>bar()</code> function, the scope available to it finds <code>bar()</code>&#39;s <code>name</code> variable with value <code>&quot;bar&quot;</code>. Neither the global <code>name</code> nor <code>foo(..)</code>&#39;s <code>name</code> matter. In other words, an interpolated string literal is just lexically scoped where it appears, not dynamically scoped in any way.</p>\n<h3 id=\"tagged-template-literals\">Tagged Template Literals</h3>\n<p>Again, renaming the feature for sanity sake: <em>tagged string literals</em>.</p>\n<p>To be honest, this is one of the cooler tricks that ES6 offers. It may seem a little strange, and perhaps not all that generally practical at first. But once you&#39;ve spent some time with it, tagged string literals may just surprise you in their usefulness.</p>\n<p>For example:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(strings, <span class=\"hljs-rest_arg\">...values</span>)</span> </span>{\nconsole.log( strings );\nconsole.log( values );\n}\n\n<span class=\"hljs-keyword\">var</span> desc = <span class=\"hljs-string\">\"awesome\"</span>;\n\nfoo`Everything <span class=\"hljs-keyword\">is</span> ${desc}!`;\n<span class=\"hljs-comment\">// [ \"Everything is \", \"!\"]</span>\n<span class=\"hljs-comment\">// [ \"awesome\" ]</span>\n</code></pre>\n<p>Let&#39;s take a moment to consider what&#39;s happening in the previous snippet. First, the most jarring thing that jumps out is <code>foo`Everything...`;</code>. That doesn&#39;t look like anything we&#39;ve seen before. What is it?</p>\n<p>It&#39;s essentially a special kind of function call that doesn&#39;t need the <code>( .. )</code>. The <em>tag</em> -- the <code>foo</code> part before the <code>`..` </code> string literal -- is a function value that should be called. Actually, it can be any expression that results in a function, even a function call that returns another function, like:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span><span class=\"hljs-params\">()</span> </span>{\n<span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(strings, <span class=\"hljs-rest_arg\">...values</span>)</span> </span>{\nconsole.log( strings );\nconsole.log( values );\n}\n}\n\n<span class=\"hljs-keyword\">var</span> desc = <span class=\"hljs-string\">\"awesome\"</span>;\n\nbar()`Everything <span class=\"hljs-keyword\">is</span> ${desc}!`;\n<span class=\"hljs-comment\">// [ \"Everything is \", \"!\"]</span>\n<span class=\"hljs-comment\">// [ \"awesome\" ]</span>\n</code></pre>\n<p>But what gets passed to the <code>foo(..)</code> function when invoked as a tag for a string literal?</p>\n<p>The first argument -- we called it <code>strings</code> -- is an array of all the plain strings (the stuff between any interpolated expressions). We get two values in the <code>strings</code> array: <code>&quot;Everything is &quot;</code> and <code>&quot;!&quot;</code>.</p>\n<p>For convenience sake in our example, we then gather up all subsequent arguments into an array called <code>values</code> using the <code>...</code> gather/rest operator (see the &quot;Spread/Rest&quot; section earlier in this chapter), though you could of course have left them as individual named parameters following the <code>strings</code> parameter.</p>\n<p>The argument(s) gathered into our <code>values</code> array are the results of the already-evaluated interpolation expressions found in the string literal. So obviously the only element in <code>values</code> in our example is <code>&quot;awesome&quot;</code>.</p>\n<p>You can think of these two arrays as: the values in <code>values</code> are the separators if you were to splice them in between the values in <code>strings</code>, and then if you joined everything together, you&#39;d get the complete interpolated string value.</p>\n<p>A tagged string literal is like a processing step after the interpolation expressions are evaluated but before the final string value is compiled, allowing you more control over generating the string from the literal.</p>\n<p>Typically, the string literal tag function (<code>foo(..)</code> in the previous snippets) should compute an appropriate string value and return it, so that you can use the tagged string literal as a value just like untagged string literals:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">tag</span><span class=\"hljs-params\">(strings, <span class=\"hljs-rest_arg\">...values</span>)</span> </span>{\n<span class=\"hljs-keyword\">return</span> strings.reduce( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(s,v,idx)</span></span>{\n<span class=\"hljs-keyword\">return</span> s + (idx &gt; <span class=\"hljs-number\">0</span> ? values[idx-<span class=\"hljs-number\">1</span>] : <span class=\"hljs-string\">\"\"</span>) + v;\n}, <span class=\"hljs-string\">\"\"</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> desc = <span class=\"hljs-string\">\"awesome\"</span>;\n\n<span class=\"hljs-keyword\">var</span> text = tag`Everything <span class=\"hljs-keyword\">is</span> ${desc}!`;\n\nconsole.log( text );            <span class=\"hljs-comment\">// Everything is awesome!</span>\n</code></pre>\n<p>In this snippet, <code>tag(..)</code> is a pass-through operation, in that it doesn&#39;t perform any special modifications, but just uses <code>reduce(..)</code> to loop over and splice/interleave <code>strings</code> and <code>values</code> together the same way an untagged string literal would have done.</p>\n<p>So what are some practical uses? There are many advanced ones that are beyond our scope to discuss here. But here&#39;s a simple idea that formats numbers as U.S. dollars (sort of like basic localization):</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">dollabillsyall</span><span class=\"hljs-params\">(strings, <span class=\"hljs-rest_arg\">...values</span>)</span> </span>{\n<span class=\"hljs-keyword\">return</span> strings.reduce( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(s,v,idx)</span></span>{\n<span class=\"hljs-keyword\">if</span> (idx &gt; <span class=\"hljs-number\">0</span>) {\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> values[idx-<span class=\"hljs-number\">1</span>] == <span class=\"hljs-string\">\"number\"</span>) {\n<span class=\"hljs-comment\">// look, also using interpolated</span>\n<span class=\"hljs-comment\">// string literals!</span>\ns += `$${values[idx-<span class=\"hljs-number\">1</span>].toFixed( <span class=\"hljs-number\">2</span> )}`;\n}\n<span class=\"hljs-keyword\">else</span> {\ns += values[idx-<span class=\"hljs-number\">1</span>];\n}\n}\n\n<span class=\"hljs-keyword\">return</span> s + v;\n}, <span class=\"hljs-string\">\"\"</span> );\n}\n\n<span class=\"hljs-keyword\">var</span> amt1 = <span class=\"hljs-number\">11.99</span>,\namt2 = amt1 * <span class=\"hljs-number\">1.08</span>,\nname = <span class=\"hljs-string\">\"Kyle\"</span>;\n\n<span class=\"hljs-keyword\">var</span> text = dollabillsyall\n`Thanks <span class=\"hljs-keyword\">for</span> your purchase, ${name}! Your\nproduct cost was ${amt1}, which <span class=\"hljs-keyword\">with</span> tax\ncomes out to ${amt2}.`\n\nconsole.log( text );\n<span class=\"hljs-comment\">// Thanks for your purchase, Kyle! Your</span>\n<span class=\"hljs-comment\">// product cost was $11.99, which with tax</span>\n<span class=\"hljs-comment\">// comes out to $12.95.</span>\n</code></pre>\n<p>If a <code>number</code> value is encountered in the <code>values</code> array, we put <code>&quot;$&quot;</code> in front of it and format it to two decimal places with <code>toFixed(2)</code>. Otherwise, we let the value pass-through untouched.</p>\n<h4 id=\"raw-strings\">Raw Strings</h4>\n<p>In the previous snippets, our tag functions receive the first argument we called <code>strings</code>, which is an array. But there&#39;s an additional bit of data included: the raw unprocessed versions of all the strings. You can access those raw string values using the <code>.raw</code> property, like this:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">showraw</span><span class=\"hljs-params\">(strings, <span class=\"hljs-rest_arg\">...values</span>)</span> </span>{\nconsole.log( strings );\nconsole.log( strings.raw );\n}\n\nshowraw`Hello\\nWorld`;\n<span class=\"hljs-comment\">// [ \"Hello</span>\n<span class=\"hljs-comment\">// World\" ]</span>\n<span class=\"hljs-comment\">// [ \"Hello\\nWorld\" ]</span>\n</code></pre>\n<p>The raw version of the value preserves the raw escaped <code>\\n</code> sequence (the <code>\\</code> and the <code>n</code> are separate characters), while the processed version considers it a single newline character. However, the earlier mentioned line-ending normalization is applied to both values.</p>\n<p>ES6 comes with a built-in function that can be used as a string literal tag: <code>String.raw(..)</code>. It simply passes through the raw versions of the <code>strings</code> values:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">`Hello\\nWorld`</span> );\n<span class=\"hljs-comment\">// Hello</span>\n<span class=\"hljs-comment\">// World</span>\n\n<span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-built_in\">String</span>.raw<span class=\"hljs-string\">`Hello\\nWorld`</span> );\n<span class=\"hljs-comment\">// Hello\\nWorld</span>\n\n<span class=\"hljs-built_in\">String</span>.raw<span class=\"hljs-string\">`Hello\\nWorld`</span>.length;\n<span class=\"hljs-comment\">// 12</span>\n</code></pre>\n<p>Other uses for string literal tags included special processing for internationalization, localization, and more!</p>\n<h2 id=\"arrow-functions\">Arrow Functions</h2>\n<p>We&#39;ve touched on <code>this</code> binding complications with functions earlier in this chapter, and they&#39;re covered at length in the <em>this &amp; Object Prototypes</em> title of this series. It&#39;s important to understand the frustrations that <code>this</code>-based programming with normal functions brings, because that is the primary motivation for the new ES6 <code>=&gt;</code> arrow function feature.</p>\n<p>Let&#39;s first illustrate what an arrow function looks like, as compared to normal functions:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y)</span> </span>{\n<span class=\"hljs-keyword\">return</span> x + y;\n}\n\n<span class=\"hljs-comment\">// versus</span>\n\n<span class=\"hljs-keyword\">var</span> foo = (x,y) =&gt; x + y;\n</code></pre>\n<p>The arrow function definition consists of a parameter list (of zero or more parameters, and surrounding <code>( .. )</code> if there&#39;s not exactly one parameter), followed by the <code>=&gt;</code> marker, followed by a function body.</p>\n<p>So, in the previous snippet, the arrow function is just the <code>(x,y) =&gt; x + y</code> part, and that function reference happens to be assigned to the variable <code>foo</code>.</p>\n<p>The body only needs to be enclosed by <code>{ .. }</code> if there&#39;s more than one expression, or if the body consists of a non-expression statement. If there&#39;s only one expression, and you omit the surrounding <code>{ .. }</code>, there&#39;s an implied <code>return</code> in front of the expression, as illustrated in the previous snippet.</p>\n<p>Here&#39;s some other arrow function variations to consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> f1</span> = () =&gt; <span class=\"hljs-number\">12</span>;\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> f2</span> = x =&gt; x * <span class=\"hljs-number\">2</span>;\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> f3</span> = (x,y) =&gt; {\n<span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> z</span> = x * <span class=\"hljs-number\">2</span> + y;\ny++;\nx *= <span class=\"hljs-number\">3</span>;\n<span class=\"hljs-keyword\">return</span> (x + y + z) / <span class=\"hljs-number\">2</span>;\n};\n</code></pre>\n<p>Arrow functions are <em>always</em> function expressions; there is no arrow function declaration. It also should be clear that they are anonymous function expressions -- they have no named reference for the purposes of recursion or event binding/unbinding -- though &quot;Function Names&quot; in Chapter 7 will describe ES6&#39;s function name inference rules for debugging purposes.</p>\n<p><strong>Note:</strong> All the capabilities of normal function parameters are available to arrow functions, including default values, destructuring, rest parameters, and so on.</p>\n<p>Arrow functions have a nice, shorter syntax, which makes them on the surface very attractive for writing terser code. Indeed, nearly all literature on ES6 (other than the titles in this series) seems to immediately and exclusively adopt the arrow function as &quot;the new function.&quot;</p>\n<p>It is telling that nearly all examples in discussion of arrow functions are short single statement utilities, such as those passed as callbacks to various utilities. For example:</p>\n<pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];\n\na = a.<span class=\"hljs-built_in\">map</span>( v =&gt; v * <span class=\"hljs-number\">2</span> );\n\nconsole.<span class=\"hljs-built_in\">log</span>( a );                <span class=\"hljs-comment\">// [2,4,6,8,10]</span>\n</code></pre>\n<p>In those cases, where you have such inline function expressions, and they fit the pattern of computing a quick calculation in a single statement and returning that result, arrow functions indeed look to be an attractive and lightweight alternative to the more verbose <code>function</code> keyword and syntax.</p>\n<p>Most people tend to <em>ooh and aah</em> at nice terse examples like that, as I imagine you just did!</p>\n<p>However, I would caution you that it would seem to me somewhat a misapplication of this feature to use arrow function syntax with otherwise normal, multistatement functions, especially those that would otherwise be naturally expressed as function declarations.</p>\n<p>Recall the <code>dollabillsyall(..)</code> string literal tag function from earlier in this chapter -- let&#39;s change it to use <code>=&gt;</code> syntax:</p>\n<pre><code class=\"lang-js\">var dollabillsyall = <span class=\"hljs-function\"><span class=\"hljs-params\">(strings, ...values)</span> =&gt;</span>\nstrings.reduce( <span class=\"hljs-function\"><span class=\"hljs-params\">(s,v,idx)</span> =&gt;</span> {\n<span class=\"hljs-keyword\">if</span> (idx &gt; <span class=\"hljs-number\">0</span>) {\n<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> values[idx-<span class=\"hljs-number\">1</span>] == <span class=\"hljs-string\">\"number\"</span>) {\n<span class=\"hljs-regexp\">//</span> look, also using interpolated\n<span class=\"hljs-regexp\">//</span> string literals!\ns += `<span class=\"javascript\">$${values[idx-<span class=\"hljs-number\">1</span>].toFixed( <span class=\"hljs-number\">2</span> )}</span>`;\n}\n<span class=\"hljs-keyword\">else</span> {\ns += values[idx-<span class=\"hljs-number\">1</span>];\n}\n}\n\n<span class=\"hljs-keyword\">return</span> s + v;\n}, <span class=\"hljs-string\">\"\"</span> );\n</code></pre>\n<p>In this example,  the only modifications I made were the removal of <code>function</code>, <code>return</code>, and some <code>{ .. }</code>, and then the insertion of <code>=&gt;</code> and a <code>var</code>. Is this a significant improvement in the readability of the code? Meh.</p>\n<p>I&#39;d actually argue that the lack of <code>return</code> and outer <code>{ .. }</code> partially obscures the fact that the <code>reduce(..)</code> call is the only statement in the <code>dollabillsyall(..)</code> function and that its result is the intended result of the call. Also, the trained eye that is so used to hunting for the word <code>function</code> in code to find scope boundaries now needs to look for the <code>=&gt;</code> marker, which can definitely be harder to find in the thick of the code.</p>\n<p>While not a hard-and-fast rule, I&#39;d say that the readability gains from <code>=&gt;</code> arrow function conversion are inversely proportional to the length of the function being converted. The longer the function, the less <code>=&gt;</code> helps; the shorter the function, the more <code>=&gt;</code> can shine.</p>\n<p>I think it&#39;s probably more sensible and reasonable to adopt <code>=&gt;</code> for the places in code where you do need short inline function expressions, but leave your normal-length main functions as is.</p>\n<h3 id=\"not-just-shorter-syntax-but-this-\">Not Just Shorter Syntax, But <code>this</code></h3>\n<p>Most of the popular attention toward <code>=&gt;</code> has been on saving those precious keystrokes by dropping <code>function</code>, <code>return</code>, and <code>{ .. }</code> from your code.</p>\n<p>But there&#39;s a big detail we&#39;ve skipped over so far. I said at the beginning of the section that <code>=&gt;</code> functions are closely related to <code>this</code> binding behavior. In fact, <code>=&gt;</code> arrow functions are <em>primarily designed</em> to alter <code>this</code> behavior in a specific way, solving a particular and common pain point with <code>this</code>-aware coding.</p>\n<p>The saving of keystrokes is a red herring, a misleading sideshow at best.</p>\n<p>Let&#39;s revisit another example from earlier in this chapter:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\n<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">self</span> = this;\n\nbtn.addEventListener( <span class=\"hljs-string\">\"click\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{\n<span class=\"hljs-comment\">// ..</span>\n<span class=\"hljs-keyword\">self</span>.makeRequest(..);\n}, <span class=\"hljs-keyword\">false</span> );\n}\n};\n</code></pre>\n<p>We used the <code>var self = this</code> hack, and then referenced <code>self.makeRequest(..)</code>, because inside the callback function we&#39;re passing to <code>addEventListener(..)</code>, the <code>this</code> binding will not be the same as it is in <code>makeRequest(..)</code> itself. In other words, because <code>this</code> bindings are dynamic, we fall back to the predictability of lexical scope via the <code>self</code> variable.</p>\n<p>Herein we finally can see the primary design characteristic of <code>=&gt;</code> arrow functions. Inside arrow functions, the <code>this</code> binding is not dynamic, but is instead lexical. In the previous snippet, if we used an arrow function for the callback, <code>this</code> will be predictably what we wanted it to be.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> controller = {\nmakeRequest: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(..)</span></span>{\nbtn.addEventListener( <span class=\"hljs-string\">\"click\"</span>, () =&gt; {\n<span class=\"hljs-comment\">// ..</span>\n<span class=\"hljs-keyword\">this</span>.makeRequest(..);\n}, <span class=\"hljs-literal\">false</span> );\n}\n};\n</code></pre>\n<p>Lexical <code>this</code> in the arrow function callback in the previous snippet now points to the same value as in the enclosing <code>makeRequest(..)</code> function. In other words, <code>=&gt;</code> is a syntactic stand-in for <code>var self = this</code>.</p>\n<p>In cases where <code>var self = this</code> (or, alternatively, a function <code>.bind(this)</code> call) would normally be helpful, <code>=&gt;</code> arrow functions are a nicer alternative operating on the same prinicple. Sounds great, right?</p>\n<p>Not quite so simple.</p>\n<p>If <code>=&gt;</code> replaces <code>var self = this</code> or <code>.bind(this)</code> and it helps, guess what happens if you use <code>=&gt;</code> with a <code>this</code>-aware function that <em>doesn&#39;t</em> need <code>var self = this</code> to work? You might be able to guess that it&#39;s going to mess things up. Yeah.</p>\n<p>Consider:</p>\n<pre><code class=\"lang-js\">var controller = {\n<span class=\"hljs-attribute\">makeRequest</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">(..)</span> =&gt;</span> {\n<span class=\"hljs-regexp\">//</span> ..\n<span class=\"hljs-keyword\">this</span>.helper(..);\n},\n<span class=\"hljs-attribute\">helper</span>: <span class=\"hljs-function\"><span class=\"hljs-params\">(..)</span> =&gt;</span> {\n<span class=\"hljs-regexp\">//</span> ..\n}\n};\n\ncontroller.makeRequest(..);\n</code></pre>\n<p>Although we invoke as <code>controller.makeRequest(..)</code>, the <code>this.helper</code> reference fails, because <code>this</code> here doesn&#39;t point to <code>controller</code> as it normally would. Where does it point? It lexically inherits <code>this</code> from the surrounding scope. In this previous snippet, that&#39;s the global scope, where <code>this</code> points to the global object. Ugh.</p>\n<p>In addition to lexical <code>this</code>, arrow functions also have lexical <code>arguments</code> -- they don&#39;t have their own <code>arguments</code> array but instead inherit from their parent -- as well as lexical <code>super</code> and <code>new.target</code> (see &quot;Classes&quot; in Chapter 3).</p>\n<p>So now we can conclude a more nuanced set of rules for when <code>=&gt;</code> is appropriate and not:</p>\n<ul>\n<li>If you have a short, single-statement inline function expression, where the only statement is a <code>return</code> of some computed value, <em>and</em> that function doesn&#39;t already make a <code>this</code> reference inside it, <em>and</em> there&#39;s no self-reference (recursion, event binding/unbinding), <em>and</em> you don&#39;t reasonably expect the function to ever be that way, you can probably safely refactor it to be an <code>=&gt;</code> arrow function.</li>\n<li>If you have an inner function expression that&#39;s relying on a <code>var self = this</code> hack or a <code>.bind(this)</code> call on it in the enclosing function to ensure proper <code>this</code> binding, that inner function expression can probably safely become an <code>=&gt;</code> arrow function.</li>\n<li>If you have an inner function expression that&#39;s relying on something like <code>var args = Array.prototype.slice.call(arguments)</code> in the enclosing function to make a lexical copy of <code>arguments</code>, that inner function expression can probably safely become an <code>=&gt;</code> arrow function.</li>\n<li><p>For everything else -- normal function declarations, longer multistatment function expressions, functions that need a lexical name identifier self-reference (recursion, etc.), and any other function that doesn&#39;t fit the previous characteristics -- you should probably avoid <code>=&gt;</code> function syntax.</p>\n<p>  Bottom line: <code>=&gt;</code> is about lexical binding of <code>this</code>, <code>arguments</code>, and <code>super</code>. These are intentional features designed to fix some common problems, not bugs, quirks, or mistakes in ES6.</p>\n<p>  Don&#39;t believe any hype that <code>=&gt;</code> is primarily, or even mostly, about fewer keystrokes. Whether you save keystrokes or waste them, you should know exactly what you are intentionally doing with every character typed.</p>\n<p>  <strong>Tip:</strong> If you have a function that for any of these articulated reasons is not a good match for an <code>=&gt;</code> arrow function, but it&#39;s being declared as part of an object literal, recall from &quot;Concise Methods&quot; earlier in this chapter that there&#39;s another option for shorter function syntax.</p>\n<p>  If you prefer a visual decision chart for how/why to pick an arrow function:</p>\n<p>  <img src=\"fig1.png\"></p>\n<h2 id=\"-for-of-loops\"><code>for..of</code> Loops</h2>\n<p>  Joining the <code>for</code> and <code>for..in</code> loops from the JavaScript we&#39;re all familiar with, ES6 adds a <code>for..of</code> loop, which loops over the set of values produced by an <em>iterator</em>.</p>\n<p>  The value you loop over with <code>for..of</code> must be an <em>iterable</em>, or it must be a value which can be coerced/boxed to an object (see the <em>Types &amp; Grammar</em> title of this series) that is an iterable. An iterable is simply an object that is able to produce an iterator, which the loop then uses.</p>\n<p>  Let&#39;s compare <code>for..of</code> to <code>for..in</code> to illustrate the difference:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-variable\">\"a\"</span>,<span class=\"hljs-variable\">\"b\"</span>,<span class=\"hljs-variable\">\"c\"</span>,<span class=\"hljs-variable\">\"d\"</span>,<span class=\"hljs-variable\">\"e\"</span>];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> idx <span class=\"hljs-keyword\">in</span> a) {\n  console.log( idx );\n  }\n  // <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> val <span class=\"hljs-keyword\">of</span> a) {\n  console.log( val );\n  }\n  // <span class=\"hljs-variable\">\"a\"</span> <span class=\"hljs-variable\">\"b\"</span> <span class=\"hljs-variable\">\"c\"</span> <span class=\"hljs-variable\">\"d\"</span> <span class=\"hljs-variable\">\"e\"</span>\n</code></pre>\n<p>  As you can see, <code>for..in</code> loops over the keys/indexes in the <code>a</code> array, while <code>for..of</code> loops over the values in <code>a</code>.</p>\n<p>  Here&#39;s the pre-ES6 version of the <code>for..of</code> from that previous snippet:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">\"a\"</span>,<span class=\"hljs-string\">\"b\"</span>,<span class=\"hljs-string\">\"c\"</span>,<span class=\"hljs-string\">\"d\"</span>,<span class=\"hljs-string\">\"e\"</span>],\n  k = <span class=\"hljs-type\">Object</span>.keys( a );\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>, <span class=\"hljs-title\">i</span> =</span> <span class=\"hljs-number\">0</span>; i &lt; k.length; i++) {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span> =</span> a[ k[i] ];\n  console.log( <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span> );</span>\n  }\n  <span class=\"hljs-comment\">// \"a\" \"b\" \"c\" \"d\" \"e\"</span>\n</code></pre>\n<p>  And here&#39;s the ES6 but non-<code>for..of</code> equivalent, which also gives a glimpse at manually iterating an iterator (see &quot;Iterators&quot; in Chapter 3):</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-string\">\"a\"</span>,<span class=\"hljs-string\">\"b\"</span>,<span class=\"hljs-string\">\"c\"</span>,<span class=\"hljs-string\">\"d\"</span>,<span class=\"hljs-string\">\"e\"</span>];\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> val, ret, it = a[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]();\n  (ret = it.next()) &amp;&amp; !ret.done;\n  ) {\n  val = ret.value;\n  console.log( val );\n  }\n  // <span class=\"hljs-string\">\"a\"</span> <span class=\"hljs-string\">\"b\"</span> <span class=\"hljs-string\">\"c\"</span> <span class=\"hljs-string\">\"d\"</span> <span class=\"hljs-string\">\"e\"</span>\n</code></pre>\n<p>  Under the covers, the <code>for..of</code> loop asks the iterable for an iterator (using the built-in <code>Symbol.iterator</code>; see &quot;Well-Known Symbols&quot; in Chapter 7), then it repeatedly calls the iterator and assigns its produced value to the loop iteration variable.</p>\n<p>  Standard built-in values in JavaScript that are by default iterables (or provide them) include:</p>\n</li>\n<li><p>Arrays</p>\n</li>\n<li>Strings</li>\n<li>Generators (see Chapter 3)</li>\n<li><p>Collections / TypedArrays (see Chapter 5)</p>\n<p>  <strong>Warning:</strong> Plain objects are not by default suitable for <code>for..of</code> looping. That&#39;s because they don&#39;t have a default iterator, which is intentional, not a mistake. However, we won&#39;t go any further into those nuanced reasonings here. In &quot;Iterators&quot; in Chapter 3, we&#39;ll see how to define iterators for our own objects, which lets <code>for..of</code> loop over any object to get a set of values we define.</p>\n<p>  Here&#39;s how to loop over the characters in a primitive string:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> c <span class=\"hljs-keyword\">of</span> <span class=\"hljs-variable\">\"hello\"</span>) {\n  console.log( c );\n  }\n  // <span class=\"hljs-variable\">\"h\"</span> <span class=\"hljs-variable\">\"e\"</span> <span class=\"hljs-variable\">\"l\"</span> <span class=\"hljs-variable\">\"l\"</span> <span class=\"hljs-variable\">\"o\"</span>\n</code></pre>\n<p>  The <code>&quot;hello&quot;</code> primitive string value is coerced/boxed to the <code>String</code> object wrapper equivalent, which is an iterable by default.</p>\n<p>  In <code>for (XYZ of ABC)..</code>, the <code>XYZ</code> clause can either be an assignment expression or a declaration, identical to that same clause in <code>for</code> and <code>for..in</code> loops. So you can do stuff like this:</p>\n<pre><code class=\"lang-js\">  var o = {};\n\n  <span class=\"hljs-keyword\">for</span> (o.a of [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]) {\n  console.<span class=\"hljs-built_in\">log</span>( o.a );\n  }\n  <span class=\"hljs-comment\">// 1 2 3</span>\n\n  <span class=\"hljs-keyword\">for</span> ({x: o.a} of [ {x: <span class=\"hljs-number\">1</span>}, {x: <span class=\"hljs-number\">2</span>}, {x: <span class=\"hljs-number\">3</span>} ]) {\n  console.<span class=\"hljs-built_in\">log</span>( o.a );\n  }\n  <span class=\"hljs-comment\">// 1 2 3</span>\n</code></pre>\n<p>  <code>for..of</code> loops can be prematurely stopped, just like other loops, with <code>break</code>, <code>continue</code>, <code>return</code> (if in a function), and thrown exceptions. In any of these cases, the iterator&#39;s <code>return(..)</code> function is automatically called (if one exists) to let the iterator perform cleanup tasks, if necessary.</p>\n<p>  <strong>Note:</strong> See &quot;Iterators&quot; in Chapter 3 for more complete coverage on iterables and iterators.</p>\n<h2 id=\"regular-expressions\">Regular Expressions</h2>\n<p>  Let&#39;s face it: regular expressions haven&#39;t changed much in JS in a long time. So it&#39;s a great thing that they&#39;ve finally learned a couple of new tricks in ES6. We&#39;ll briefly cover the additions here, but the overall topic of regular expressions is so dense that you&#39;ll need to turn to chapters/books dedicated to it (of which there are many!) if you need a refresher.</p>\n<h3 id=\"unicode-flag\">Unicode Flag</h3>\n<p>  We&#39;ll cover the topic of Unicode in more detail in &quot;Unicode&quot; later in this chapter. Here, we&#39;ll just look briefly at the new <code>u</code> flag for ES6+ regular expressions, which turns on Unicode matching for that expression.</p>\n<p>  JavaScript strings are typically interpreted as sequences of 16-bit characters, which correspond to the characters in the <em>Basic Multilingual Plane (BMP)</em> (<a href=\"http://en.wikipedia.org/wiki/Plane_%28Unicode%29\">http://en.wikipedia.org/wiki/Plane_%28Unicode%29</a>). But there are many UTF-16 characters that fall outside this range, and so strings may have these multibyte characters in them.</p>\n<p>  Prior to ES6, regular expressions could only match based on BMP characters, which means that those extended characters were treated as two separate characters for matching purposes. This is often not ideal.</p>\n<p>  So, as of ES6, the <code>u</code> flag tells a regular expression to process a string with the intepretation of Unicode (UTF-16) characters, such that such an extended character will be matched as a single entity.</p>\n<p>  <strong>Warning:</strong> Despite the name implication, &quot;UTF-16&quot; doesn&#39;t strictly mean 16 bits. Modern Unicode uses 21 bits, and standards like UTF-8 and UTF-16 refer roughly to how many bits are used in the representation of a character.</p>\n<p>  An example (straight from the ES6 specification):  (the musical symbol G-clef) is Unicode point U+1D11E (0x1D11E).</p>\n<p>  If this character appears in a regular expression pattern (like <code>//</code>), the standard BMP interpretation would be that it&#39;s two separate characters (0xD834 and 0xDD1E) to match with. But the new ES6 Unicode-aware mode means that <code>//u</code> (or the escaped Unicode form <code>/\\u{1D11E}/u</code>) will match <code>&quot;&quot;</code> in a string as a single matched character.</p>\n<p>  You might be wondering why this matters? In non-Unicode BMP mode, the pattern is treated as two separate characters, but would still find the match in a string with the <code>&quot;&quot;</code> character in it, as you can see if you try:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-regexp\">//</span>.test( <span class=\"hljs-string\">\"-clef\"</span> );            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-literal\">true</span>\n</code></pre>\n<p>  The length of the match is what matters. For example:</p>\n<pre><code class=\"lang-js\">  /^.-clef/ .<span class=\"hljs-keyword\">test</span>( <span class=\"hljs-string\">\"-clef\"</span> );        <span class=\"hljs-comment\">// false</span>\n  /^.-clef/<span class=\"hljs-keyword\">u</span>.<span class=\"hljs-keyword\">test</span>( <span class=\"hljs-string\">\"-clef\"</span> );        <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>  The <code>^.-clef</code> in the pattern says to match only a single character at the beginning before the normal <code>&quot;-clef&quot;</code> text. In standard BMP mode, the match fails (two characters), but with <code>u</code> Unicode mode flagged on, the match succeeds (one character).</p>\n<p>  It&#39;s also important to note that <code>u</code> makes quantifiers like <code>+</code> and <code>*</code> apply to the entire Unicode code point as a single character, not just the <em>lower surrogate</em> (aka rightmost half of the symbol) of the character. The same goes for Unicode characters appearing in character classes, like <code>/[-]/u</code>.</p>\n<p>  <strong>Note:</strong> There&#39;s plenty more nitty-gritty details about <code>u</code> behavior in regular expressions, which Mathias Bynens (<a href=\"https://twitter.com/mathias\">https://twitter.com/mathias</a>) has written extensively about (<a href=\"https://mathiasbynens.be/notes/es6-unicode-regex\">https://mathiasbynens.be/notes/es6-unicode-regex</a>).</p>\n<h3 id=\"sticky-flag\">Sticky Flag</h3>\n<p>  Another flag mode added to ES6 regular expressions is <code>y</code>, which is often called &quot;sticky mode.&quot; <em>Sticky</em> essentially means the regular expression has a virtual anchor at its beginning that keeps it rooted to matching at only the position indicated by the regular expression&#39;s <code>lastIndex</code> property.</p>\n<p>  To illustrate, let&#39;s consider two regular expressions, the first without sticky mode and the second with:</p>\n<pre><code class=\"lang-js\">  var re1 = <span class=\"hljs-regexp\">/foo/</span>,\n  str = <span class=\"hljs-string\">\"++foo++\"</span>;\n\n  re1.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span>\n  re1.test( str );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span>\n  re1.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span> -- <span class=\"hljs-keyword\">not</span> updated\n\n  re1.lastIndex = <span class=\"hljs-number\">4</span>;\n  re1.test( str );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span> -- ignored <span class=\"hljs-string\">`lastIndex`</span>\n  re1.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4</span> -- <span class=\"hljs-keyword\">not</span> updated\n</code></pre>\n<p>  Three things to observe about this snippet:</p>\n</li>\n<li><p><code>test(..)</code> doesn&#39;t pay any attention to <code>lastIndex</code>&#39;s value, and always just performs its match from the beginning of the input string.</p>\n</li>\n<li>Because our pattern does not have a <code>^</code> start-of-input anchor, the search for <code>&quot;foo&quot;</code> is free to move ahead through the whole string looking for a match.</li>\n<li><p><code>lastIndex</code> is not updated by <code>test(..)</code>.</p>\n<p>  Now, let&#39;s try a sticky mode regular expression:</p>\n<pre><code class=\"lang-js\">  var re2 = <span class=\"hljs-regexp\">/foo/y</span>,        <span class=\"hljs-regexp\">//</span> &lt;-- notice the <span class=\"hljs-string\">`y`</span> sticky flag\n  str = <span class=\"hljs-string\">\"++foo++\"</span>;\n\n  re2.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span>\n  re2.test( str );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">false</span> -- <span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-keyword\">not</span> found at <span class=\"hljs-string\">`0`</span>\n  re2.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span>\n\n  re2.lastIndex = <span class=\"hljs-number\">2</span>;\n  re2.test( str );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span>\n  re2.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">5</span> -- updated to after previous match\n\n  re2.test( str );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">false</span>\n  re2.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span> -- reset after previous match failure\n</code></pre>\n<p>  And so our new observations about sticky mode:</p>\n</li>\n<li><p><code>test(..)</code> uses <code>lastIndex</code> as the exact and only position in <code>str</code> to look to make a match. There is no moving ahead to look for the match -- it&#39;s either there at the <code>lastIndex</code> position or not.</p>\n</li>\n<li><p>If a match is made, <code>test(..)</code> updates <code>lastIndex</code> to point to the character immediately following the match. If a match fails, <code>test(..)</code> resets <code>lastIndex</code> back to <code>0</code>.</p>\n<p>  Normal non-sticky patterns that aren&#39;t otherwise <code>^</code>-rooted to the start-of-input are free to move ahead in the input string looking for a match. But sticky mode restricts the pattern to matching just at the position of <code>lastIndex</code>.</p>\n<p>  As I suggested at the beginning of this section, another way of looking at this is that <code>y</code> implies a virtual anchor at the beginning of the pattern that is relative (aka constrains the start of the match) to exactly the <code>lastIndex</code> position.</p>\n<p>  <strong>Warning:</strong> In previous literature on the topic, it has alternatively been asserted that this behavior is like <code>y</code> implying a <code>^</code> (start-of-input) anchor in the pattern. This is inaccurate. We&#39;ll explain in further detail in &quot;Anchored Sticky&quot; later.</p>\n<h4 id=\"sticky-positioning\">Sticky Positioning</h4>\n<p>  It may seem strangely limiting that to use <code>y</code> for repeated matches, you have to manually ensure <code>lastIndex</code> is in the exact right position, as it has no move-ahead capability for matching.</p>\n<p>  Here&#39;s one possible scenario: if you know that the match you care about is always going to be at a position that&#39;s a multiple of a number (e.g., <code>0</code>, <code>10</code>, <code>20</code>, etc.), you can just construct a limited pattern matching what you care about, but then manually set <code>lastIndex</code> each time before match to those fixed positions.</p>\n<p>  Consider:</p>\n<pre><code class=\"lang-js\">  var re = /f../y,\n  <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">\"foo       far       fad\"</span>;\n\n  <span class=\"hljs-built_in\">str</span>.<span class=\"hljs-built_in\">match</span>( re );        <span class=\"hljs-comment\">// [\"foo\"]</span>\n\n  re.lastIndex = <span class=\"hljs-number\">10</span>;\n  <span class=\"hljs-built_in\">str</span>.<span class=\"hljs-built_in\">match</span>( re );        <span class=\"hljs-comment\">// [\"far\"]</span>\n\n  re.lastIndex = <span class=\"hljs-number\">20</span>;\n  <span class=\"hljs-built_in\">str</span>.<span class=\"hljs-built_in\">match</span>( re );        <span class=\"hljs-comment\">// [\"fad\"]</span>\n</code></pre>\n<p>  However, if you&#39;re parsing a string that isn&#39;t formatted in fixed positions like that, figuring out what to set <code>lastIndex</code> to before each match is likely going to be untenable.</p>\n<p>  There&#39;s a saving nuance to consider here. <code>y</code> requires that <code>lastIndex</code> be in the exact position for a match to occur. But it doesn&#39;t strictly require that <em>you</em> manually set <code>lastIndex</code>.</p>\n<p>  Instead, you can construct your expressions in such a way that they capture in each main match everything before and after the thing you care about, up to right before the next thing you&#39;ll care to match.</p>\n<p>  Because <code>lastIndex</code> will set to the next character beyond the end of a match, if you&#39;ve matched everything up to that point, <code>lastIndex</code> will always be in the correct position for the <code>y</code> pattern to start from the next time.</p>\n<p>  <strong>Warning:</strong> If you can&#39;t predict the structure of the input string in a sufficiently patterned way like that, this technique may not be suitable and you may not be able to use <code>y</code>.</p>\n<p>  Having structured string input is likely the most practical scenario where <code>y</code> will be capable of performing repeated matching throughout a string. Consider:</p>\n<pre><code class=\"lang-js\">  var re = <span class=\"hljs-regexp\">/\\d+\\.\\s(.*?)(?:\\s|$)/y</span>\n  str = <span class=\"hljs-string\">\"1. foo 2. bar 3. baz\"</span>;\n\n  str.match( re );        <span class=\"hljs-regexp\">//</span> [ <span class=\"hljs-string\">\"1. foo \"</span>, <span class=\"hljs-string\">\"foo\"</span> ]\n\n  re.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">7</span> -- correct position!\n  str.match( re );        <span class=\"hljs-regexp\">//</span> [ <span class=\"hljs-string\">\"2. bar \"</span>, <span class=\"hljs-string\">\"bar\"</span> ]\n\n  re.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">14</span> -- correct position!\n  str.match( re );        <span class=\"hljs-regexp\">//</span> [<span class=\"hljs-string\">\"3. baz\"</span>, <span class=\"hljs-string\">\"baz\"</span>]\n</code></pre>\n<p>  This works because I knew something ahead of time about the structure of the input string: there is always a numeral prefix like <code>&quot;1. &quot;</code> before the desired match (<code>&quot;foo&quot;</code>, etc.), and either a space after it, or the end of the string (<code>$</code> anchor). So the regular expression I constructed captures all of that in each main match, and then I use a matching group <code>( )</code> so that the stuff I really care about is separated out for convenience.</p>\n<p>  After the first match (<code>&quot;1. foo &quot;</code>), the <code>lastIndex</code> is <code>7</code>, which is already the position needed to start the next match, for <code>&quot;2. bar &quot;</code>, and so on.</p>\n<p>  If you&#39;re going to use <code>y</code> sticky mode for repeated matches, you&#39;ll probably want to look for opportunities to have <code>lastIndex</code> automatically positioned as we&#39;ve just demonstrated.</p>\n<h4 id=\"sticky-versus-global\">Sticky Versus Global</h4>\n<p>  Some readers may be aware that you can emulate something like this <code>lastIndex</code>-relative matching with the <code>g</code> global match flag and the <code>exec(..)</code> method, as so:</p>\n<pre><code class=\"lang-js\">  var re = /o+./g,        <span class=\"hljs-comment\">// &lt;-- look, `g`!</span>\n  <span class=\"hljs-keyword\">str</span> = <span class=\"hljs-string\">\"foot book more\"</span>;\n\n  re.exec( <span class=\"hljs-keyword\">str</span> );            <span class=\"hljs-comment\">// [\"oot\"]</span>\n  re.lastIndex;            <span class=\"hljs-comment\">// 4</span>\n\n  re.exec( <span class=\"hljs-keyword\">str</span> );            <span class=\"hljs-comment\">// [\"ook\"]</span>\n  re.lastIndex;            <span class=\"hljs-comment\">// 9</span>\n\n  re.exec( <span class=\"hljs-keyword\">str</span> );            <span class=\"hljs-comment\">// [\"or\"]</span>\n  re.lastIndex;            <span class=\"hljs-comment\">// 13</span>\n\n  re.exec( <span class=\"hljs-keyword\">str</span> );            <span class=\"hljs-comment\">// null -- no more matches!</span>\n  re.lastIndex;            <span class=\"hljs-comment\">// 0 -- starts over now!</span>\n</code></pre>\n<p>  While it&#39;s true that <code>g</code> pattern matches with <code>exec(..)</code> start their matching from <code>lastIndex</code>&#39;s current value, and also update <code>lastIndex</code> after each match (or failure), this is not the same thing as <code>y</code>&#39;s behavior.</p>\n<p>  Notice in the previous snippet that <code>&quot;ook&quot;</code>, located at position <code>6</code>, was matched and found by the second <code>exec(..)</code> call, even though at the time, <code>lastIndex</code> was <code>4</code> (from the end of the previous match). Why? Because as we said earlier, non-sticky matches are free to move ahead in their matching. A sticky mode expression would have failed here, because it would not be allowed to move ahead.</p>\n<p>  In addition to perhaps undesired move-ahead matching behavior, another downside to just using <code>g</code> instead of <code>y</code> is that <code>g</code> changes the behavior of some matching methods, like <code>str.match(re)</code>.</p>\n<p>  Consider:</p>\n<pre><code class=\"lang-js\">  var re = <span class=\"hljs-regexp\">/o+./g</span>,        <span class=\"hljs-regexp\">//</span> &lt;-- look, <span class=\"hljs-string\">`g`</span>!\n  str = <span class=\"hljs-string\">\"foot book more\"</span>;\n\n  str.match( re );        <span class=\"hljs-regexp\">//</span> [<span class=\"hljs-string\">\"oot\"</span>,<span class=\"hljs-string\">\"ook\"</span>,<span class=\"hljs-string\">\"or\"</span>]\n</code></pre>\n<p>  See how all the matches were returned at once? Sometimes that&#39;s OK, but sometimes that&#39;s not what you want.</p>\n<p>  The <code>y</code> sticky flag will give you one-at-a-time progressive matching with utilities like <code>test(..)</code> and <code>match(..)</code>. Just make sure the <code>lastIndex</code> is always in the right position for each match!</p>\n<h4 id=\"anchored-sticky\">Anchored Sticky</h4>\n<p>  As we warned earlier, it&#39;s inaccurate to think of sticky mode as implying a pattern starts with <code>^</code>. The <code>^</code> anchor has a distinct meaning in regular expressions, which is <em>not altered</em> by sticky mode. <code>^</code> is an anchor that <em>always</em> refers to the beginning of the input, and <em>is not</em> in any way relative to <code>lastIndex</code>.</p>\n<p>  Besides poor/inaccurate documentation on this topic, the confusion is unfortunately strengthened further because an older pre-ES6 experiment with sticky mode in Firefox <em>did</em> make <code>^</code> relative to <code>lastIndex</code>, so that behavior has been around for years.</p>\n<p>  ES6 elected not to do it that way. <code>^</code> in a pattern means start-of-input absolutely and only.</p>\n<p>  As a consequence, a pattern like <code>/^foo/y</code> will always and only find a <code>&quot;foo&quot;</code> match at the beginning of a string, <em>if it&#39;s allowed to match there</em>. If <code>lastIndex</code> is not <code>0</code>, the match will fail. Consider:</p>\n<pre><code class=\"lang-js\">  var re = <span class=\"hljs-regexp\">/^foo/y</span>,\n  str = <span class=\"hljs-string\">\"foo\"</span>;\n\n  re.test( str );            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span>\n  re.test( str );            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">false</span>\n  re.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span> -- reset after failure\n\n  re.lastIndex = <span class=\"hljs-number\">1</span>;\n  re.test( str );            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">false</span> -- failed <span class=\"hljs-keyword\">for</span> positioning\n  re.lastIndex;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">0</span> -- reset after failure\n</code></pre>\n<p>  Bottom line: <code>y</code> plus <code>^</code> plus <code>lastIndex &gt; 0</code> is an incompatible combination that will always cause a failed match.</p>\n<p>  <strong>Note:</strong> While <code>y</code> does not alter the meaning of <code>^</code> in any way, the <code>m</code> multiline mode <em>does</em>, such that <code>^</code> means start-of-input <em>or</em> start of text after a newline. So, if you combine <code>y</code> and <code>m</code> flags together for a pattern, you can find multiple <code>^</code>-rooted matches in a string. But remember: because it&#39;s <code>y</code> sticky, you&#39;ll have to make sure <code>lastIndex</code> is pointing at the correct new line position (likely by matching to the end of the line) each subsequent time, or no subsequent matches will be made.</p>\n<h3 id=\"regular-expression-flags-\">Regular Expression <code>flags</code></h3>\n<p>  Prior to ES6, if you wanted to examine a regular expression object to see what flags it had applied, you needed to parse them out -- ironically, probably with another regular expression -- from the content of the <code>source</code> property, such as:</p>\n<pre><code class=\"lang-js\">  var re = /foo/ig;\n\n  re.<span class=\"hljs-keyword\">to</span>String();            // <span class=\"hljs-string\">\"/foo/ig\"</span>\n\n  var <span class=\"hljs-keyword\">flags</span> = re.<span class=\"hljs-keyword\">to</span>String().<span class=\"hljs-built_in\">match</span>( /\\/([gim]*)$/ )[<span class=\"hljs-number\">1</span>];\n\n  <span class=\"hljs-keyword\">flags</span>;                    // <span class=\"hljs-string\">\"ig\"</span>\n</code></pre>\n<p>  As of ES6, you can now get these values directly, with the new <code>flags</code> property:</p>\n<pre><code class=\"lang-js\">  var re = <span class=\"hljs-regexp\">/foo/ig</span>;\n\n  re.flags;                <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">\"gi\"</span>\n</code></pre>\n<p>  It&#39;s a small nuance, but the ES6 specification calls for the expression&#39;s flags to be listed in this order: <code>&quot;gimuy&quot;</code>, regardless of what order the original pattern was specified with. That&#39;s the reason for the difference between <code>/ig</code> and <code>&quot;gi&quot;</code>.</p>\n<p>  No, the order of flags specified or listed doesn&#39;t matter.</p>\n<p>  Another tweak from ES6 is that the <code>RegExp(..)</code> constructor is now <code>flags</code>-aware if you pass it an existing regular expression:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> re1 = <span class=\"hljs-regexp\">/foo*/y</span>;\n  re1.source;                            <span class=\"hljs-comment\">// \"foo*\"</span>\n  re1.flags;                            <span class=\"hljs-comment\">// \"y\"</span>\n\n  <span class=\"hljs-keyword\">var</span> re2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>( re1 );\n  re2.source;                            <span class=\"hljs-comment\">// \"foo*\"</span>\n  re2.flags;                            <span class=\"hljs-comment\">// \"y\"</span>\n\n  <span class=\"hljs-keyword\">var</span> re3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">RegExp</span>( re1, <span class=\"hljs-string\">\"ig\"</span> );\n  re3.source;                            <span class=\"hljs-comment\">// \"foo*\"</span>\n  re3.flags;                            <span class=\"hljs-comment\">// \"gi\"</span>\n</code></pre>\n<p>  Prior to ES6, the <code>re3</code> construction would throw an error, but as of ES6 you can override the flags when duplicating.</p>\n<h2 id=\"number-literal-extensions\">Number Literal Extensions</h2>\n<p>  Prior to ES5, number literals looked like the following -- the octal form was not officially specified, only allowed as an extension that browsers had come to de facto agreement on:</p>\n<pre><code class=\"lang-js\">  var dec = <span class=\"hljs-number\">42</span>,\n  oct = <span class=\"hljs-number\">052</span>,\n  hex = <span class=\"hljs-number\">0x2a</span>;\n</code></pre>\n<p>  <strong>Note:</strong> Though you are specifying a number in different bases, the number&#39;s mathematic value is what is stored, and the default output interpretation is always base-10. The three variables in the previous snippet all have the <code>42</code> value stored in them.</p>\n<p>  To further illustrate that <code>052</code> was a nonstandard form extension, consider:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"42\"</span> );                <span class=\"hljs-comment\">// 42</span>\n  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"052\"</span> );            <span class=\"hljs-comment\">// 52</span>\n  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"0x2a\"</span> );            <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<p>  ES5 continued to permit the browser-extended octal form (including such inconsistencies), except that in strict mode, the octal literal (<code>052</code>) form is disallowed. This restriction was done mainly because many developers had the habit (from other languages) of seemingly innocuously prefixing otherwise base-10 numbers with <code>0</code>&#39;s for code alignment purposes, and then running into the accidental fact that they&#39;d changed the number value entirely!</p>\n<p>  ES6 continues the legacy of changes/variations to how number literals outside base-10 numbers can be represented. There&#39;s now an official octal form, an amended hexadecimal form, and a brand-new binary form. For web compatibility reasons, the old octal <code>052</code> form will continue to be legal (though unspecified) in non-strict mode, but should really never be used anymore.</p>\n<p>  Here are the new ES6 number literal forms:</p>\n<pre><code class=\"lang-js\">  var dec = <span class=\"hljs-number\">42</span>,\n  oct = 0o52,            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">or</span> <span class=\"hljs-string\">`0O52`</span> <span class=\"hljs-symbol\">:</span>(\n  hex = <span class=\"hljs-number\">0x2a</span>,            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">or</span> <span class=\"hljs-string\">`0X2a`</span> <span class=\"hljs-symbol\">:/</span>\n  bin = 0b10101<span class=\"hljs-number\">0</span>;        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">or</span> <span class=\"hljs-string\">`0B101010`</span> <span class=\"hljs-symbol\">:/</span>\n</code></pre>\n<p>  The only decimal form allowed is base-10. Octal, hexadecimal, and binary are all integer forms.</p>\n<p>  And the string representations of these forms are all able to be coerced/converted to their number equivalent:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"42\"</span> );            <span class=\"hljs-comment\">// 42</span>\n  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"0o52\"</span> );        <span class=\"hljs-comment\">// 42</span>\n  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"0x2a\"</span> );        <span class=\"hljs-comment\">// 42</span>\n  <span class=\"hljs-built_in\">Number</span>( <span class=\"hljs-string\">\"0b101010\"</span> );    <span class=\"hljs-comment\">// 42</span>\n</code></pre>\n<p>  Though not strictly new to ES6, it&#39;s a little-known fact that you can actually go the opposite direction of conversion (well, sort of):</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = 42;\n\n  a.<span class=\"hljs-keyword\">toString</span>();            <span class=\"hljs-comment\">// \"42\" -- also `a.toString( 10 )`</span>\n  a.<span class=\"hljs-keyword\">toString</span>( 8 );        <span class=\"hljs-comment\">// \"52\"</span>\n  a.<span class=\"hljs-keyword\">toString</span>( 16 );        <span class=\"hljs-comment\">// \"2a\"</span>\n  a.<span class=\"hljs-keyword\">toString</span>( 2 );        <span class=\"hljs-comment\">// \"101010\"</span>\n</code></pre>\n<p>  In fact, you can represent a number this way in any base from <code>2</code> to <code>36</code>, though it&#39;d be rare that you&#39;d go outside the standard bases: 2, 8, 10, and 16.</p>\n<h2 id=\"unicode\">Unicode</h2>\n<p>  Let me just say that this section is not an exhaustive everything-you-ever-wanted-to-know-about-Unicode resource. I want to cover what you need to know that&#39;s <em>changing</em> for Unicode in ES6, but we won&#39;t go much deeper than that. Mathias Bynens (<a href=\"http://twitter.com/mathias\">http://twitter.com/mathias</a>) has written/spoken extensively and brilliantly about JS and Unicode (see <a href=\"https://mathiasbynens.be/notes/javascript-unicode\">https://mathiasbynens.be/notes/javascript-unicode</a> and <a href=\"http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode\">http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode</a>).</p>\n<p>  The Unicode characters that range from <code>0x0000</code> to <code>0xFFFF</code> contain all the standard printed characters (in various languages) that you&#39;re likely to have seen or interacted with. This group of characters is called the <em>Basic Multilingual Plane (BMP)</em>. The BMP even contains fun symbols like this cool snowman:  (U+2603).</p>\n<p>  There are lots of other extended Unicode characters beyond this BMP set, which range up to <code>0x10FFFF</code>. These symbols are often referred to as <em>astral</em> symbols, as that&#39;s the name given to the set of 16 <em>planes</em> (e.g., layers/groupings) of characters beyond the BMP. Examples of astral symbols include  (U+1D11E) and  (U+1F4A9).</p>\n<p>  Prior to ES6, JavaScript strings could specify Unicode characters using Unicode escaping, such as:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> snowman = <span class=\"hljs-string\">\"\\u2603\"</span>;\n  <span class=\"hljs-built_in\">console</span>.log( snowman );            <span class=\"hljs-comment\">// \"\"</span>\n</code></pre>\n<p>  However, the <code>\\uXXXX</code> Unicode escaping only supports four hexadecimal characters, so you can only represent the BMP set of characters in this way. To represent an astral character using Unicode escaping prior to ES6, you need to use a <em>surrogate pair</em> -- basically two specially calculated Unicode-escaped characters side by side, which JS interprets together as a single astral character:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> gclef = <span class=\"hljs-string\">\"\\uD834\\uDD1E\"</span>;\n  <span class=\"hljs-built_in\">console</span>.log( gclef );            <span class=\"hljs-comment\">// \"\"</span>\n</code></pre>\n<p>  As of ES6, we now have a new form for Unicode escaping (in strings and regular expressions), called Unicode <em>code point escaping</em>:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> gclef = <span class=\"hljs-string\">\"\\u{1D11E}\"</span>;\n  <span class=\"hljs-built_in\">console</span>.log( gclef );            <span class=\"hljs-comment\">// \"\"</span>\n</code></pre>\n<p>  As you can see, the difference is the presence of the <code>{ }</code> in the escape sequence, which allows it to contain any number of hexadecimal characters. Because you only need six to represent the highest possible code point value in Unicode (i.e., 0x10FFFF), this is sufficient.</p>\n<h3 id=\"unicode-aware-string-operations\">Unicode-Aware String Operations</h3>\n<p>  By default, JavaScript string operations and methods are not sensitive to astral symbols in string values. So, they treat each BMP character individually, even the two surrogate halves that make up an otherwise single astral character. Consider:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> snowman</span> = <span class=\"hljs-string\">\"\"</span>;\n  snowman.length;                    <span class=\"hljs-comment\">// 1</span>\n\n  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> gclef</span> = <span class=\"hljs-string\">\"\"</span>;\n  gclef.length;                    <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<p>  So, how do we accurately calculate the length of such a string? In this scenario, the following trick will work:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> gclef = <span class=\"hljs-string\">\"\"</span>;\n\n  [...gclef].length;                <span class=\"hljs-comment\">// 1</span>\n  Array.<span class=\"hljs-keyword\">from</span>( gclef ).length;        <span class=\"hljs-comment\">// 1</span>\n</code></pre>\n<p>  Recall from the &quot;<code>for..of</code> Loops&quot; section earlier in this chapter that ES6 strings have built-in iterators. This iterator happens to be Unicode-aware, meaning it will automatically output an astral symbol as a single value. We take advantage of that using the <code>...</code> spread operator in an array literal, which creates an array of the string&#39;s symbols. Then we just inspect the length of that resultant array. ES6&#39;s <code>Array.from(..)</code> does basically the same thing as <code>[...XYZ]</code>, but we&#39;ll cover that utility in detail in Chapter 6.</p>\n<p>  <strong>Warning:</strong> It should be noted that constructing and exhausting an iterator just to get the length of a string is quite expensive on performance, relatively speaking, compared to what a theoretically optimized native utility/property would do.</p>\n<p>  Unfortunately, the full answer is not as simple or straightforward. In addition to the surrogate pairs (which the string iterator takes care of), there are special Unicode code points that behave in other special ways, which is much harder to account for. For example, there&#39;s a set of code points that modify the previous adjacent character, known as <em>Combining Diacritical Marks</em>.</p>\n<p>  Consider these two string outputs:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-built_in\">console</span>.log( s1 );                <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">\"\"</span>\n  <span class=\"hljs-built_in\">console</span>.log( s2 );                <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">\"\"</span>\n</code></pre>\n<p>  They look the same, but they&#39;re not! Here&#39;s how we created <code>s1</code> and <code>s2</code>:</p>\n<pre><code class=\"lang-js\">  var <span class=\"hljs-literal\">s1</span> = <span class=\"hljs-string\">\"\\xE9\"</span>,\n  <span class=\"hljs-literal\">s2</span> = <span class=\"hljs-string\">\"e\\u0301\"</span><span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>  As you can probably guess, our previous <code>length</code> trick doesn&#39;t work with <code>s2</code>:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-attr_selector\">[...s1]</span><span class=\"hljs-class\">.length</span>;                    <span class=\"hljs-comment\">// 1</span>\n  <span class=\"hljs-attr_selector\">[...s2]</span><span class=\"hljs-class\">.length</span>;                    <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<p>  So what can we do? In this case, we can perform a <em>Unicode normalization</em> on the value before inquiring about its length, using the ES6 <code>String#normalize(..)</code> utility (which we&#39;ll cover more in Chapter 6):</p>\n<pre><code class=\"lang-js\">  var s1 = <span class=\"hljs-string\">\"\\xE9\"</span>,\n  s2 = <span class=\"hljs-string\">\"e\\u0301\"</span>;\n\n  s1.<span class=\"hljs-built_in\">normalize</span>().<span class=\"hljs-built_in\">length</span>;            <span class=\"hljs-comment\">// 1</span>\n  s2.<span class=\"hljs-built_in\">normalize</span>().<span class=\"hljs-built_in\">length</span>;            <span class=\"hljs-comment\">// 1</span>\n\n  s1 === s2;                        <span class=\"hljs-comment\">// false</span>\n  s1 === s2.<span class=\"hljs-built_in\">normalize</span>();            <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>  Essentially, <code>normalize(..)</code> takes a sequence like <code>&quot;e\\u0301&quot;</code> and normalizes it to <code>&quot;\\xE9&quot;</code>. Normalization can even combine multiple adjacent combining marks if there&#39;s a suitable Unicode character they combine to:</p>\n<pre><code class=\"lang-js\">  var <span class=\"hljs-literal\">s1</span> = <span class=\"hljs-string\">\"o\\u0302\\u0300\"</span>,\n  <span class=\"hljs-literal\">s2</span> = <span class=\"hljs-literal\">s1</span>.normalize(),\n  <span class=\"hljs-literal\">s3</span> = <span class=\"hljs-string\">\"\"</span><span class=\"hljs-comment\">;</span>\n\n  <span class=\"hljs-literal\">s1</span>.length<span class=\"hljs-comment\">;                        // 3</span>\n  <span class=\"hljs-literal\">s2</span>.length<span class=\"hljs-comment\">;                        // 1</span>\n  <span class=\"hljs-literal\">s3</span>.length<span class=\"hljs-comment\">;                        // 1</span>\n\n  <span class=\"hljs-literal\">s2</span> === <span class=\"hljs-literal\">s3</span><span class=\"hljs-comment\">;                        // true</span>\n</code></pre>\n<p>  Unfortunately, normalization isn&#39;t fully perfect here, either. If you have multiple combining marks modifying a single character, you may not get the length count you&#39;d expect, because there may not be a single defined normalized character that represents the combination of all the marks. For example:</p>\n<pre><code class=\"lang-js\">  var s1 = <span class=\"hljs-string\">\"e\\u0301\\u0330\"</span>;\n\n  console.<span class=\"hljs-built_in\">log</span>( s1 );                <span class=\"hljs-comment\">// \"e\"</span>\n\n  s1.<span class=\"hljs-built_in\">normalize</span>().<span class=\"hljs-built_in\">length</span>;            <span class=\"hljs-comment\">// 2</span>\n</code></pre>\n<p>  The further you go down this rabbit hole, the more you realize that it&#39;s difficult to get one precise definition for &quot;length.&quot; What we see visually rendered as a single character -- more precisely called a <em>grapheme</em> -- doesn&#39;t always strictly relate to a single &quot;character&quot; in the program processing sense.</p>\n<p>  <strong>Tip:</strong> If you want to see just how deep this rabbit hole goes, check out the &quot;Grapheme Cluster Boundaries&quot; algorithm (<a href=\"http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\">http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries</a>).</p>\n<h3 id=\"character-positioning\">Character Positioning</h3>\n<p>  Similar to length complications, what does it actually mean to ask, &quot;what is the character at position 2?&quot; The naive pre-ES6 answer comes from <code>charAt(..)</code>, which will not respect the atomicity of an astral character, nor will it take into account combining marks.</p>\n<p>  Consider:</p>\n<pre><code class=\"lang-js\">  var s1 = <span class=\"hljs-string\">\"abc\\u0301d\"</span>,\n  s2 = <span class=\"hljs-string\">\"ab\\u0107d\"</span>,\n  s3 = <span class=\"hljs-string\">\"ab\\u{1d49e}d\"</span>;\n\n  console.<span class=\"hljs-built_in\">log</span>( s1 );                <span class=\"hljs-comment\">// \"abd\"</span>\n  console.<span class=\"hljs-built_in\">log</span>( s2 );                <span class=\"hljs-comment\">// \"abd\"</span>\n  console.<span class=\"hljs-built_in\">log</span>( s3 );                <span class=\"hljs-comment\">// \"abd\"</span>\n\n  s1.charAt( <span class=\"hljs-number\">2</span> );                    <span class=\"hljs-comment\">// \"c\"</span>\n  s2.charAt( <span class=\"hljs-number\">2</span> );                    <span class=\"hljs-comment\">// \"\"</span>\n  s3.charAt( <span class=\"hljs-number\">2</span> );                    <span class=\"hljs-comment\">// \"\" &lt;-- unprintable surrogate</span>\n  s3.charAt( <span class=\"hljs-number\">3</span> );                    <span class=\"hljs-comment\">// \"\" &lt;-- unprintable surrogate</span>\n</code></pre>\n<p>  So, is ES6 giving us a Unicode-aware verison of <code>charAt(..)</code>? Unfortunately, no. At the time of this writing, there&#39;s a proposal for such a utility that&#39;s under consideration for post-ES6.</p>\n<p>  But with what we explored in the previous section (and of course with the limitations noted thereof!), we can hack an ES6 answer:</p>\n<pre><code class=\"lang-js\">  var s1 = \"abc\\u0301d\",\n  s2 = \"ab\\u0107d\",\n  s3 = \"ab\\u{1d49e}d\";\n\n  [<span class=\"hljs-link_label\">...s1.normalize()</span>][<span class=\"hljs-link_reference\">2</span>];            // \"\"\n  [<span class=\"hljs-link_label\">...s2.normalize()</span>][<span class=\"hljs-link_reference\">2</span>];            // \"\"\n  [<span class=\"hljs-link_label\">...s3.normalize()</span>][<span class=\"hljs-link_reference\">2</span>];            // \"\"\n</code></pre>\n<p>  <strong>Warning:</strong> Reminder of an earlier warning: constructing and exhausting an iterator each time you want to get at a single character is... very not ideal, performance wise. Let&#39;s hope we get a built-in and optimized utility for this soon, post-ES6.</p>\n<p>  What about a Unicode-aware version of the <code>charCodeAt(..)</code> utility? ES6 gives us <code>codePointAt(..)</code>:</p>\n<pre><code class=\"lang-js\">  var <span class=\"hljs-literal\">s1</span> = <span class=\"hljs-string\">\"abc\\u0301d\"</span>,\n  <span class=\"hljs-literal\">s2</span> = <span class=\"hljs-string\">\"ab\\u0107d\"</span>,\n  <span class=\"hljs-literal\">s3</span> = <span class=\"hljs-string\">\"ab\\u{1d49e}d\"</span><span class=\"hljs-comment\">;</span>\n\n  <span class=\"hljs-literal\">s1</span>.normalize().codePointAt( <span class=\"hljs-number\">2</span> ).toString( <span class=\"hljs-number\">16</span> )<span class=\"hljs-comment\">;</span>\n  // <span class=\"hljs-string\">\"107\"</span>\n\n  <span class=\"hljs-literal\">s2</span>.normalize().codePointAt( <span class=\"hljs-number\">2</span> ).toString( <span class=\"hljs-number\">16</span> )<span class=\"hljs-comment\">;</span>\n  // <span class=\"hljs-string\">\"107\"</span>\n\n  <span class=\"hljs-literal\">s3</span>.normalize().codePointAt( <span class=\"hljs-number\">2</span> ).toString( <span class=\"hljs-number\">16</span> )<span class=\"hljs-comment\">;</span>\n  // <span class=\"hljs-string\">\"1d49e\"</span>\n</code></pre>\n<p>  What about the other direction? A Unicode-aware version of <code>String.fromCharCode(..)</code> is ES6&#39;s <code>String.fromCodePoint(..)</code>:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">String</span>.fromCodePoint( <span class=\"hljs-number\">0</span>x107 );        // <span class=\"hljs-string\">\"\"</span>\n\n  <span class=\"hljs-keyword\">String</span>.fromCodePoint( <span class=\"hljs-number\">0</span>x1d49e );    // <span class=\"hljs-string\">\"\"</span>\n</code></pre>\n<p>  So wait, can we just combine <code>String.fromCodePoint(..)</code> and <code>codePointAt(..)</code> to get a better version of a Unicode-aware <code>charAt(..)</code> from earlier? Yep!</p>\n<pre><code class=\"lang-js\">  var <span class=\"hljs-literal\">s1</span> = <span class=\"hljs-string\">\"abc\\u0301d\"</span>,\n  <span class=\"hljs-literal\">s2</span> = <span class=\"hljs-string\">\"ab\\u0107d\"</span>,\n  <span class=\"hljs-literal\">s3</span> = <span class=\"hljs-string\">\"ab\\u{1d49e}d\"</span><span class=\"hljs-comment\">;</span>\n\n  <span class=\"hljs-keyword\">String.fromCodePoint( </span><span class=\"hljs-literal\">s1</span>.normalize().codePointAt( <span class=\"hljs-number\">2</span> ) )<span class=\"hljs-comment\">;</span>\n  // <span class=\"hljs-string\">\"\"</span>\n\n  <span class=\"hljs-keyword\">String.fromCodePoint( </span><span class=\"hljs-literal\">s2</span>.normalize().codePointAt( <span class=\"hljs-number\">2</span> ) )<span class=\"hljs-comment\">;</span>\n  // <span class=\"hljs-string\">\"\"</span>\n\n  <span class=\"hljs-keyword\">String.fromCodePoint( </span><span class=\"hljs-literal\">s3</span>.normalize().codePointAt( <span class=\"hljs-number\">2</span> ) )<span class=\"hljs-comment\">;</span>\n  // <span class=\"hljs-string\">\"\"</span>\n</code></pre>\n<p>  There&#39;s quite a few other string methods we haven&#39;t addressed here, including <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring(..)</code>, <code>indexOf(..)</code>, <code>slice(..)</code>, and a dozen others. None of these have been changed or augmented for full Unicode awareness, so you should be very careful -- probably just avoid them! -- when working with strings containing astral symbols.</p>\n<p>  There are also several string methods that use regular expressions for their behavior, like <code>replace(..)</code> and <code>match(..)</code>. Thankfully, ES6 brings Unicode awareness to regular expressions, as we covered in &quot;Unicode Flag&quot; earlier in this chapter.</p>\n<p>  OK, there we have it! JavaScript&#39;s Unicode string support is significantly better over pre-ES6 (though still not perfect) with the various additions we&#39;ve just covered.</p>\n<h3 id=\"unicode-identifier-names\">Unicode Identifier Names</h3>\n<p>  Unicode can also be used in identifier names (variables, properties, etc.). Prior to ES6, you could do this with Unicode-escapes, like:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> \\u03A9</span> = <span class=\"hljs-number\">42</span>;\n\n  <span class=\"hljs-comment\">// same as: var  = 42;</span>\n</code></pre>\n<p>  As of ES6, you can also use the earlier explained code point escape syntax:</p>\n<pre><code class=\"lang-js\">  var \\u{<span class=\"hljs-number\">2</span>B400} = <span class=\"hljs-number\">42</span>;\n\n  <span class=\"hljs-comment\">// same as: var  = 42;</span>\n</code></pre>\n<p>  There&#39;s a complex set of rules around exactly which Unicode characters are allowed. Furthermore, some are allowed only if they&#39;re not the first character of the identifier name.</p>\n<p>  <strong>Note:</strong> Mathias Bynens has a great post (<a href=\"https://mathiasbynens.be/notes/javascript-identifiers-es6\">https://mathiasbynens.be/notes/javascript-identifiers-es6</a>) on all the nitty-gritty details.</p>\n<p>  The reasons for using such unusual characters in identifier names are rather rare and academic. You typically won&#39;t be best served by writing code that relies on these esoteric capabilities.</p>\n<h2 id=\"symbols\">Symbols</h2>\n<p>  With ES6, for the first time in quite a while, a new primitive type has been added to JavaScript: the <code>symbol</code>. Unlike the other primitive types, however, symbols don&#39;t have a literal form.</p>\n<p>  Here&#39;s how you create a symbol:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> sym = <span class=\"hljs-built_in\">Symbol</span>( <span class=\"hljs-string\">\"some optional description\"</span> );\n\n  <span class=\"hljs-keyword\">typeof</span> sym;        <span class=\"hljs-comment\">// \"symbol\"</span>\n</code></pre>\n<p>  Some things to note:</p>\n</li>\n<li><p>You cannot and should not use <code>new</code> with <code>Symbol(..)</code>. It&#39;s not a constructor, nor are you producing an object.</p>\n</li>\n<li>The parameter passed to <code>Symbol(..)</code> is optional. If passed, it should be a string that gives a friendly description for the symbol&#39;s purpose.</li>\n<li><p>The <code>typeof</code> output is a new value (<code>&quot;symbol&quot;</code>) that is the primary way to identify a symbol.</p>\n<p>  The description, if provided, is solely used for the stringification representation of the symbol:</p>\n<pre><code class=\"lang-js\">  sym.toString();        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">\"Symbol(some optional description)\"</span>\n</code></pre>\n<p>  Similar to how primitive string values are not instances of <code>String</code>, symbols are also not instances of <code>Symbol</code>. If, for some reason, you want to construct a boxed wrapper object form of a symbol value, you can do the following:</p>\n<pre><code class=\"lang-js\">  sym <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Symbol</span>;        <span class=\"hljs-comment\">// false</span>\n\n  <span class=\"hljs-keyword\">var</span> symObj = <span class=\"hljs-built_in\">Object</span>( sym );\n  symObj <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Symbol</span>;    <span class=\"hljs-comment\">// true</span>\n\n  symObj.valueOf() === sym;    <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>  <strong>Note:</strong> <code>symObj</code> in this snippet is interchangeable with <code>sym</code>; either form can be used in all places symbols are utilized. There&#39;s not much reason to use the boxed wrapper object form (<code>symObj</code>) instead of the primitive form (<code>sym</code>). Keeping with similar advice for other primitives, it&#39;s probably best to prefer <code>sym</code> over <code>symObj</code>.</p>\n<p>  The internal value of a symbol itself -- referred to as its <code>name</code> -- is hidden from the code and cannot be obtained. You can think of this symbol value as an automatically generated, unique (within your application) string value.</p>\n<p>  But if the value is hidden and unobtainable, what&#39;s the point of having a symbol at all?</p>\n<p>  The main point of a symbol is to create a string-like value that can&#39;t collide with any other value. So, for example, consider using a symbol as a constant representing an event name:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">const</span> EVT_LOGIN = <span class=\"hljs-built_in\">Symbol</span>( <span class=\"hljs-string\">\"event.login\"</span> );\n</code></pre>\n<p>  You&#39;d then use <code>EVT_LOGIN</code> in place of a generic string literal like <code>&quot;event.login&quot;</code>:</p>\n<pre><code class=\"lang-js\">  evthub.listen( EVT_LOGIN, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(data)</span></span>{\n  <span class=\"hljs-comment\">// ..</span>\n  } );\n</code></pre>\n<p>  The benefit here is that <code>EVT_LOGIN</code> holds a value that cannot be duplicated (accidentally or otherwise) by any other value, so it is impossible for there to be any confusion of which event is being dispatched or handled.</p>\n<p>  <strong>Note:</strong> Under the covers, the <code>evthub</code> utility assumed in the previous snippet would almost certainly be using the symbol value from the <code>EVT_LOGIN</code> argument directly as the property/key in some internal object (hash) that tracks event handlers. If <code>evthub</code> instead needed to use the symbol value as a real string, it would need to explicitly coerce with <code>String(..)</code> or <code>toString()</code>, as implicit string coercion of symbols is not allowed.</p>\n<p>  You may use a symbol directly as a property name/key in an object, such as a special property that you want to treat as hidden or meta in usage. It&#39;s important to know that although you intend to treat it as such, it is not <em>actually</em> a hidden or untouchable property.</p>\n<p>  Consider this module that implements the <em>singleton</em> pattern behavior -- that is, it only allows itself to be created once:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">const</span> INSTANCE = <span class=\"hljs-built_in\">Symbol</span>( <span class=\"hljs-string\">\"instance\"</span> );\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">HappyFace</span>(<span class=\"hljs-params\"></span>) </span>{\n  <span class=\"hljs-keyword\">if</span> (HappyFace[INSTANCE]) <span class=\"hljs-keyword\">return</span> HappyFace[INSTANCE];\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">smile</span>(<span class=\"hljs-params\"></span>) </span>{ .. }\n\n  <span class=\"hljs-keyword\">return</span> HappyFace[INSTANCE] = {\n  smile: smile\n  };\n  }\n\n  <span class=\"hljs-keyword\">var</span> me = HappyFace(),\n  you = HappyFace();\n\n  me === you;            <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<p>  The <code>INSTANCE</code> symbol value here is a special, almost hidden, meta-like property stored statically on the <code>HappyFace()</code> function object.</p>\n<p>  It could alternatively have been a plain old property like <code>__instance</code>, and the behavior would have been identical. The usage of a symbol simply improves the metaprogramming style, keeping this <code>INSTANCE</code> property set apart from any other normal properties.</p>\n<h3 id=\"symbol-registry\">Symbol Registry</h3>\n<p>  One mild downside to using symbols as in the last few examples is that the <code>EVT_LOGIN</code> and <code>INSTANCE</code> variables had to be stored in an outer scope (perhaps even the global scope), or otherwise somehow stored in a publicly available location, so that all parts of the code that need to use the symbols can access them.</p>\n<p>  To aid in organizing code with access to these symbols, you can create symbol values with the <em>global symbol registry</em>. For example:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">const</span> EVT_LOGIN = Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"event.login\"</span> );\n\n  console.<span class=\"hljs-built_in\">log</span>( EVT_LOGIN );        <span class=\"hljs-comment\">// Symbol(event.login)</span>\n</code></pre>\n<p>  And:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">HappyFace</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">const</span> INSTANCE = Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"instance\"</span> );\n\n  <span class=\"hljs-keyword\">if</span> (HappyFace[INSTANCE]) <span class=\"hljs-keyword\">return</span> HappyFace[INSTANCE];\n\n  <span class=\"hljs-comment\">// ..</span>\n\n  <span class=\"hljs-keyword\">return</span> HappyFace[INSTANCE] = { .. };\n  }\n</code></pre>\n<p>  <code>Symbol.for(..)</code> looks in the global symbol registry to see if a symbol is already stored with the provided description text, and returns it if so. If not, it creates one to return. In other words, the global symbol registry treats symbol values, by description text, as singletons themselves.</p>\n<p>  But that also means that any part of your application can retrieve the symbol from the registry using <code>Symbol.for(..)</code>, as long as the matching description name is used.</p>\n<p>  Ironically, symbols are basically intended to replace the use of <em>magic strings</em> (arbitrary string values given special meaning) in your application. But you precisely use <em>magic</em> description string values to uniquely identify/locate them in the global symbol registry!</p>\n<p>  To avoid accidental collisions, you&#39;ll probably want to make your symbol descriptions quite unique. One easy way of doing that is to include prefix/context/namespacing information in them.</p>\n<p>  For example, consider a utility such as the following:</p>\n<pre><code class=\"lang-js\">  function extractValues(<span class=\"hljs-built_in\">str</span>) {\n  var <span class=\"hljs-variable\">key</span> = Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"extractValues.parse\"</span> ),\n  re = extractValues[<span class=\"hljs-variable\">key</span>] ||\n  /[^=&amp;]+?=([^&amp;]+?)(?=&amp;|$)/g,\n  values = [], <span class=\"hljs-built_in\">match</span>;\n\n  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">match</span> = re.exec( <span class=\"hljs-built_in\">str</span> )) {\n  values.push( <span class=\"hljs-built_in\">match</span>[<span class=\"hljs-number\">1</span>] );\n  }\n\n  <span class=\"hljs-keyword\">return</span> values;\n  }\n</code></pre>\n<p>  We use the magic string value <code>&quot;extractValues.parse&quot;</code> because it&#39;s quite unlikely that any other symbol in the registry would ever collide with that description.</p>\n<p>  If a user of this utility wants to override the parsing regular expression, they can also use the symbol registry:</p>\n<pre><code class=\"lang-js\">  extractValues[Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"extractValues.parse\"</span> )] =\n  /..<span class=\"hljs-keyword\">some</span> pattern../g;\n\n  extractValues( <span class=\"hljs-string\">\"..some string..\"</span> );\n</code></pre>\n<p>  Aside from the assistance the symbol registry provides in globally storing these values, everything we&#39;re seeing here could have been done by just actually using the magic string <code>&quot;extractValues.parse&quot;</code> as the key, rather than the symbol. The improvements exist at the metaprogramming level more than the functional level.</p>\n<p>  You may have occasion to use a symbol value that has been stored in the registry to look up what description text (key) it&#39;s stored under. For example, you may need to signal to another part of your application how to locate a symbol in the registry because you cannot pass the symbol value itself.</p>\n<p>  You can retrieve a registered symbol&#39;s description text (key) using <code>Symbol.keyFor(..)</code>:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> s = Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"something cool\"</span> );\n\n  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">desc</span> = Symbol.keyFor( s );\n  console.<span class=\"hljs-literal\">log</span>( <span class=\"hljs-keyword\">desc</span> );            <span class=\"hljs-comment\">// \"something cool\"</span>\n\n  <span class=\"hljs-comment\">// get the symbol from the registry again</span>\n  <span class=\"hljs-keyword\">var</span> s2 = Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-keyword\">desc</span> );\n\n  s2 === s;                        <span class=\"hljs-comment\">// true</span>\n</code></pre>\n<h3 id=\"symbols-as-object-properties\">Symbols as Object Properties</h3>\n<p>  If a symbol is used as a property/key of an object, it&#39;s stored in a special way so that the property will not show up in a normal enumeration of the object&#39;s properties:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> o = {\n  foo: <span class=\"hljs-number\">42</span>,\n  [ <span class=\"hljs-built_in\">Symbol</span>( <span class=\"hljs-string\">\"bar\"</span> ) ]: <span class=\"hljs-string\">\"hello world\"</span>,\n  baz: <span class=\"hljs-keyword\">true</span>\n  };\n\n  <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames( o );    <span class=\"hljs-comment\">// [ \"foo\",\"baz\" ]</span>\n</code></pre>\n<p>  To retrieve an object&#39;s symbol properties:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols( o );    <span class=\"hljs-comment\">// [ Symbol(bar) ]</span>\n</code></pre>\n<p>  This makes it clear that a property symbol is not actually hidden or inaccessible, as you can always see it in the <code>Object.getOwnPropertySymbols(..)</code> list.</p>\n<h4 id=\"built-in-symbols\">Built-In Symbols</h4>\n<p>  ES6 comes with a number of predefined built-in symbols that expose various meta behaviors on JavaScript object values. However, these symbols are <em>not</em> registered in the global symbol registry, as one might expect.</p>\n<p>  Instead, they&#39;re stored as properties on the <code>Symbol</code> function object. For example, in the &quot;<code>for..of</code>&quot; section earlier in this chapter, we introduced the <code>Symbol.iterator</code> value:</p>\n<pre><code class=\"lang-js\">  <span class=\"hljs-keyword\">var</span> a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];\n\n  a[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>];            // native function\n</code></pre>\n<p>  The specification uses the <code>@@</code> prefix notation to refer to the built-in symbols, the most common ones being: <code>@@iterator</code>, <code>@@toStringTag</code>, <code>@@toPrimitive</code>. Several others are defined as well, though they probably won&#39;t be used as often.</p>\n<p>  <strong>Note:</strong> See &quot;Well Known Symbols&quot; in Chapter 7 for detailed information about how these built-in symbols are used for meta programming purposes.</p>\n<h2 id=\"review\">Review</h2>\n<p>  ES6 adds a heap of new syntax forms to JavaScript, so there&#39;s plenty to learn!</p>\n<p>  Most of these are designed to ease the pain points of common programming idioms, such as setting default values to function parameters and gathering the &quot;rest&quot; of the parameters into an array. Destructuring is a powerful tool for more concisely expressing assignments of values from arrays and nested objects.</p>\n<p>  While features like <code>=&gt;</code> arrow functions appear to also be all about shorter and nicer-looking syntax, they actually have very specific behaviors that you should intentionally use only in appropriate situations.</p>\n<p>  Expanded Unicode support, new tricks for regular expressions, and even a new primitive <code>symbol</code> type round out the syntactic evolution of ES6.</p>\n</li>\n</ul>\n"}},"README":{"body":"<hr> <p><strong><a href=\"http://shop.oreilly.com/product/0636920033769.do\">Purchase digital/print copy from O&#39;Reilly</a></strong></p> <hr> <p><a href=\"toc.md\">Table of Contents</a></p> <ul> <li><a href=\"foreword.md\">Foreword</a> (by <a href=\"http://bocoup.com/weblog/author/rick-waldron/\">Rick Waldron</a>)</li> <li><a href=\"../preface.md\">Preface</a></li> <li><a href=\"ch1.md\">Chapter 1: ES? Now &amp; Future</a></li> <li><a href=\"ch2.md\">Chapter 2: Syntax</a></li> <li><a href=\"ch3.md\">Chapter 3: Organization</a></li> <li><a href=\"ch4.md\">Chapter 4: Async Flow Control</a></li> <li><a href=\"ch5.md\">Chapter 5: Collections</a></li> <li><a href=\"ch6.md\">Chapter 6: API Additions</a></li> <li><a href=\"ch7.md\">Chapter 7: Meta Programming</a></li> <li><a href=\"ch8.md\">Chapter 8: Beyond ES6</a></li> <li><a href=\"apA.md\">Appendix A: Thank You&#39;s!</a></li> </ul> ","title":"You Don't Know JS: ES6 & Beyond"},"apA":{"body":"<h1 id=\"appendix-a-acknowledgments\">Appendix A: Acknowledgments</h1> <p>I have many people to thank for making this book title and the overall series happen.</p> <p>First, I must thank my wife Christen Simpson, and my two kids Ethan and Emily, for putting up with Dad always pecking away at the computer. Even when not writing books, my obsession with JavaScript glues my eyes to the screen far more than it should. That time I borrow from my family is the reason these books can so deeply and completely explain JavaScript to you, the reader. I owe my family everything.</p> <p>I&#39;d like to thank my editors at O&#39;Reilly, namely Simon St.Laurent and Brian MacDonald, as well as the rest of the editorial and marketing staff. They are fantastic to work with, and have been especially accommodating during this experiment into &quot;open source&quot; book writing, editing, and production.</p> <p>Thank you to the many folks who have participated in making this book series better by providing editorial suggestions and corrections, including Shelley Powers, Tim Ferro, Evan Borden, Forrest L. Norvell, Jennifer Davis, Jesse Harlin, and many others. A big thank you to Rick Waldron for writing the Foreword for this title.</p> <p>Thank you to the countless folks in the community, including members of the TC39 committee, who have shared so much knowledge with the rest of us, and especially tolerated my incessant questions and explorations with patience and detail. John-David Dalton, Juriy &quot;kangax&quot; Zaytsev, Mathias Bynens, Axel Rauschmayer, Nicholas Zakas, Angus Croll, Reginald Braithwaite, Dave Herman, Brendan Eich, Allen Wirfs-Brock, Bradley Meck, Domenic Denicola, David Walsh, Tim Disney, Peter van der Zee, Andrea Giammarchi, Kit Cambridge, Eric Elliott, Andr Bargull, Caitlin Potter, Brian Terlson, Ingvar Stepanyan, Chris Dickinson, Luke Hoban, and so many others, I can&#39;t even scratch the surface.</p> <p>The <em>You Don&#39;t Know JS</em> book series was born on Kickstarter, so I also wish to thank all my (nearly) 500 generous backers, without whom this book series could not have happened:</p> <blockquote> <p>Jan Szpila, nokiko, Murali Krishnamoorthy, Ryan Joy, Craig Patchett, pdqtrader, Dale Fukami, ray hatfield, R0drigo Perez [Mx], Dan Petitt, Jack Franklin, Andrew Berry, Brian Grinstead, Rob Sutherland, Sergi Meseguer, Phillip Gourley, Mark Watson, Jeff Carouth, Alfredo Sumaran, Martin Sachse, Marcio Barrios, Dan, AimelyneM, Matt Sullivan, Delnatte Pierre-Antoine, Jake Smith, Eugen Tudorancea, Iris, David Trinh, simonstl, Ray Daly, Uros Gruber, Justin Myers, Shai Zonis, Mom &amp; Dad, Devin Clark, Dennis Palmer, Brian Panahi Johnson, Josh Marshall, Marshall, Dennis Kerr, Matt Steele, Erik Slagter, Sacah, Justin Rainbow, Christian Nilsson, Delapouite, D.Pereira, Nicolas Hoizey, George V. Reilly, Dan Reeves, Bruno Laturner, Chad Jennings, Shane King, Jeremiah Lee Cohick, od3n, Stan Yamane, Marko Vucinic, Jim B, Stephen Collins, gir orsteinsson, Eric Pederson, Owain, Nathan Smith, Jeanetteurphy, Alexandre ELIS, Chris Peterson, Rik Watson, Luke Matthews, Justin Lowery, Morten Nielsen, Vernon Kesner, Chetan Shenoy, Paul Tregoing, Marc Grabanski, Dion Almaer, Andrew Sullivan, Keith Elsass, Tom Burke, Brian Ashenfelter, David Stuart, Karl Swedberg, Graeme, Brandon Hays, John Christopher, Gior, manoj reddy, Chad Smith, Jared Harbour, Minoru TODA, Chris Wigley, Daniel Mee, Mike, Handyface, Alex Jahraus, Carl Furrow, Rob Foulkrod, Max Shishkin, Leigh Penny Jr., Robert Ferguson, Mike van Hoenselaar, Hasse Schougaard, rajan venkataguru, Jeff Adams, Trae Robbins, Rolf Langenhuijzen, Jorge Antunes, Alex Koloskov, Hugh Greenish, Tim Jones, Jose Ochoa, Michael Brennan-White, Naga Harish Muvva, Barkczi Dvid, Kitt Hodsden, Paul McGraw, Sascha Goldhofer, Andrew Metcalf, Markus Krogh, Michael Mathews, Matt Jared, Juanfran, Georgie Kirschner, Kenny Lee, Ted Zhang, Amit Pahwa, Inbal Sinai, Dan Raine, Schabse Laks, Michael Tervoort, Alexandre Abreu, Alan Joseph Williams, NicolasD, Cindy Wong, Reg Braithwaite, LocalPCGuy, Jon Friskics, Chris Merriman, John Pena, Jacob Katz, Sue Lockwood, Magnus Johansson, Jeremy Crapsey, Grzegorz Pawowski, nico nuzzaci, Christine Wilks, Hans Bergren, charles montgomery, Ariel - Fogel, Ivan Kolev, Daniel Campos, Hugh Wood, Christian Bradford, Frdric Harper, Ionu Dan Popa, Jeff Trimble, Rupert Wood, Trey Carrico, Pancho Lopez, Jol kuijten, Tom A Marra, Jeff Jewiss, Jacob Rios, Paolo Di Stefano, Soledad Penades, Chris Gerber, Andrey Dolganov, Wil Moore III, Thomas Martineau, Kareem, Ben Thouret, Udi Nir, Morgan Laupies, jory carson-burson, Nathan L Smith, Eric Damon Walters, Derry Lozano-Hoyland, Geoffrey Wiseman, mkeehner, KatieK, Scott MacFarlane, Brian LaShomb, Adrien Mas, christopher ross, Ian Littman, Dan Atkinson, Elliot Jobe, Nick Dozier, Peter Wooley, John Hoover, dan, Martin A. Jackson, Hctor Fernando Hurtado, andy ennamorato, Paul Seltmann, Melissa Gore, Dave Pollard, Jack Smith, Philip Da Silva, Guy Israeli, @megalithic, Damian Crawford, Felix Gliesche, April Carter Grant, Heidi, jim tierney, Andrea Giammarchi, Nico Vignola, Don Jones, Chris Hartjes, Alex Howes, john gibbon, David J. Groom, BBox, Yu &#39;Dilys&#39; Sun, Nate Steiner, Brandon Satrom, Brian Wyant, Wesley Hales, Ian Pouncey, Timothy Kevin Oxley, George Terezakis, sanjay raj, Jordan Harband, Marko McLion, Wolfgang Kaufmann, Pascal Peuckert, Dave Nugent, Markus Liebelt, Welling Guzman, Nick Cooley, Daniel Mesquita, Robert Syvarth, Chris Coyier, Rmy Bach, Adam Dougal, Alistair Duggin, David Loidolt, Ed Richer, Brian Chenault, GoldFire Studios, Carles Andrs, Carlos Cabo, Yuya Saito, roberto ricardo, Barnett Klane, Mike Moore, Kevin Marx, Justin Love, Joe Taylor, Paul Dijou, Michael Kohler, Rob Cassie, Mike Tierney, Cody Leroy Lindley, tofuji, Shimon Schwartz, Raymond, Luc De Brouwer, David Hayes, Rhys Brett-Bowen, Dmitry, Aziz Khoury, Dean, Scott Tolinski - Level Up, Clement Boirie, Djordje Lukic, Anton Kotenko, Rafael Corral, Philip Hurwitz, Jonathan Pidgeon, Jason Campbell, Joseph C., SwiftOne, Jan Hohner, Derick Bailey, getify, Daniel Cousineau, Chris Charlton, Eric Turner, David Turner, Jol Galeran, Dharma Vagabond, adam, Dirk van Bergen, dave  furf, Vedran Zakanj, Ryan McAllen, Natalie Patrice Tucker, Eric J. Bivona, Adam Spooner, Aaron Cavano, Kelly Packer, Eric J, Martin Drenovac, Emilis, Michael Pelikan, Scott F. Walter, Josh Freeman, Brandon Hudgeons, vijay chennupati, Bill Glennon, Robin R., Troy Forster, otaku_coder, Brad, Scott, Frederick Ostrander, Adam Brill, Seb Flippence, Michael Anderson, Jacob, Adam Randlett, Standard, Joshua Clanton, Sebastian Kouba, Chris Deck, SwordFire, Hannes Papenberg, Richard Woeber, hnzz, Rob Crowther, Jedidiah Broadbent, Sergey Chernyshev, Jay-Ar Jamon, Ben Combee, luciano bonachela, Mark Tomlinson, Kit Cambridge, Michael Melgares, Jacob Adams, Adrian Bruinhout, Bev Wieber, Scott Puleo, Thomas Herzog, April Leone, Daniel Mizieliski, Kees van Ginkel, Jon Abrams, Erwin Heiser, Avi Laviad, David newell, Jean-Francois Turcot, Niko Roberts, Erik Dana, Charles Neill, Aaron Holmes, Grzegorz Zikowski, Nathan Youngman, Timothy, Jacob Mather, Michael Allan, Mohit Seth, Ryan Ewing, Benjamin Van Treese, Marcelo Santos, Denis Wolf, Phil Keys, Chris Yung, Timo Tijhof, Martin Lekvall, Agendine, Greg Whitworth, Helen Humphrey, Dougal Campbell, Johannes Harth, Bruno Girin, Brian Hough, Darren Newton, Craig McPheat, Olivier Tille, Dennis Roethig, Mathias Bynens, Brendan Stromberger, sundeep, John Meyer, Ron Male, John F Croston III, gigante, Carl Bergenhem, B.J. May, Rebekah Tyler, Ted Foxberry, Jordan Reese, Terry Suitor, afeliz, Tom Kiefer, Darragh Duffy, Kevin Vanderbeken, Andy Pearson, Simon Mac Donald, Abid Din, Chris Joel, Tomas Theunissen, David Dick, Paul Grock, Brandon Wood, John Weis, dgrebb, Nick Jenkins, Chuck Lane, Johnny Megahan, marzsman, Tatu Tamminen, Geoffrey Knauth, Alexander Tarmolov, Jeremy Tymes, Chad Auld, Sean Parmelee, Rob Staenke, Dan Bender, Yannick derwa, Joshua Jones, Geert Plaisier, Tom LeZotte, Christen Simpson, Stefan Bruvik, Justin Falcone, Carlos Santana, Michael Weiss, Pablo Villoslada, Peter deHaan, Dimitris Iliopoulos, seyDoggy, Adam Jordens, Noah Kantrowitz, Amol M, Matthew Winnard, Dirk Ginader, Phinam Bui, David Rapson, Andrew Baxter, Florian Bougel, Michael George, Alban Escalier, Daniel Sellers, Sasha Rudan, John Green, Robert Kowalski, David I. Teixeira (@ditma, Charles Carpenter, Justin Yost, Sam S, Denis Ciccale, Kevin Sheurs, Yannick Croissant, Pau Fracs, Stephen McGowan, Shawn Searcy, Chris Ruppel, Kevin Lamping, Jessica Campbell, Christopher Schmitt, Sablons, Jonathan Reisdorf, Bunni Gek, Teddy Huff, Michael Mullany, Michael Frstenberg, Carl Henderson, Rick Yoesting, Scott Nichols, Hernn Ciudad, Andrew Maier, Mike Stapp, Jesse Shawl, Srgio Lopes, jsulak, Shawn Price, Joel Clermont, Chris Ridmann, Sean Timm, Jason Finch, Aiden Montgomery, Elijah Manor, Derek Gathright, Jesse Harlin, Dillon Curry, Courtney Myers, Diego Cadenas, Arne de Bree, Joo Paulo Dubas, James Taylor, Philipp Kraeutli, Mihai Pun, Sam Gharegozlou, joshjs, Matt Murchison, Eric Windham, Timo Behrmann, Andrew Hall, joshua price, Thophile Villard</p> </blockquote> <p>This book series is being produced in an open source fashion, including editing and production. We owe GitHub a debt of gratitude for making that sort of thing possible for the community!</p> <p>Thank you again to all the countless folks I didn&#39;t name but who I nonetheless owe thanks. May this book series be &quot;owned&quot; by all of us and serve to contribute to increasing awareness and understanding of the JavaScript language, to the benefit of all current and future community contributors.</p> ","title":"You Don't Know JS: ES6 & Beyond"},"ch3":{"body":"<h1 id=\"chapter-3-organization\">Chapter 3: Organization</h1> <p>It&#39;s one thing to write JS code, but it&#39;s another to properly organize it. Utilizing common patterns for organization and reuse goes a long way to improving the readability and understandability of your code. Remember: code is at least as much about communicating to other developers as it is about feeding the computer instructions.</p> <p>ES6 has several important features that help signficantly improve these patterns, including: iterators, generators, modules, and classes.</p> <h2 id=\"iterators\">Iterators</h2> <p>An <em>iterator</em> is a structured pattern for pulling information from a source in one-at-a-time fashion. This pattern has been around programming for a long time. And to be sure, JS developers have been ad hoc designing and implementing iterators in JS programs since before anyone can remember, so it&#39;s not at all a new topic.</p> <p>What ES6 has done is introduce an implicit standardized interface for iterators. Many of the built-in data structures in JavaScript will now expose an iterator implementing this standard. And you can also construct your own iterators adhering to the same standard, for maximal interoperability.</p> <p>Iterators are a way of organizing ordered, sequential, pull-based consumption of data.</p> <p>For example, you may implement a utility that produces a new unique identifier each time it&#39;s requested. Or you may produce an infinite series of values that rotate through a fixed list, in round-robin fashion. Or you could attach an iterator to a database query result to pull out new rows one at a time.</p> <p>Although they have not commonly been used in JS in such a manner, iterators can also be thought of as controlling behavior one step at a time. This can be illustrated quite clearly when considering generators (see &quot;Generators&quot; later in this chapter), though you can certainly do the same without generators.</p> <h3 id=\"interfaces\">Interfaces</h3> <p>At the time of this writing, ES6 section 25.1.1.2 (<a href=\"https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface\">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface</a>) details the <code>Iterator</code> interface as having the following requirement:</p> <pre><code><span class=\"hljs-type\">Iterator</span> [required]     next() {<span class=\"hljs-keyword\">method</span>}: retrieves next <span class=\"hljs-type\">IteratorResult</span> </code></pre><p>There are two optional members that some iterators are extended with:</p> <pre><code><span class=\"hljs-type\">Iterator</span> [optional]     <span class=\"hljs-keyword\">return</span>() {<span class=\"hljs-keyword\">method</span>}: stops <span class=\"hljs-keyword\">iterator</span> <span class=\"hljs-keyword\">and</span> returns <span class=\"hljs-type\">IteratorResult</span>     throw() {<span class=\"hljs-keyword\">method</span>}: signals error <span class=\"hljs-keyword\">and</span> returns <span class=\"hljs-type\">IteratorResult</span> </code></pre><p>The <code>IteratorResult</code> interface is specified as:</p> <pre><code>IteratorResult     <span class=\"hljs-keyword\">value</span> {property}: current iteration <span class=\"hljs-keyword\">value</span> or <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">value</span>         (<span class=\"hljs-type\">optional</span> <span class=\"hljs-keyword\">if</span> `undefined`)     done {property}: boolean, indicates completion <span class=\"hljs-keyword\">status</span> </code></pre><p><strong>Note:</strong> I call these interfaces implicit not because they&#39;re not explicitly called out in the specification -- they are! -- but because they&#39;re not exposed as direct objects accessible to code. JavaScript does not, in ES6, support any notion of &quot;interfaces,&quot; so adherence for your own code is purely conventional. However, wherever JS expects an iterator -- a <code>for..of</code> loop, for instance -- what you provide must adhere to these interfaces or the code will fail.</p> <p>There&#39;s also an <code>Iterable</code> interface, which describes objects that must be able to produce iterators:</p> <pre><code><span class=\"hljs-type\">Iterable</span>     @@<span class=\"hljs-keyword\">iterator</span>() {<span class=\"hljs-keyword\">method</span>}: produces an <span class=\"hljs-type\">Iterator</span> </code></pre><p>If you recall from &quot;Built-In Symbols&quot; in Chapter 2, <code>@@iterator</code> is the special built-in symbol representing the method that can produce iterator(s) for the object.</p> <h4 id=\"iteratorresult\">IteratorResult</h4> <p>The <code>IteratorResult</code> interface specifies that the return value from any iterator operation will be an object of the form:</p> <pre><code class=\"lang-js\">{ <span class=\"hljs-string\">value:</span> .. , <span class=\"hljs-string\">done:</span> <span class=\"hljs-literal\">true</span> / <span class=\"hljs-literal\">false</span> } </code></pre> <p>Built-in iterators will always return values of this form, but more properties are, of course, allowed to be present on the return value, as necessary.</p> <p>For example, a custom iterator may add additional metadata to the result object (e.g., where the data came from, how long it took to retrieve, cache expiration length, frequency for the appropriate next request, etc.).</p> <p><strong>Note:</strong> Technically, <code>value</code> is optional if it would otherwise be considered absent or unset, such as in the case of the value <code>undefined</code>. Because accessing <code>res.value</code> will produce <code>undefined</code> whether it&#39;s present with that value or absent entirely, the presence/absence of the property is more an implementation detail or an optimization (or both), rather than a functional issue.</p> <h3 id=\"-next-iteration\"><code>next()</code> Iteration</h3> <p>Let&#39;s look at an array, which is an iterable, and the iterator it can produce to consume its values:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];  <span class=\"hljs-keyword\">var</span> it = arr[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]();  it.next();        // { value: <span class=\"hljs-number\">1</span>, done: <span class=\"hljs-literal\">false</span> } it.next();        // { value: <span class=\"hljs-number\">2</span>, done: <span class=\"hljs-literal\">false</span> } it.next();        // { value: <span class=\"hljs-number\">3</span>, done: <span class=\"hljs-literal\">false</span> }  it.next();        // { value: undefined, done: <span class=\"hljs-literal\">true</span> } </code></pre> <p>Each time the method located at <code>Symbol.iterator</code> (see Chapters 2 and 7) is invoked on this <code>arr</code> value, it will produce a new fresh iterator. Most structures will do the same, including all the built-in data structures in JS.</p> <p>However, a structure like an event queue consumer might only ever produce a single iterator (singleton pattern). Or a structure might only allow one unique iterator at a time, requiring the current one to be completed before a new one can be created.</p> <p>The <code>it</code> iterator in the previous snippet doesn&#39;t report <code>done: true</code> when you receive the <code>3</code> value. You have to call <code>next()</code> again, in essence going beyond the end of the array&#39;s values, to get the complete signal <code>done: true</code>. It may not be clear why until later in this section, but that design decision will typically be considered a best practice.</p> <p>Primitive string values are also iterables by default:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> greeting = <span class=\"hljs-string\">\"hello world\"</span>;  <span class=\"hljs-keyword\">var</span> it = greeting[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]();  it.next();        // { value: <span class=\"hljs-string\">\"h\"</span>, done: <span class=\"hljs-literal\">false</span> } it.next();        // { value: <span class=\"hljs-string\">\"e\"</span>, done: <span class=\"hljs-literal\">false</span> } .. </code></pre> <p><strong>Note:</strong> Technically, the primitive value itself isn&#39;t iterable, but thanks to &quot;boxing&quot;, <code>&quot;hello world&quot;</code> is coerced/converted to its <code>String</code> object wrapper form, which <em>is</em> an iterable. See the <em>Types &amp; Grammar</em> title of this series for more information.</p> <p>ES6 also includes several new data structures, called collections (see Chapter 5). These collections are not only iterables themselves, but they also provide API method(s) to generate an iterator, such as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> m = new <span class=\"hljs-type\">Map</span>(); m.<span class=\"hljs-type\">set</span>( <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-number\">42</span> ); m.<span class=\"hljs-type\">set</span>( { cool: <span class=\"hljs-literal\">true</span> }, <span class=\"hljs-string\">\"hello world\"</span> );  <span class=\"hljs-keyword\">var</span> it1 = m[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>](); <span class=\"hljs-keyword\">var</span> it2 = m.entries();  it1.next();        // { value: [ <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-number\">42</span> ], done: <span class=\"hljs-literal\">false</span> } it2.next();        // { value: [ <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-number\">42</span> ], done: <span class=\"hljs-literal\">false</span> } .. </code></pre> <p>The <code>next(..)</code> method of an iterator can optionally take one or more arguments. The built-in iterators mostly do not exercise this capability, though a generator&#39;s iterator definitely does (see &quot;Generators&quot; later in this chapter).</p> <p>By general convention, including all the built-in iterators, calling <code>next(..)</code> on an iterator that&#39;s already been exhausted is not an error, but will simply continue to return the result <code>{ value: undefined, done: true }</code>.</p> <h3 id=\"optional-return-and-throw-\">Optional: <code>return(..)</code> and <code>throw(..)</code></h3> <p>The optional methods on the iterator interface -- <code>return(..)</code> and <code>throw(..)</code> -- are not implemented on most of the built-in iterators. However, they definitely do mean something in the context of generators, so see &quot;Generators&quot; for more specific information.</p> <p><code>return(..)</code> is defined as sending a signal to an iterator that the consuming code is complete and will not be pulling any more values from it. This signal can be used to notify the producer (the iterator responding to <code>next(..)</code> calls) to perform any cleanup it may need to do, such as releasing/closing network, database, or file handle resources.</p> <p>If an iterator has a <code>return(..)</code> present and any condition occurs that can automatically be interpreted as abnormal or early termination of consuming the iterator, <code>return(..)</code> will automatically be called. You can call <code>return(..)</code> manually as well.</p> <p><code>return(..)</code> will return an <code>IteratorResult</code> object just like <code>next(..)</code> does. In general, the optional value you send to <code>return(..)</code> would be sent back as <code>value</code> in this <code>IteratorResult</code>, though there are nuanced cases where that might not be true.</p> <p><code>throw(..)</code> is used to signal an exception/error to an iterator, which possibly may be used differently by the iterator than the completion signal implied by <code>return(..)</code>. It does not necessarily imply a complete stop of the iterator as <code>return(..)</code> generally does.</p> <p>For example, with generator iterators, <code>throw(..)</code> actually injects a thrown exception into the generator&#39;s paused execution context, which can be caught with a <code>try..catch</code>. An uncaught <code>throw(..)</code> exception would end up abnormally aborting the generator&#39;s iterator.</p> <p><strong>Note:</strong> By general convention, an iterator should not produce any more results after having called <code>return(..)</code> or <code>throw(..)</code>.</p> <h3 id=\"iterator-loop\">Iterator Loop</h3> <p>As we covered in the &quot;<code>for..of</code>&quot; section in Chapter 2, the ES6 <code>for..of</code> loop directly consumes a conforming iterable.</p> <p>If an iterator is also an iterable, it can be used directly with the <code>for..of</code> loop. You make an iterator an iterable by giving it a <code>Symbol.iterator</code> method that simply returns the iterator itself:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> it = {     // make the `it` <span class=\"hljs-keyword\">iterator</span> an iterable     [<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]() { <span class=\"hljs-keyword\">return</span> this; },      next() { .. },     .. };  it[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]() === it;        // <span class=\"hljs-literal\">true</span> </code></pre> <p>Now we can consume the <code>it</code> iterator with a <code>for..of</code> loop:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-literal\">it</span>) {     <span class=\"hljs-built_in\">console</span>.log( v ); } </code></pre> <p>To fully understand how such a loop works, recall the <code>for</code> equivalent of a <code>for..of</code> loop from Chapter 2:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v, res; (res = <span class=\"hljs-literal\">it</span>.next()) &amp;&amp; !res.done; ) {     v = res.value;     <span class=\"hljs-built_in\">console</span>.log( v ); } </code></pre> <p>If you look closely, you&#39;ll see that <code>it.next()</code> is called before each iteration, and then <code>res.done</code> is consulted. If <code>res.done</code> is <code>true</code>, the expression evaluates to <code>false</code> and the iteration doesn&#39;t occur.</p> <p>Recall earlier that we suggested iterators should in general not return <code>done: true</code> along with the final intended value from the iterator. Now you can see why.</p> <p>If an iterator returned <code>{ done: true, value: 42 }</code>, the <code>for..of</code> loop would completely discard the <code>42</code> value and it&#39;d be lost. For this reason, assuming that your iterator may be consumed by patterns like the <code>for..of</code> loop or its manual <code>for</code> equivalent, you should probably wait to return <code>done: true</code> for signaling completion until after you&#39;ve already returned all relevant iteration values.</p> <p><strong>Warning:</strong> You can, of course, intentionally design your iterator to return some relevant <code>value</code> at the same time as returning <code>done: true</code>. But don&#39;t do this unless you&#39;ve documented that as the case, and thus implicitly forced consumers of your iterator to use a different pattern for iteration than is implied by <code>for..of</code> or its manual equivalent we depicted.</p> <h3 id=\"custom-iterators\">Custom Iterators</h3> <p>In addition to the standard built-in iterators, you can make your own! All it takes to make them interoperate with ES6&#39;s consumption facilities (e.g., the <code>for..of</code> loop and the <code>...</code> operator) is to adhere to the proper interface(s).</p> <p>Let&#39;s try constructing an iterator that produces the infinite series of numbers in the Fibonacci sequence:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-type\">Fib</span> = {     [<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]() {         <span class=\"hljs-keyword\">var</span> n1 = <span class=\"hljs-number\">1</span>, n2 = <span class=\"hljs-number\">1</span>;          <span class=\"hljs-keyword\">return</span> {             // make the <span class=\"hljs-keyword\">iterator</span> an iterable             [<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]() { <span class=\"hljs-keyword\">return</span> this; },              next() {                 <span class=\"hljs-keyword\">var</span> current = n2;                 n2 = n1;                 n1 = n1 + current;                 <span class=\"hljs-keyword\">return</span> { value: current, done: <span class=\"hljs-literal\">false</span> };             },              <span class=\"hljs-keyword\">return</span>(v) {                 console.log(                     <span class=\"hljs-string\">\"Fibonacci sequence abandoned.\"</span>                 );                 <span class=\"hljs-keyword\">return</span> { value: v, done: <span class=\"hljs-literal\">true</span> };             }         };     } };  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> <span class=\"hljs-type\">Fib</span>) {     console.log( v );      <span class=\"hljs-keyword\">if</span> (v &gt; <span class=\"hljs-number\">50</span>) <span class=\"hljs-keyword\">break</span>; } // <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">13</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">34</span> <span class=\"hljs-number\">55</span> // <span class=\"hljs-type\">Fibonacci</span> sequence abandoned. </code></pre> <p><strong>Warning:</strong> If we hadn&#39;t inserted the <code>break</code> condition, this <code>for..of</code> loop would have run forever, which is probably not the desired result in terms of breaking your program!</p> <p>The <code>Fib[Symbol.iterator]()</code> method when called returns the iterator object with <code>next()</code> and <code>return(..)</code> methods on it. State is maintained via <code>n1</code> and <code>n2</code> variables, which are kept by the closure.</p> <p>Let&#39;s <em>next</em> consider an iterator that is designed to run through a series (aka a queue) of actions, one item at a time:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> tasks = {     [<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]() {         <span class=\"hljs-keyword\">var</span> steps = this.actions.slice();          <span class=\"hljs-keyword\">return</span> {             // make the <span class=\"hljs-keyword\">iterator</span> an iterable             [<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]() { <span class=\"hljs-keyword\">return</span> this; },              next(...args) {                 <span class=\"hljs-keyword\">if</span> (steps.length &gt; <span class=\"hljs-number\">0</span>) {                     <span class=\"hljs-keyword\">let</span> res = steps.shift()( ...args );                     <span class=\"hljs-keyword\">return</span> { value: res, done: <span class=\"hljs-literal\">false</span> };                 }                 <span class=\"hljs-keyword\">else</span> {                     <span class=\"hljs-keyword\">return</span> { done: <span class=\"hljs-literal\">true</span> }                 }             },              <span class=\"hljs-keyword\">return</span>(v) {                 steps.length = <span class=\"hljs-number\">0</span>;                 <span class=\"hljs-keyword\">return</span> { value: v, done: <span class=\"hljs-literal\">true</span> };             }         };     },     actions: [] }; </code></pre> <p>The iterator on <code>tasks</code> steps through functions found in the <code>actions</code> array property, if any, and executes them one at a time, passing in whatever arguments you pass to <code>next(..)</code>, and returning any return value to you in the standard <code>IteratorResult</code> object.</p> <p>Here&#39;s how we could could use this <code>tasks</code> queue:</p> <pre><code class=\"lang-js\">tasks.actions.push(     <span class=\"hljs-function\">function <span class=\"hljs-title\">step1</span><span class=\"hljs-params\">(x)</span></span>{         console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"step 1:\"</span>, x );         <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>;     },     <span class=\"hljs-function\">function <span class=\"hljs-title\">step2</span><span class=\"hljs-params\">(x,y)</span></span>{         console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"step 2:\"</span>, x, y );         <span class=\"hljs-keyword\">return</span> x + (y * <span class=\"hljs-number\">2</span>);     },     <span class=\"hljs-function\">function <span class=\"hljs-title\">step3</span><span class=\"hljs-params\">(x,y,z)</span></span>{         console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"step 3:\"</span>, x, y, z );         <span class=\"hljs-keyword\">return</span> (x * y) + z;     } );  var it = tasks[Symbol.iterator]();  it.next( <span class=\"hljs-number\">10</span> );            <span class=\"hljs-comment\">// step 1: 10</span>                         <span class=\"hljs-comment\">// { value:   20, done: false }</span>  it.next( <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">50</span> );        <span class=\"hljs-comment\">// step 2: 20 50</span>                         <span class=\"hljs-comment\">// { value:  120, done: false }</span>  it.next( <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">50</span>, <span class=\"hljs-number\">120</span> );    <span class=\"hljs-comment\">// step 3: 20 50 120</span>                         <span class=\"hljs-comment\">// { value: 1120, done: false }</span>  it.next();                <span class=\"hljs-comment\">// { done: true }</span> </code></pre> <p>This particular usage reinforces that iterators can be a pattern for organizing functionality, not just data. It&#39;s also reminiscent of what we&#39;ll see with generators in the next section.</p> <p>You could even get creative and define an iterator that represents meta operations on a single piece of data. For example, we could define an iterator for numbers that by default ranges from <code>0</code> up to (or down to, for negative numbers) the number in question.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-type\">Number</span>.prototype[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>]) {     <span class=\"hljs-type\">Object</span>.defineProperty(         <span class=\"hljs-type\">Number</span>.prototype,         <span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>,         {             writable: <span class=\"hljs-literal\">true</span>,             configurable: <span class=\"hljs-literal\">true</span>,             enumerable: <span class=\"hljs-literal\">false</span>,             value: function <span class=\"hljs-keyword\">iterator</span>(){                 <span class=\"hljs-keyword\">var</span> i, inc, done = <span class=\"hljs-literal\">false</span>, top = +this;                  // iterate positively <span class=\"hljs-keyword\">or</span> negatively?                 inc = <span class=\"hljs-number\">1</span> * (top &lt; <span class=\"hljs-number\">0</span> ? -<span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>);                  <span class=\"hljs-keyword\">return</span> {                     // make the <span class=\"hljs-keyword\">iterator</span> itself an iterable!                     [<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>](){ <span class=\"hljs-keyword\">return</span> this; },                      next() {                         <span class=\"hljs-keyword\">if</span> (!done) {                             // initial iteration always <span class=\"hljs-number\">0</span>                             <span class=\"hljs-keyword\">if</span> (i == null) {                                 i = <span class=\"hljs-number\">0</span>;                             }                             // iterating positively                             <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (top &gt;= <span class=\"hljs-number\">0</span>) {                                 i = <span class=\"hljs-type\">Math</span>.min(top,i + inc);                             }                             // iterating negatively                             <span class=\"hljs-keyword\">else</span> {                                 i = <span class=\"hljs-type\">Math</span>.max(top,i + inc);                             }                              // done after this iteration?                             <span class=\"hljs-keyword\">if</span> (i == top) done = <span class=\"hljs-literal\">true</span>;                              <span class=\"hljs-keyword\">return</span> { value: i, done: <span class=\"hljs-literal\">false</span> };                         }                         <span class=\"hljs-keyword\">else</span> {                             <span class=\"hljs-keyword\">return</span> { done: <span class=\"hljs-literal\">true</span> };                         }                     }                 };             }         }     ); } </code></pre> <p>Now, what tricks does this creativity afford us?</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">for</span> (var i of <span class=\"hljs-number\">3</span>) {     console.<span class=\"hljs-built_in\">log</span>( i ); } <span class=\"hljs-comment\">// 0 1 2 3</span>  [...-<span class=\"hljs-number\">3</span>];                <span class=\"hljs-comment\">// [0,-1,-2,-3]</span> </code></pre> <p>Those are some fun tricks, though the practical utility is somewhat debatable. But then again, one might wonder why ES6 didn&#39;t just ship with such a minor but delightful feature easter egg!?</p> <p>I&#39;d be remiss if I didn&#39;t at least remind you that extending native prototypes as I&#39;m doing in the previous snippet is something you should only do with caution and awareness of potential hazards.</p> <p>In this case, the chances that you&#39;ll have a collision with other code or even a future JS feature is probably exceedingly low. But just beware of the slight possibility. And document what you&#39;re doing verbosely for posterity&#39;s sake.</p> <p><strong>Note:</strong> I&#39;ve expounded on this particular technique in this blog post (<a href=\"http://blog.getify.com/iterating-es6-numbers/\">http://blog.getify.com/iterating-es6-numbers/</a>) if you want more details. And this comment (<a href=\"http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294\">http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294</a>) even suggests a similar trick but for making string character ranges.</p> <h3 id=\"iterator-consumption\">Iterator Consumption</h3> <p>We&#39;ve already shown consuming an iterator item by item with the <code>for..of</code> loop. But there are other ES6 structures that can consume iterators.</p> <p>Let&#39;s consider the iterator attached to this array (though any iterator we choose would have the following behaviors):</p> <pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]; </code></pre> <p>The <code>...</code> spread operator fully exhausts an iterator. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y,z,w,p)</span> <span class=\"hljs-comment\">{     console.log( x + y + z + w + p ); }</span>  <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">( ...a )</span>;</span>            <span class=\"hljs-comment\">// 15</span> </code></pre> <p><code>...</code> can also spread an iterator inside an array:</p> <pre><code class=\"lang-js\">var b = [ <span class=\"hljs-number\">0</span>, ...a, <span class=\"hljs-number\">6</span> ]; b;                        <span class=\"hljs-comment\">// [0,1,2,3,4,5,6]</span> </code></pre> <p>Array destructuring (see &quot;Destructuring&quot; in Chapter 2) can partially or completely (if paired with a <code>...</code> rest/gather operator) consume an iterator:</p> <pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> it</span> = a[Symbol.iterator]();  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> [x,y]</span> = it;            <span class=\"hljs-comment\">// take just the first two elements from `it`</span> <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> [z, ...w]</span> = it;        <span class=\"hljs-comment\">// take the third, then the rest all at once</span>  <span class=\"hljs-comment\">// is `it` fully exhausted? Yep.</span> it.next();                <span class=\"hljs-comment\">// { value: undefined, done: true }</span>  x;                        <span class=\"hljs-comment\">// 1</span> y;                        <span class=\"hljs-comment\">// 2</span> z;                        <span class=\"hljs-comment\">// 3</span> w;                        <span class=\"hljs-comment\">// [4,5]</span> </code></pre> <h2 id=\"generators\">Generators</h2> <p>All functions run to completion, right? In other words, once a function starts running, it finishes before anything else can interrupt.</p> <p>At least that&#39;s how it&#39;s been for the whole history of JavaScript up to this point. As of ES6, a new somewhat exotic form of function is being introduced, called a generator. A generator can pause itself in mid-execution, and can be resumed either right away or at a later time. So it clearly does not hold the run-to-completion guarantee that normal functions do.</p> <p>Moreover, each pause/resume cycle in mid-execution is an opportunity for two-way message passing, where the generator can return a value, and the controlling code that resumes it can send a value back in.</p> <p>As with iterators in the previous section, there are multiple ways to think about what a generator is, or rather what it&#39;s most useful for. There&#39;s no one right answer, but we&#39;ll try to consider several angles.</p> <p><strong>Note:</strong> See the <em>Async &amp; Performance</em> title of this series for more information about generators, and also see Chapter 4 of this current title.</p> <h3 id=\"syntax\">Syntax</h3> <p>The generator function is declared with this new syntax:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-comment\">// ..</span> } </code></pre> <p>The position of the <code>*</code> is not functionally relevant. The same declaration could be written as any of the following:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)  </span>{ .. } <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)  </span>{ .. } <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> * <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>)   </span>{ .. } .. </code></pre> <p>The <em>only</em> difference here is stylistic preference. Most other literature seems to prefer <code>function* foo(..) { .. }</code>. I prefer <code>function *foo(..) { .. }</code>, so that&#39;s how I&#39;ll present them for the rest of this title.</p> <p>My reason is purely didactic in nature. In this text, when referring to a generator function, I will use <code>*foo(..)</code>, as opposed to <code>foo(..)</code> for a normal function. I observe that <code>*foo(..)</code> more closely matches the <code>*</code> positioning of <code>function *foo(..) { .. }</code>.</p> <p>Moreover, as we saw in Chapter 2 with concise methods, there&#39;s a concise generator form in object literals:</p> <pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> a</span> = {     *foo() { .. } }; </code></pre> <p>I would say that with concise generators, <code>*foo() { .. }</code> is rather more natural than <code>* foo() { .. }</code>. So that further argues for matching the consistency with <code>*foo()</code>.</p> <p>Consistency eases understanding and learning.</p> <h4 id=\"executing-a-generator\">Executing a Generator</h4> <p>Though a generator is declared with <code>*</code>, you still execute it like a normal function:</p> <pre><code class=\"lang-js\">foo()<span class=\"hljs-comment\">;</span> </code></pre> <p>You can still pass it arguments, as in:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\">function *<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x,y)</span> </span>{     <span class=\"hljs-comment\">// ..</span> }  foo( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">10</span> ); </code></pre> <p>The major difference is that executing a generator, like <code>foo(5,10)</code> doesn&#39;t actually run the code in the generator. Instead, it produces an iterator that will control the generator to execute its code.</p> <p>We&#39;ll come back to this later in &quot;Iterator Control,&quot; but briefly:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-comment\">// ..</span> }  <span class=\"hljs-keyword\">var</span> it = foo();  <span class=\"hljs-comment\">// to start/advanced `*foo()`, call</span> <span class=\"hljs-comment\">// `it.next(..)`</span> </code></pre> <h4 id=\"-yield-\"><code>yield</code></h4> <p>Generators also have a new keyword you can use inside them, to signal the pause point: <code>yield</code>. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">10</span>;     <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-number\">20</span>;      <span class=\"hljs-keyword\">yield</span>;      <span class=\"hljs-keyword\">var</span> z = x + y; } </code></pre> <p>In this <code>*foo()</code> generator, the operations on the first two lines would run at the beginning, then <code>yield</code> would pause the generator. If and when resumed, the last line of <code>*foo()</code> would run. <code>yield</code> can appear any number of times (or not at all, technically!) in a generator.</p> <p>You can even put <code>yield</code> inside a loop, and it can represent a repeated pause point. In fact, a loop that never completes just means a generator that never completes, which is completely valid, and sometimes entirely what you need.</p> <p><code>yield</code> is not just a pause point. It&#39;s an expression that sends out a value when pausing the generator. Here&#39;s a <code>while..true</code> loop in a generator that for each iteration <code>yield</code>s a new random number:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) {         <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Math</span>.random();     } } </code></pre> <p>The <code>yield ..</code> expression not only sends a value -- <code>yield</code> without a value is the same as <code>yield undefined</code> -- but also receives (e.g., is replaced by) the eventual resumption value. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">10</span>;     <span class=\"hljs-built_in\">console</span>.log( x ); } </code></pre> <p>This generator will first <code>yield</code> out the value <code>10</code> when pausing itself. When you resume the generator -- using the <code>it.next(..)</code> we referred to earlier -- whatever value (if any) you resume with will replace/complete the whole <code>yield 10</code> expression, meaning that value will be assigned to the <code>x</code> variable.</p> <p>A <code>yield ..</code> expression can appear anywhere a normal expression can. For example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> arr = [ <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span> ];     <span class=\"hljs-built_in\">console</span>.log( arr, <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">4</span> ); } </code></pre> <p><code>*foo()</code> here has four <code>yield ..</code> expressions. Each <code>yield</code> results in the generator pausing to wait for a resumption value that&#39;s then used in the various expression contexts.</p> <p><code>yield</code> is not technically an operator, though when used like <code>yield 1</code> it sure looks like it. Because <code>yield</code> can be used all by itself as in <code>var x = yield;</code>, thinking of it as an operator can sometimes be confusing.</p> <p>Technically, <code>yield ..</code> is of the same &quot;expression precedence&quot; -- similar conceptually to operator precedence -- as an assignment expression like <code>a = 3</code>. That means <code>yield ..</code> can basically appear anywhere <code>a = 3</code> can validly appear.</p> <p>Let&#39;s illustrate the symmetry:</p> <pre><code class=\"lang-js\">var a, b;  a = <span class=\"hljs-number\">3</span>;                    <span class=\"hljs-comment\">// valid</span> b = <span class=\"hljs-number\">2</span> + a = <span class=\"hljs-number\">3</span>;            <span class=\"hljs-comment\">// invalid</span> b = <span class=\"hljs-number\">2</span> + (a = <span class=\"hljs-number\">3</span>);        <span class=\"hljs-comment\">// valid</span>  yield <span class=\"hljs-number\">3</span>;                <span class=\"hljs-comment\">// valid</span> a = <span class=\"hljs-number\">2</span> + yield <span class=\"hljs-number\">3</span>;        <span class=\"hljs-comment\">// invalid</span> a = <span class=\"hljs-number\">2</span> + (yield <span class=\"hljs-number\">3</span>);        <span class=\"hljs-comment\">// valid</span> </code></pre> <p><strong>Note:</strong> If you think about it, it makes a sort of conceptual sense that a <code>yield ..</code> expression would behave similar to an assignment expression. When a paused <code>yield</code> expression is resumed, it&#39;s completed/replaced by the resumption value in a way that&#39;s not terribly dissimilar from being &quot;assigned&quot; that value.</p> <p>The takeaway: if you need <code>yield ..</code> to appear in a position where an assignment like <code>a = 3</code> would not itself be allowed, it needs to be wrapped in a <code>( )</code>.</p> <p>Because of the low precedence of the <code>yield</code> keyword, almost any expression after a <code>yield ..</code> will be computed first before being sent with <code>yield</code>. Only the <code>...</code> spread operator and the <code>,</code> comma operator have lower precedence, meaning they&#39;d bind after the <code>yield</code> has been evaluated.</p> <p>So just like with multiple operators in normal statements, another case where <code>( )</code> might be needed is to override (elevate) the low precedence of <code>yield</code>, such as the difference between these expressions:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">3</span>;            <span class=\"hljs-regexp\">//</span> same as <span class=\"hljs-string\">`yield (2 + 3)`</span>  (<span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>) + <span class=\"hljs-number\">3</span>;            <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">`yield 2`</span> first, <span class=\"hljs-keyword\">then</span> <span class=\"hljs-string\">`+ 3`</span> </code></pre> <p>Just like <code>=</code> assignment, <code>yield</code> is also &quot;right-associative,&quot; which means that multiple <code>yield</code> expressions in succession are treated as having been <code>( .. )</code> grouped from right to left. So, <code>yield yield yield 3</code> is treated as <code>yield (yield (yield 3))</code>. A &quot;left-associative&quot; interpretation like <code>((yield) yield) yield 3</code> would make no sense.</p> <p>Just like with operators, it&#39;s a good idea to use <code>( .. )</code> grouping, even if not strictly required, to disambiguate your intent if <code>yield</code> is combined with other operators or <code>yield</code>s.</p> <p><strong>Note:</strong> See the <em>Types &amp; Grammar</em> title of this series for more information about operator precedence and associativity.</p> <h4 id=\"-yield-\"><code>yield *</code></h4> <p>In the same way that the <code>*</code> makes a <code>function</code> declaration into <code>function *</code> generator declaration, a <code>*</code> makes <code>yield</code> into <code>yield *</code>, which is a very different mechanism, called <em>yield delegation</em>. Grammatically, <code>yield *..</code> will behave the same as a <code>yield ..</code>, as discussed in the previous section.</p> <p><code>yield * ..</code> requires an iterable; it then invokes that iterable&#39;s iterator, and delegates its own host generator&#39;s control to that iterator until it&#39;s exhausted. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\">function *<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{     yield *[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]; } </code></pre> <p><strong>Note:</strong> As with the <code>*</code> position in a generator&#39;s declaration (discussed earlier), the <code>*</code> positioning in <code>yield *</code> expressions is stylistically up to you. Most other literature prefers <code>yield* ..</code>, but I prefer <code>yield *..</code>, for very symmetrical reasons as already discussed.</p> <p>The <code>[1,2,3]</code> value produces an iterator that will step through its values, so the <code>*foo()</code> generator will yield those values out as it&#39;s consumed. Another way to illustrate the behavior is in yield delegating to another generator:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>; }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">yield</span> *foo(); } </code></pre> <p>The iterator produced when <code>*bar()</code> calls <code>*foo()</code> is delegated to via <code>yield *</code>, meaning whatever value(s) <code>*foo()</code> produces will be produced by <code>*bar()</code>.</p> <p>Whereas with <code>yield ..</code> the completion value of the expression comes from resuming the generator with <code>it.next(..)</code>, the completion value of the <code>yield *..</code> expression comes from the return value (if any) from the delegated-to iterator.</p> <p>Built-in iterators generally don&#39;t have return values, as we covered at the end of the &quot;Iterator Loop&quot; section earlier in this chapter. But if you define your own custom iterator (or generator), you can design it to <code>return</code> a value, which <code>yield *..</code> would capture:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">4</span>; }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">yield</span> *foo();     <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"x:\"</span>, x ); }  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> bar()) {     <span class=\"hljs-built_in\">console</span>.log( v ); } <span class=\"hljs-comment\">// 1 2 3</span> <span class=\"hljs-comment\">// x: 4</span> </code></pre> <p>While the <code>1</code>, <code>2</code>, and <code>3</code> values are <code>yield</code>ed out of <code>*foo()</code> and then out of <code>*bar()</code>, the <code>4</code> value returned from <code>*foo()</code> is the completion value of the <code>yield *foo()</code> expression, which then gets assigned to <code>x</code>.</p> <p>Because <code>yield *</code> can call another generator (by way of delegating to its iterator), it can also perform a sort of generator recursion by calling itself:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\">function *<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x)</span> </span>{     <span class=\"hljs-keyword\">if</span> (x &lt; <span class=\"hljs-number\">3</span>) {         x = <span class=\"hljs-function\">yield *<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">( x + <span class=\"hljs-number\">1</span> )</span></span>;     }     <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; }  foo( <span class=\"hljs-number\">1</span> ); </code></pre> <p>The result from <code>foo(1)</code> and then calling the iterator&#39;s <code>next()</code> to run it through its recursive steps will be <code>24</code>. The first <code>*foo(..)</code> run has <code>x</code> at value <code>1</code>, which is <code>x &lt; 3</code>. <code>x + 1</code> is passed recursively to <code>*foo(..)</code>, so <code>x</code> is then <code>2</code>. One more recursive call results in <code>x</code> of <code>3</code>.</p> <p>Now, because <code>x &lt; 3</code> fails, the recursion stops, and <code>return 3 * 2</code> gives <code>6</code> back to the previous call&#39;s <code>yield *..</code> expression, which is then assigned to <code>x</code>. Another <code>return 6 * 2</code> returns <code>12</code> back to the previous call&#39;s <code>x</code>. Finally <code>12 * 2</code>, or <code>24</code>, is returned from the completed run of the <code>*foo(..)</code> generator.</p> <h3 id=\"iterator-control\">Iterator Control</h3> <p>Earlier, we briefly introduced the concept that generators are controlled by iterators. Let&#39;s fully dig into that now.</p> <p>Recall the recursive <code>*foo(..)</code> from the previous section. Here&#39;s how we&#39;d run it:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\">function *<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(x)</span> </span>{     <span class=\"hljs-keyword\">if</span> (x &lt; <span class=\"hljs-number\">3</span>) {         x = <span class=\"hljs-function\">yield *<span class=\"hljs-title\">foo</span><span class=\"hljs-params\">( x + <span class=\"hljs-number\">1</span> )</span></span>;     }     <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; }  var it = foo( <span class=\"hljs-number\">1</span> ); it.next();                <span class=\"hljs-comment\">// { value: 24, done: true }</span> </code></pre> <p>In this case, the generator doesn&#39;t really ever pause, as there&#39;s no <code>yield ..</code> expression. Instead, <code>yield *</code> just keeps the current iteration step going via the recursive call. So, just one call to the iterator&#39;s <code>next()</code> function fully runs the generator.</p> <p>Now let&#39;s consider a generator that will have multiple steps and thus multiple produced values:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>; } </code></pre> <p>We already know we can consume an iterator, even one attached to a generator like <code>*foo()</code>, with a <code>for..of</code> loop:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> foo()) {     <span class=\"hljs-built_in\">console</span>.log( v ); } <span class=\"hljs-comment\">// 1 2 3</span> </code></pre> <p><strong>Note:</strong> The <code>for..of</code> loop requires an iterable. A generator function reference (like <code>foo</code>) by itself is not an iterable; you must execute it with <code>foo()</code> to get the iterator (which is also an iterable, as we explained earlier in this chapter). You could theoretically extend the <code>GeneratorPrototype</code> (the prototype of all generator functions) with a <code>Symbol.iterator</code> function that essentially just does <code>return this()</code>. That would make the <code>foo</code> reference itself an iterable, which means <code>for (var v of foo) { .. }</code> (notice no <code>()</code> on <code>foo</code>) will work.</p> <p>Let&#39;s instead iterate the generator manually:</p> <pre><code class=\"lang-js\">function *foo() {     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>; }  var it = foo();  it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> } it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> } it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">3</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> }  it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> undefined, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">true</span> } </code></pre> <p>If you look closely, there are three <code>yield</code> statements and four <code>next()</code> calls. That may seem like a strange mismatch. In fact, there will always be one more <code>next()</code> call than <code>yield</code> expression, assuming all are evaluated and the generator is fully run to completion.</p> <p>But if you look at it from the opposite perspective (inside-out instead of outside-in), the matching between <code>yield</code> and <code>next()</code> makes more sense.</p> <p>Recall that the <code>yield ..</code> expression will be completed by the value you resume the generator with. That means the argument you pass to <code>next(..)</code> completes whatever <code>yield ..</code> expression is currently paused waiting for a completion.</p> <p>Let&#39;s illustrate this perspective this way:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">var</span> z = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;     <span class=\"hljs-built_in\">console</span>.log( x, y, z ); } </code></pre> <p>In this snippet, each <code>yield ..</code> is sending a value out (<code>1</code>, <code>2</code>, <code>3</code>), but more directly, it&#39;s pausing the generator to wait for a value. In other words, it&#39;s almost like asking the question, &quot;What value should I use here? I&#39;ll wait to hear back.&quot;</p> <p>Now, here&#39;s how we control <code>*foo()</code> to start it up:</p> <pre><code class=\"lang-js\">var it = foo();  it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> } </code></pre> <p>That first <code>next()</code> call is starting up the generator from its initial paused state, and running it to the first <code>yield</code>. At the moment you call that first <code>next()</code>, there&#39;s no <code>yield ..</code> expression waiting for a completion. If you passed a value to that first <code>next()</code> call, it would currently just be thrown away, because no <code>yield</code> is waiting to receive such a value.</p> <p><strong>Note:</strong> An early proposal for the &quot;beyond ES6&quot; timeframe <em>would</em> let you access a value passed to an initial <code>next(..)</code> call via a separate meta property (see Chapter 7) inside the generator.</p> <p>Now, let&#39;s answer the currently pending question, &quot;What value should I assign to <code>x</code>?&quot; We&#39;ll answer it by sending a value to the <em>next</em> <code>next(..)</code> call:</p> <pre><code class=\"lang-js\">it.<span class=\"hljs-keyword\">next</span>( <span class=\"hljs-string\">\"foo\"</span> );        <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-keyword\">false</span> } </code></pre> <p>Now, the <code>x</code> will have the value <code>&quot;foo&quot;</code>, but we&#39;ve also asked a new question, &quot;What value should I assign to <code>y</code>?&quot; And we answer:</p> <pre><code class=\"lang-js\">it.<span class=\"hljs-keyword\">next</span>( <span class=\"hljs-string\">\"bar\"</span> );        <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">3</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-keyword\">false</span> } </code></pre> <p>Answer given, another question asked. Final answer:</p> <pre><code class=\"lang-js\">it.next( <span class=\"hljs-string\">\"baz\"</span> );        // <span class=\"hljs-string\">\"foo\"</span> <span class=\"hljs-string\">\"bar\"</span> <span class=\"hljs-string\">\"baz\"</span>                         // { value: undefined, <span class=\"hljs-keyword\">done</span>: <span class=\"hljs-literal\">true</span> } </code></pre> <p>Now it should be clearer how each <code>yield ..</code> &quot;question&quot; is answered by the <em>next</em> <code>next(..)</code> call, and so the &quot;extra&quot; <code>next()</code> call we observed is always just the initial one that starts everything going.</p> <p>Let&#39;s put all those steps together:</p> <pre><code class=\"lang-js\"><span class=\"hljs-built_in\">var</span> it = foo();  <span class=\"hljs-comment\">// start up the generator</span> it.<span class=\"hljs-built_in\">next</span>();                <span class=\"hljs-comment\">// { value: 1, done: false }</span>  <span class=\"hljs-comment\">// answer first question</span> it.<span class=\"hljs-built_in\">next</span>( <span class=\"hljs-string\">\"foo\"</span> );        <span class=\"hljs-comment\">// { value: 2, done: false }</span>  <span class=\"hljs-comment\">// answer second question</span> it.<span class=\"hljs-built_in\">next</span>( <span class=\"hljs-string\">\"bar\"</span> );        <span class=\"hljs-comment\">// { value: 3, done: false }</span>  <span class=\"hljs-comment\">// answer third question</span> it.<span class=\"hljs-built_in\">next</span>( <span class=\"hljs-string\">\"baz\"</span> );        <span class=\"hljs-comment\">// \"foo\" \"bar\" \"baz\"</span>                         <span class=\"hljs-comment\">// { value: undefined, done: true }</span> </code></pre> <p>You can think of a generator as a producer of values, in which case each iteration is simply producing a value to be consumed.</p> <p>But in a more general sense, perhaps it&#39;s appropriate to think of generators as controlled, progressive code execution, much like the <code>tasks</code> queue example from the earlier &quot;Custom Iterators&quot; section.</p> <p><strong>Note:</strong> That perspective is exactly the motivation for how we&#39;ll revisit generators in Chapter 4. Specifically, there&#39;s no reason that <code>next(..)</code> has to be called right away after the previous <code>next(..)</code> finishes. While the generator&#39;s inner execution context is paused, the rest of the program continues unblocked, including the ability for asynchronous actions to control when the generator is resumed.</p> <h3 id=\"early-completion\">Early Completion</h3> <p>As we covered earlier in this chapter, the iterator attached to a generator supports the optional <code>return(..)</code> and <code>throw(..)</code> methods. Both of them have the effect of aborting a paused generator immediately.</p> <p>Consider:</p> <pre><code class=\"lang-js\">function *foo() {     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>; }  var it = foo();  it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> }  it.<span class=\"hljs-keyword\">return</span>( <span class=\"hljs-number\">42</span> );        <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">42</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">true</span> }  it.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> undefined, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">true</span> } </code></pre> <p><code>return(x)</code> is kind of like forcing a <code>return x</code> to be processed at exactly that moment, such that you get the specified value right back. Once a generator is completed, either normally or early as shown, it no longer processes any code or returns any values.</p> <p>In addition to <code>return(..)</code> being callable manually, it&#39;s also called automatically at the end of iteration by any of the ES6 constructs that consume iterators, such as the <code>for..of</code> loop and the <code>...</code> spread operator.</p> <p>The purpose for this capability is so the generator can be notified if the controlling code is no longer going to iterate over it anymore, so that it can perhaps do any cleanup tasks (freeing up resources, resetting status, etc.). Identical to a normal function cleanup pattern, the main way to accomplish this is to use a <code>finally</code> clause:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">try</span> {         <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;         <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;         <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;     }     <span class=\"hljs-keyword\">finally</span> {         <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"cleanup!\"</span> );     } }  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> foo()) {     <span class=\"hljs-built_in\">console</span>.log( v ); } <span class=\"hljs-comment\">// 1 2 3</span> <span class=\"hljs-comment\">// cleanup!</span>  <span class=\"hljs-keyword\">var</span> it = foo();  it.next();                <span class=\"hljs-comment\">// { value: 1, done: false }</span> it.return( <span class=\"hljs-number\">42</span> );        <span class=\"hljs-comment\">// cleanup!</span>                         <span class=\"hljs-comment\">// { value: 42, done: true }</span> </code></pre> <p><strong>Warning:</strong> Do not put a <code>yield</code> statement inside the <code>finally</code> clause! It&#39;s valid and legal, but it&#39;s a really terrible idea. It acts in a sense as deferring the completion of the <code>return(..)</code> call you made, as any <code>yield ..</code> expressions in the <code>finally</code> clause are respected to pause and send messages; you don&#39;t immediately get a completed generator as expected. There&#39;s basically no good reason to opt in to that crazy <em>bad part</em>, so avoid doing so!</p> <p>In addition to the previous snippet showing how <code>return(..)</code> aborts the generator while still triggering the <code>finally</code> clause, it also demonstrates that a generator produces a whole new iterator each time it&#39;s called. In fact, you can use multiple iterators attached to the same generator concurrently:</p> <pre><code class=\"lang-js\">function *foo() {     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>; }  var it1 = foo(); it1.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> } it1.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> }  var it2 = foo(); it2.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> }  it1.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">3</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> }  it2.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">2</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> } it2.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> <span class=\"hljs-number\">3</span>, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">false</span> }  it2.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> undefined, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">true</span> } it1.<span class=\"hljs-keyword\">next</span>();                <span class=\"hljs-regexp\">//</span> { <span class=\"hljs-symbol\">value:</span> undefined, <span class=\"hljs-symbol\">done:</span> <span class=\"hljs-literal\">true</span> } </code></pre> <h4 id=\"early-abort\">Early Abort</h4> <p>Instead of calling <code>return(..)</code>, you can call <code>throw(..)</code>. Just like <code>return(x)</code> is essentially injecting a <code>return x</code> into the generator at its current pause point, calling <code>throw(x)</code> is essentially like injecting a <code>throw x</code> at the pause point.</p> <p>Other than the exception behavior (we cover what that means to <code>try</code> clauses in the next section), <code>throw(..)</code> produces the same sort of early completion that aborts the generator&#39;s run at its current pause point. For example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;     <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>; }  <span class=\"hljs-keyword\">var</span> it = foo();  it.next();                <span class=\"hljs-comment\">// { value: 1, done: false }</span>  <span class=\"hljs-keyword\">try</span> {     it.throw( <span class=\"hljs-string\">\"Oops!\"</span> ); } <span class=\"hljs-keyword\">catch</span> (err) {     <span class=\"hljs-built_in\">console</span>.log( err );    <span class=\"hljs-comment\">// Exception: Oops!</span> }  it.next();                <span class=\"hljs-comment\">// { value: undefined, done: true }</span> </code></pre> <p>Because <code>throw(..)</code> basically injects a <code>throw ..</code> in replacement of the <code>yield 1</code> line of the generator, and nothing handles this exception, it immediately propagates back out to the calling code, which handles it with a <code>try..catch</code>.</p> <p>Unlike <code>return(..)</code>, the iterator&#39;s <code>throw(..)</code> method is never called automatically.</p> <p>Of course, though not shown in the previous snippet, if a <code>try..finally</code> clause was waiting inside the generator when you call <code>throw(..)</code>, the <code>finally</code> clause would be given a chance to complete before the exception is propagated back to the calling code.</p> <h3 id=\"error-handling\">Error Handling</h3> <p>As we&#39;ve already hinted, error handling with generators can be expressed with <code>try..catch</code>, which works in both inbound and outbound directions:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">try</span> {         <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     }     <span class=\"hljs-keyword\">catch</span> (err) {         <span class=\"hljs-built_in\">console</span>.log( err );     }      <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">\"Hello!\"</span>; }  <span class=\"hljs-keyword\">var</span> it = foo();  it.next();                <span class=\"hljs-comment\">// { value: 1, done: false }</span>  <span class=\"hljs-keyword\">try</span> {     it.throw( <span class=\"hljs-string\">\"Hi!\"</span> );    <span class=\"hljs-comment\">// Hi!</span>                         <span class=\"hljs-comment\">// { value: 2, done: false }</span>     it.next();      <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"never gets here\"</span> ); } <span class=\"hljs-keyword\">catch</span> (err) {     <span class=\"hljs-built_in\">console</span>.log( err );    <span class=\"hljs-comment\">// Hello!</span> } </code></pre> <p>Errors can also propagate in both directions through <code>yield *</code> delegation:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">try</span> {         <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>;     }     <span class=\"hljs-keyword\">catch</span> (err) {         <span class=\"hljs-built_in\">console</span>.log( err );     }      <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>;      <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">\"foo: e2\"</span>; }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">try</span> {         <span class=\"hljs-keyword\">yield</span> *foo();          <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"never gets here\"</span> );     }     <span class=\"hljs-keyword\">catch</span> (err) {         <span class=\"hljs-built_in\">console</span>.log( err );     } }  <span class=\"hljs-keyword\">var</span> it = bar();  <span class=\"hljs-keyword\">try</span> {     it.next();            <span class=\"hljs-comment\">// { value: 1, done: false }</span>      it.throw( <span class=\"hljs-string\">\"e1\"</span> );    <span class=\"hljs-comment\">// e1</span>                         <span class=\"hljs-comment\">// { value: 2, done: false }</span>      it.next();            <span class=\"hljs-comment\">// foo: e2</span>                         <span class=\"hljs-comment\">// { value: undefined, done: true }</span> } <span class=\"hljs-keyword\">catch</span> (err) {     <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"never gets here\"</span> ); }  it.next();                <span class=\"hljs-comment\">// { value: undefined, done: true }</span> </code></pre> <p>When <code>*foo()</code> calls <code>yield 1</code>, the <code>1</code> value passes through <code>*bar()</code> untouched, as we&#39;ve already seen.</p> <p>But what&#39;s most interesting about this snippet is that when <code>*foo()</code> calls <code>throw &quot;foo: e2&quot;</code>, this error propagates to <code>*bar()</code> and is immediately caught by <code>*bar()</code>&#39;s <code>try..catch</code> block. The error doesn&#39;t pass through <code>*bar()</code> like the <code>1</code> value did.</p> <p><code>*bar()</code>&#39;s <code>catch</code> then does a normal output of <code>err</code> (<code>&quot;foo: e2&quot;</code>) and then <code>*bar()</code> finishes normally, which is why the <code>{ value: undefined, done: true }</code> iterator result comes back from <code>it.next()</code>.</p> <p>If <code>*bar()</code> didn&#39;t have a <code>try..catch</code> around the <code>yield *..</code> expression, the error would of course propagate all the way out, and on the way through it still would complete (abort) <code>*bar()</code>.</p> <h3 id=\"transpiling-a-generator\">Transpiling a Generator</h3> <p>Is it possible to represent a generator&#39;s capabilities prior to ES6? It turns out it is, and there are several great tools that do so, including most notably Facebook&#39;s Regenerator tool (<a href=\"https://facebook.github.io/regenerator/\">https://facebook.github.io/regenerator/</a>).</p> <p>But just to better understand generators, let&#39;s try our hand at manually converting. Basically, we&#39;re going to create a simple closure-based state machine.</p> <p>We&#39;ll keep our source generator really simple:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">42</span>;     <span class=\"hljs-built_in\">console</span>.log( x ); } </code></pre> <p>To start, we&#39;ll need a function called <code>foo()</code> that we can execute, which needs to return an iterator:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-comment\">// ..</span>      <span class=\"hljs-keyword\">return</span> {         next: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(v)</span> </span>{             <span class=\"hljs-comment\">// ..</span>         }          <span class=\"hljs-comment\">// we'll skip `return(..)` and `throw(..)`</span>     }; } </code></pre> <p>Now, we need some inner variable to keep track of where we are in the steps of our &quot;generator&quot;&#39;s logic. We&#39;ll call it <code>state</code>. There will be three states: <code>0</code> initially, <code>1</code> while waiting to fulfill the <code>yield</code> expression, and <code>2</code> once the generator is complete.</p> <p>Each time <code>next(..)</code> is called, we need to process the next step, and then increment <code>state</code>. For convenience, we&#39;ll put each step into a <code>case</code> clause of a <code>switch</code> statement, and we&#39;ll hold that in an inner function called <code>nextState(..)</code> that <code>next(..)</code> can call. Also, because <code>x</code> is a variable across the overall scope of the &quot;generator,&quot; it needs to live outside the <code>nextState(..)</code> function.</p> <p>Here it is all together (obviously somewhat simplified, to keep the conceptual illustration clearer):</p> <pre><code class=\"lang-js\">function foo() {     function nextState(v) {         switch (<span class=\"hljs-keyword\">state</span>) {             case <span class=\"hljs-number\">0</span>:                 <span class=\"hljs-keyword\">state</span>++;                  // the `yield` expression                 return <span class=\"hljs-number\">42</span>;             case <span class=\"hljs-number\">1</span>:                 <span class=\"hljs-keyword\">state</span>++;                  // `yield` expression fulfilled                 x = v;                 console.<span class=\"hljs-keyword\">log</span>( x );                  // the implicit `return`                 return undefined;              // no need <span class=\"hljs-keyword\">to</span> handle <span class=\"hljs-keyword\">state</span> `<span class=\"hljs-number\">2</span>`         }     }      var <span class=\"hljs-keyword\">state</span> = <span class=\"hljs-number\">0</span>, x;      return {         next: function(v) {             var ret = nextState( v );              return { value: ret, done: (<span class=\"hljs-keyword\">state</span> == <span class=\"hljs-number\">2</span>) };         }          // we'll <span class=\"hljs-keyword\">skip</span> `return(..)` and `throw(..)`     }; } </code></pre> <p>And finally, let&#39;s test our pre-ES6 &quot;generator&quot;:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-literal\">it</span> = foo();  <span class=\"hljs-literal\">it</span>.next();                <span class=\"hljs-pi\">// { value: 42, done: false }  it.next( 10 );            //</span> <span class=\"hljs-number\">10</span>                         // { <span class=\"hljs-attribute\">value</span>: <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-attribute\">done</span>: <span class=\"hljs-literal\">true</span> } </code></pre> <p>Not bad, huh? Hopefully this exercise solidifies in your mind that generators are actually just simple syntax for state machine logic. That makes them widely applicable.</p> <h3 id=\"generator-uses\">Generator Uses</h3> <p>So, now that we much more deeply understand how generators work, what are they useful for?</p> <p>We&#39;ve seen two major patterns:</p> <ul> <li><p><em>Producing a series of values:</em> This usage can be simple (e.g., random strings or incremented numbers), or it can represent more structured data access (e.g., iterating over rows returned from a database query).</p> <p> Either way, we use the iterator to control a generator so that some logic can be invoked for each call to <code>next(..)</code>. Normal iterators on data structures merely pull values without any controlling logic.</p> </li> <li><p><em>Queue of tasks to perform serially:</em> This usage often represents flow control for the steps in an algorithm, where each step requires retrieval of data from some external source. The fulfillment of each piece of data may be immediate, or may be asynchronously delayed.</p> <p> From the perspective of the code inside the generator, the details of sync or async at a <code>yield</code> point are entirely opaque. Moreover, these details are intentionally abstracted away, such as not to obscure the natural sequential expression of steps with such implementation complications. Abstraction also means the implementations can be swapped/refactored often without touching the code in the generator at all.</p> </li> </ul> <p>When generators are viewed in light of these uses, they become a lot more than just a different or nicer syntax for a manual state machine. They are a powerful abstraction tool for organizing and controlling orderly production and consumption of data.</p> <h2 id=\"modules\">Modules</h2> <p>I don&#39;t think it&#39;s an exaggeration to suggest that the single most important code organization pattern in all of JavaScript is, and always has been, the module. For myself, and I think for a large cross-section of the community, the module pattern drives the vast majority of code.</p> <h3 id=\"the-old-way\">The Old Way</h3> <p>The traditional module pattern is based on an outer function with inner variables and functions, and a returned &quot;public API&quot; with methods that have closure over the inner data and capabilities. It&#39;s often expressed like this:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Hello</span>(<span class=\"hljs-params\">name</span>) </span>{     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">greeting</span>(<span class=\"hljs-params\"></span>) </span>{         <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\"!\"</span> );     }      <span class=\"hljs-comment\">// public API</span>     <span class=\"hljs-keyword\">return</span> {         greeting: greeting     }; }  <span class=\"hljs-keyword\">var</span> me = Hello( <span class=\"hljs-string\">\"Kyle\"</span> ); me.greeting();            <span class=\"hljs-comment\">// Hello Kyle!</span> </code></pre> <p>This <code>Hello(..)</code> module can produce multiple instances by being called subsequent times. Sometimes, a module is only called for as a singleton (i.e., it just needs one instance), in which case a slight variation on the previous snippet, using an IIFE, is common:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> me = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Hello</span>(<span class=\"hljs-params\">name</span>)</span>{     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">greeting</span>(<span class=\"hljs-params\"></span>) </span>{         <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"Hello \"</span> + name + <span class=\"hljs-string\">\"!\"</span> );     }      <span class=\"hljs-comment\">// public API</span>     <span class=\"hljs-keyword\">return</span> {         greeting: greeting     }; })( <span class=\"hljs-string\">\"Kyle\"</span> );  me.greeting();            <span class=\"hljs-comment\">// Hello Kyle!</span> </code></pre> <p>This pattern is tried and tested. It&#39;s also flexible enough to have a wide assortment of variations for a number of different scenarios.</p> <p>One of the most common is the Asynchronous Module Definition (AMD), and another is the Universal Module Definition (UMD). We won&#39;t cover the particulars of these patterns and techniques here, but they&#39;re explained extensively in many places online.</p> <h3 id=\"moving-forward\">Moving Forward</h3> <p>As of ES6, we no longer need to rely on the enclosing function and closure to provide us with module support. ES6 modules have first class syntactic and functional support.</p> <p>Before we get into the specific syntax, it&#39;s important to understand some fairly significant conceptual differences with ES6 modules compared to how you may have dealt with modules in the past:</p> <ul> <li><p>ES6 uses file-based modules, meaning one module per file. At this time, there is no standardized way of combining multiple modules into a single file.</p> <p> That means that if you are going to load ES6 modules directly into a browser web application, you will be loading them individually, not as a large bundle in a single file as has been common in performance optimization efforts.</p> <p> It&#39;s expected that the contemporaneous advent of HTTP/2 will significantly mitigate any such performance concerns, as it operates on a persistent socket connection and thus can very efficiently load many smaller files in parallel and interleaved with one another.</p> </li> <li><p>The API of an ES6 module is static. That is, you define statically what all the top-level exports are on your module&#39;s public API, and those cannot be amended later.</p> <p> Some uses are accustomed to being able to provide dynamic API definitions, where methods can be added/removed/replaced in response to runtime conditions. Either these uses will have to change to fit with ES6 static APIs, or they will have to restrain the dynamic changes to properties/methods of a second-level object.</p> </li> <li>ES6 modules are singletons. That is, there&#39;s only one instance of the module, which maintains its state. Every time you import that module into another module, you get a reference to the one centralized instance. If you want to be able to produce multiple module instances, your module will need to provide some sort of factory to do it.</li> <li><p>The properties and methods you expose on a module&#39;s public API are not just normal assignments of values or references. They are actual bindings (almost like pointers) to the identifiers in your inner module definition.</p> <p> In pre-ES6 modules, if you put a property on your public API that holds a primitive value like a number or string, that property assignment was by value-copy, and any internal update of a corresponding variable would be separate and not affect the public copy on the API object.</p> <p> With ES6, exporting a local private variable, even if it currently holds a primitive string/number/etc, exports a binding to the variable. If the module changes the  variable&#39;s value, the external import binding now resolves to that new value.</p> </li> <li><p>Importing a module is the same thing as statically requesting it to load (if it hasn&#39;t already). If you&#39;re in a browser, that implies a blocking load over the network. If you&#39;re on a server (i.e., Node.js), it&#39;s a blocking load from the filesystem.</p> <p> However, don&#39;t panic about the performance implications. Because ES6 modules have static definitions, the import requirements can be statically scanned, and loads will happen preemptively, even before you&#39;ve used the module.</p> <p> ES6 doesn&#39;t actually specify or handle the mechanics of how these load requests work. There&#39;s a separate notion of a Module Loader, where each hosting environment (browser, Node.js, etc.) provides a default Loader appropriate to the environment. The importing of a module uses a string value to represent where to get the module (URL, file path, etc.), but this value is opaque in your program and only meaningful to the Loader itself.</p> <p> You can define your own custom Loader if you want more fine-grained control than the default Loader affords -- which is basically none, as it&#39;s totally hidden from your program&#39;s code.</p> </li> </ul> <p>As you can see, ES6 modules will serve the overall use case of organizing code with encapsulation, controlling public APIs, and referencing dependency imports. But they have a very particular way of doing so, and that may or may not fit very closely with how you&#39;ve already been doing modules for years.</p> <h4 id=\"commonjs\">CommonJS</h4> <p>There&#39;s a similar, but not fully compatible, module syntax called CommonJS, which is familiar to those in the Node.js ecosystem.</p> <p>For lack of a more tactful way to say this, in the long run, ES6 modules essentially are bound to supercede all previous formats and standards for modules, even CommonJS, as they are built on syntactic support in the language. This will, in time, inevitably win out as the superior approach, if for no other reason than ubiquity.</p> <p>We face a fairly long road to get to that point, though. There are literally hundreds of thousands of CommonJS style modules in the server-side JavaScript world, and 10 times that many modules of varying format standards (UMD, AMD, ad hoc) in the browser world. It will take many years for the transitions to make any significant progress.</p> <p>In the interim, module transpilers/converters will be an absolute necessity. You might as well just get used to that new reality. Whether you author in regular modules, AMD, UMD, CommonJS, or ES6, these tools will have to parse and convert to a format that is suitable for whatever environment your code will run in.</p> <p>For Node.js, that probably means (for now) that the target is CommonJS. For the browser, it&#39;s probably UMD or AMD. Expect lots of flux on this over the next few years as these tools mature and best practices emerge.</p> <p>From here on out, my best advice on modules is this: whatever format you&#39;ve been religiously attached to with strong affinity, also develop an appreciation for and understanding of ES6 modules, such as they are, and let your other module tendencies fade. They <em>are</em> the future of modules in JS, even if that reality is a bit of a ways off.</p> <h3 id=\"the-new-way\">The New Way</h3> <p>The two main new keywords that enable ES6 classes are <code>import</code> and <code>export</code>. There&#39;s lots of nuance to the syntax, so let&#39;s take a deeper look.</p> <p><strong>Warning:</strong> An important detail that&#39;s easy to overlook: both <code>import</code> and <code>export</code> must always appear in the top-level scope of their respective usage. For example, you cannot put either an <code>import</code> or <code>export</code> inside an <code>if</code> conditional; they must appear outside of all blocks and functions.</p> <h4 id=\"-export-ing-api-members\"><code>export</code>ing API Members</h4> <p>The <code>export</code> keyword is either put in front of a declaration, or used as an operator (of sorts) with a special list of bindings to export. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">export</span> function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-comment\">// ..</span> }  <span class=\"hljs-keyword\">export</span> var awesome = <span class=\"hljs-number\">42</span>;  var bar = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]; <span class=\"hljs-keyword\">export</span> { bar }; </code></pre> <p>Another way of expressing the same exports:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\">function <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-comment\">// ..</span> }  var awesome = <span class=\"hljs-number\">42</span>; var bar = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];  <span class=\"hljs-keyword\">export</span> { foo, awesome, bar }; </code></pre> <p>These are all called <em>named exports</em>, as you are in effect exporting the name bindings of the variables/functions/etc.</p> <p>Anything you don&#39;t <em>label</em> with <code>export</code> stays private inside the scope of the module. That is, although something like <code>var bar = ..</code> looks like it&#39;s declaring at the top-level global scope, the top-level scope is actually the module itself; there is no global scope in modules.</p> <p><strong>Note:</strong> Modules <em>do</em> still have access to <code>window</code> and all the &quot;globals&quot; that hang off it, just not as lexical top-level scope. However, you really should stay away from the globals in your modules if at all possible.</p> <p>You can also &quot;rename&quot; (aka alias) a module member during named export:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. }  <span class=\"hljs-keyword\">export</span> { foo <span class=\"hljs-keyword\">as</span> bar }; </code></pre> <p>When this module is imported, only the <code>bar</code> member name is available to import; <code>foo</code> stays hidden inside the module.</p> <p>Module exports are not just normal assignments of values or references, as you&#39;re accustomed to with the <code>=</code> assignment operator. Actually, when you export something, you&#39;re exporting a binding (kinda like a pointer) to that thing (variable, etc.).</p> <p>Within your module, if you change the value of a variable you already exported a binding to, even if it&#39;s already been imported (see the next section), the imported binding will resolve to the current (updated) value.</p> <p>Consider:</p> <pre><code class=\"lang-js\">var awesome = <span class=\"hljs-number\">42</span>; <span class=\"hljs-keyword\">export</span> { awesome };  <span class=\"hljs-comment\">// later</span> awesome = <span class=\"hljs-number\">100</span>; </code></pre> <p>When this module is imported, regardless of whether that&#39;s before or after the <code>awesome = 100</code> setting, once that assignment has happened, the imported binding resolves to the <code>100</code> value, not <code>42</code>.</p> <p>That&#39;s because the binding is, in essence, a reference to, or a pointer to, the <code>awesome</code> variable itself, rather than a copy of its value. This is a mostly unprecedented concept for JS introduced with ES6 module bindings.</p> <p>Though you can clearly use <code>export</code> multiple times inside a module&#39;s definition, ES6 definitely prefers the approach that a module has a single export, which is known as a <em>default export</em>. In the words of some members of the TC39 committee, you&#39;re &quot;rewarded with simpler <code>import</code> syntax&quot; if you follow that pattern, and conversely &quot;penalized&quot; with more verbose syntax if you don&#39;t.</p> <p>A default export sets a particular exported binding to be the default when importing the module. The name of the binding is literally <code>default</code>. As you&#39;ll see later, when importing module bindings you can also rename them, as you commonly will with a default export.</p> <p>There can only be one <code>default</code> per module definition. We&#39;ll cover <code>import</code> in the next section, and you&#39;ll see how the <code>import</code> syntax is more concise if the module has a default export.</p> <p>There&#39;s a subtle nuance to default export syntax that you should pay close attention to. Compare these two snippets:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">..</span>) </span>{     <span class=\"hljs-comment\">// ..</span> }  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> foo; </code></pre> <p>And this one:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">..</span>) </span>{     <span class=\"hljs-comment\">// ..</span> }  <span class=\"hljs-keyword\">export</span> { foo <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">default</span> }; </code></pre> <p>In the first snippet, you are exporting a binding to the function expression value at that moment, <em>not</em> to the identifier <code>foo</code>. In other words, <code>export default ..</code> takes an expression. If you later assign <code>foo</code> to a different value inside your module, the module import still reveals the function originally exported, not the new value.</p> <p>By the way, the first snippet could also have been written as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">..</span>) </span>{     <span class=\"hljs-comment\">// ..</span> } </code></pre> <p><strong>Warning:</strong> Although the <code>function foo..</code> part here is technically a function expression, for the purposes of the internal scope of the module, it&#39;s treated like a function declaration, in that the <code>foo</code> name is bound in the module&#39;s top-level scope (often called &quot;hoisting&quot;). The same is true for <code>export default class Foo..</code>. However, while you <em>can</em> do <code>export var foo = ..</code>, you currently cannot do <code>export default var foo = ..</code> (or <code>let</code> or <code>const</code>), in a frustrating case of inconsistency. At the time of this writing, there&#39;s already discussion of adding that capability in soon, post-ES6, for consistency sake.</p> <p>Recall the second snippet again:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">..</span>) </span>{     <span class=\"hljs-comment\">// ..</span> }  <span class=\"hljs-keyword\">export</span> { foo <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">default</span> }; </code></pre> <p>In this version of the module export, the default export binding is actually to the <code>foo</code> identifier rather than its value, so you get the previously described binding behavior (i.e., if you later change <code>foo</code>&#39;s value, the value seen on the import side will also be updated).</p> <p>Be very careful of this subtle gotcha in default export syntax, especially if your logic calls for export values to be updated. If you never plan to update a default export&#39;s value, <code>export default ..</code> is fine. If you do plan to update the value, you must use <code>export { .. as default }</code>. Either way, make sure to comment your code to explain your intent!</p> <p>Because there can only be one <code>default</code> per module, you may be tempted to design your module with one default export of an object with all your API methods on it, such as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-tag\">export</span> <span class=\"hljs-tag\">default</span> {     <span class=\"hljs-tag\">foo</span>() { .. },     <span class=\"hljs-tag\">bar</span>() { .. },     .. }; </code></pre> <p>That pattern seems to map closely to how a lot of developers have already structured their pre-ES6 modules, so it seems like a natural approach. Unfortunately, it has some downsides and is officially discouraged.</p> <p>In particular, the JS engine cannot statically analyze the contents of a plain object, which means it cannot do some optimizations for static <code>import</code> performance. The advantage of having each member individually and explicitly exported is that the engine <em>can</em> do the static analysis and optimization.</p> <p>If your API has more than one member already, it seems like these principles -- one default export per module, and all API members as named exports -- are in conflict, doesn&#39;t it? But you <em>can</em> have a single default export as well as other named exports; they are not mutually exclusive.</p> <p>So, instead of this (discouraged) pattern:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. }  foo.bar = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ .. }; foo.baz = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ .. }; </code></pre> <p>You can do:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. }  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span>(<span class=\"hljs-params\"></span>) </span>{ .. } </code></pre> <p><strong>Note:</strong> In this previous snippet, I used the name <code>foo</code> for the function that <code>default</code> labels. That <code>foo</code> name, however, is ignored for the purposes of export -- <code>default</code> is actually the exported name. When you import this default binding, you can give it whatever name you want, as you&#39;ll see in the next section.</p> <p>Alternatively, some will prefer:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span>(<span class=\"hljs-params\"></span>) </span>{ .. }  <span class=\"hljs-keyword\">export</span> { foo <span class=\"hljs-keyword\">as</span> <span class=\"hljs-keyword\">default</span>, bar, baz, .. }; </code></pre> <p>The effects of mixing default and named exports will be more clear when we cover <code>import</code> shortly. But essentially it means that the most concise default import form would only retrieve the <code>foo()</code> function. The user could additionally manually list <code>bar</code> and <code>baz</code> as named imports, if they want them.</p> <p>You can probably imagine how tedious that&#39;s going to be for consumers of your module if you have lots of named export bindings. There is a wildcard import form where you import all of a module&#39;s exports within a single namespace object, but there&#39;s no way to wildcard import to top-level bindings.</p> <p>Again, the ES6 module mechanism is intentionally designed to discourage modules with lots of exports; relatively speaking, it&#39;s desired that such approaches be a little more difficult, as a sort of social engineering to encourage simple module design in favor of large/complex module design.</p> <p>I would probably recommend you not mix default export with named exports, especially if you have a large API and refactoring to separate modules isn&#39;t practical or desired. In that case, just use all named exports, and document that consumers of your module should probably use the <code>import * as ..</code> (namespace import, discussed in the next section) approach to bring the whole API in at once on a single namespace.</p> <p>We mentioned this earlier, but let&#39;s come back to it in more detail. Other than the <code>export default ...</code> form that exports an expression value binding, all other export forms are exporting bindings to local identifiers. For those bindings, if you change the value of a variable inside a module after exporting, the external imported binding will access the updated value:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> foo = <span class=\"hljs-number\">42</span>; <span class=\"hljs-literal\">export</span> { foo <span class=\"hljs-literal\">as</span> <span class=\"hljs-keyword\">default</span> };  <span class=\"hljs-literal\">export</span> <span class=\"hljs-keyword\">var</span> bar = <span class=\"hljs-string\">\"hello world\"</span>;  foo = <span class=\"hljs-number\">10</span>; bar = <span class=\"hljs-string\">\"cool\"</span>; </code></pre> <p>When you import this module, the <code>default</code> and <code>bar</code> exports will be bound to the local variables <code>foo</code> and <code>bar</code>, meaning they will reveal the updated <code>10</code> and <code>&quot;cool&quot;</code> values. The values at time of export are irrelevant. The values at time of import are irrelevant. The bindings are live links, so all that matters is what the current value is when you access the binding.</p> <p><strong>Warning:</strong> Two-way bindings are not allowed. If you import a <code>foo</code> from a module, and try to change the value of your imported <code>foo</code> variable, an error will be thrown! We&#39;ll revisit that in the next section.</p> <p>You can also re-export another module&#39;s exports, such as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> { foo, bar } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"baz\"</span>; <span class=\"hljs-keyword\">export</span> { foo <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">FOO</span>, bar <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">BAR</span> } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"baz\"</span>; <span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"baz\"</span>; </code></pre> <p>Those forms are similar to just first importing from the <code>&quot;baz&quot;</code> module then listing its members explicitly for export from your module. However, in these forms, the members of the <code>&quot;baz&quot;</code> module are never imported to your module&#39;s local scope; they sort of pass through untouched.</p> <h4 id=\"-import-ing-api-members\"><code>import</code>ing API Members</h4> <p>To import a module, unsurprisingly you use the <code>import</code> statement. Just as <code>export</code> has several nuanced variations, so does <code>import</code>, so spend plenty of time considering the following issues and experimenting with your options.</p> <p>If you want to import certain specific named members of a module&#39;s API into your top-level scope, you use this syntax:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { foo, bar, baz } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>; </code></pre> <p><strong>Warning:</strong> The <code>{ .. }</code> syntax here may look like an object literal, or even an object destructuring syntax. However, its form is special just for modules, so be careful not to confuse it with other <code>{ .. }</code> patterns elsewhere.</p> <p>The <code>&quot;foo&quot;</code> string is called a <em>module specifier</em>. Because the whole goal is statically analyzable syntax, the module specifier must be a string literal; it cannot be a variable holding the string value.</p> <p>From the perspective of your ES6 code and the JS engine itself, the contents of this string literal are completely opaque and meaningless. The module loader will interpret this string as an instruction of where to find the desired module, either as a URL path or a local filesystem path.</p> <p>The <code>foo</code>, <code>bar</code>, and <code>baz</code> identifiers listed must match named exports on the module&#39;s API (static analysis and error assertion apply). They are bound as top-level identifiers in your current scope:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>;  foo(); </code></pre> <p>You can rename the bound identifiers imported, as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> { foo <span class=\"hljs-keyword\">as</span> theFooFunc } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>;  theFooFunc(); </code></pre> <p>If the module has just a default export that you want to import and bind to an identifier, you can opt to skip the <code>{ .. }</code> surrounding syntax for that binding. The <code>import</code> in this preferred case gets the nicest and most concise of the <code>import</code> syntax forms:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>;  <span class=\"hljs-comment\">// or:</span> <span class=\"hljs-keyword\">import</span> { default <span class=\"hljs-keyword\">as</span> foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>; </code></pre> <p><strong>Note:</strong> As explained in the previous section, the <code>default</code> keyword in a module&#39;s <code>export</code> specifies a named export where the name is actually <code>default</code>, as is illustrated by the second more verbose syntax option. The renaming from <code>default</code> to, in this case, <code>foo</code>, is explicit in the latter syntax and is identical yet implicit in the former syntax.</p> <p>You can also import a default export along with other named exports, if the module has such a definition. Recall this module definition from earlier:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. }  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span>(<span class=\"hljs-params\"></span>) </span>{ .. } </code></pre> <p>To import that module&#39;s default export and its two named exports:</p> <pre><code class=\"lang-js\"><span class=\"hljs-label\">import</span> FOOFN, { <span class=\"hljs-keyword\">bar, </span><span class=\"hljs-keyword\">baz </span>as <span class=\"hljs-keyword\">BAZ </span>} from <span class=\"hljs-string\">\"foo\"</span><span class=\"hljs-comment\">;</span>  <span class=\"hljs-label\">FOOFN</span>()<span class=\"hljs-comment\">;</span> <span class=\"hljs-keyword\">bar(); </span><span class=\"hljs-keyword\">BAZ();</span> </code></pre> <p>The strongly suggested approach from ES6&#39;s module philosophy is that you only import the specific bindings from a module that you need. If a module provides 10 API methods, but you only need two of them, some believe it wasteful to bring in the entire set of API bindings.</p> <p>One benefit, besides code being more explicit, is that narrow imports make static analysis and error detection (accidentally using the wrong binding name, for instance) more robust.</p> <p>Of course, that&#39;s just the standard position influenced by ES6 design philosophy; there&#39;s nothing that requires adherence to that approach.</p> <p>Many developers would be quick to point out that such approaches can be more tedious, requiring you to regularly revisit and update your <code>import</code> statement(s) each time you realize you need something else from a module. The trade-off is in exchange for convenience.</p> <p>In that light, the preference might be to import everything from the module into a single namespace, rather than importing individual members, each directly into the scope. Fortunately, the <code>import</code> statement has a syntax variation that can support this style of module consumption, called <em>namespace import</em>.</p> <p>Consider a <code>&quot;foo&quot;</code> module exported as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-number\">42</span>; <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span>(<span class=\"hljs-params\"></span>) </span>{ .. } </code></pre> <p>You can import that entire API to a single module namespace binding:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>;  foo.bar(); foo.x;            <span class=\"hljs-comment\">// 42</span> foo.baz(); </code></pre> <p><strong>Note:</strong> The <code>* as ..</code> clause requires the <code>*</code> wildcard. In other words, you cannot do something like <code>import { bar, x } as foo from &quot;foo&quot;</code> to bring in only part of the API but still bind to the <code>foo</code> namespace. I would have liked something like that, but for ES6 it&#39;s all or nothing with the namespace import.</p> <p>If the module you&#39;re importing with <code>* as ..</code> has a default export, it is named <code>default</code> in the namespace specified. You can additionaly name the default import outside of the namespace binding, as a top-level identifier. Consider a <code>&quot;world&quot;</code> module exported as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\"></span>) </span>{ .. } <span class=\"hljs-keyword\">export</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span>(<span class=\"hljs-params\"></span>) </span>{ .. } </code></pre> <p>And this <code>import</code>:</p> <pre><code class=\"lang-js\">import foofn, * <span class=\"hljs-keyword\">as</span> hello from <span class=\"hljs-string\">\"world\"</span>;  foofn<span class=\"hljs-literal\">()</span>; hello.default<span class=\"hljs-literal\">()</span>; hello.bar<span class=\"hljs-literal\">()</span>; hello.baz<span class=\"hljs-literal\">()</span>; </code></pre> <p>While this syntax is valid, it can be rather confusing that one method of the module (the default export) is bound at the top-level of your scope, whereas the rest of the named exports (and one called <code>default</code>) are bound as properties on a differently named (<code>hello</code>) identifier namespace.</p> <p>As I mentioned earlier, my suggestion would be to avoid designing your module exports in this way, to reduce the chances that your module&#39;s users will suffer these strange quirks.</p> <p>All imported bindings are immutable and/or read-only. Consider the previous import; all of these subsequent assignment attempts will throw <code>TypeError</code>s:</p> <pre><code class=\"lang-js\">import foofn, * as hello from <span class=\"hljs-string\">\"world\"</span>;  foofn = <span class=\"hljs-number\">42</span>;            <span class=\"hljs-comment\">// (runtime) TypeError!</span> hello.<span class=\"hljs-keyword\">default</span> = <span class=\"hljs-number\">42</span>;    <span class=\"hljs-comment\">// (runtime) TypeError!</span> hello.bar = <span class=\"hljs-number\">42</span>;        <span class=\"hljs-comment\">// (runtime) TypeError!</span> hello.baz = <span class=\"hljs-number\">42</span>;        <span class=\"hljs-comment\">// (runtime) TypeError!</span> </code></pre> <p>Recall earlier in the &quot;<code>export</code>ing API Members&quot; section that we talked about how the <code>bar</code> and <code>baz</code> bindings are bound to the actual identifiers inside the <code>&quot;world&quot;</code> module. That means if the module changes those values, <code>hello.bar</code> and <code>hello.baz</code> now reference the updated values.</p> <p>But the immutable/read-only nature of your local imported bindings enforces that you cannot change them from the imported bindings, hence the <code>TypeError</code>s. That&#39;s pretty important, because without those protections, your changes would end up affecting all other consumers of the module (remember: singleton), which could create some very surprising side effects!</p> <p>Moreover, though a module <em>can</em> change its API members from the inside, you should be very cautious of intentionally designing your modules in that fashion. ES6 modules are <em>intended</em> to be static, so deviations from that principle should be rare and should be carefully and verbosely documented.</p> <p><strong>Warning:</strong> There are module design philosophies where you actually intend to let a consumer change the value of a property on your API, or module APIs are designed to be &quot;extended&quot; by having other &quot;plug-ins&quot; add to the API namespace. As we just asserted, ES6 module APIs should be thought of and designed as static and unchangeable, which strongly restricts and discourages these alternative module design patterns. You can get around these limitations by exporting a plain object, which of course can then be changed at will. But be careful and think twice before going down that road.</p> <p>Declarations that occur as a result of an <code>import</code> are &quot;hoisted&quot; (see the <em>Scope &amp; Closures</em> title of this series). Consider:</p> <pre><code class=\"lang-js\">foo();  <span class=\"hljs-keyword\">import</span> { foo } <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>; </code></pre> <p><code>foo()</code> can run because not only did the static resolution of the <code>import ..</code> statement figure out what <code>foo</code> is during compilation, but it also &quot;hoisted&quot; the declaration to the top of the module&#39;s scope, thus making it available throughout the module.</p> <p>Finally, the most basic form of the <code>import</code> looks like this:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">\"foo\"</span>; </code></pre> <p>This form does not actually import any of the module&#39;s bindings into your scope. It loads (if not already loaded), compiles (if not already compiled), and evaluates (if not already run) the <code>&quot;foo&quot;</code> module.</p> <p>In general, that sort of import is probably not going to be terribly useful. There may be niche cases where a module&#39;s definition has side effects (such as assigning things to the <code>window</code>/global object). You could also envision using <code>import &quot;foo&quot;</code> as a sort of preload for a module that may be needed later.</p> <h3 id=\"circular-module-dependency\">Circular Module Dependency</h3> <p>A imports B. B imports A. How does this actually work?</p> <p>I&#39;ll state off the bat that designing systems with intentional circular dependency is generally something I try to avoid. That having been said, I recognize there are reasons people do this and it can solve some sticky design situations.</p> <p>Let&#39;s consider how ES6 handles this. First, module <code>&quot;A&quot;</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> bar <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"B\"</span>;  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">10</span>) <span class=\"hljs-keyword\">return</span> bar( x - <span class=\"hljs-number\">1</span> );     <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; } </code></pre> <p>Now, module <code>&quot;B&quot;</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"A\"</span>;  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">y</span>) </span>{     <span class=\"hljs-keyword\">if</span> (y &gt; <span class=\"hljs-number\">5</span>) <span class=\"hljs-keyword\">return</span> foo( y / <span class=\"hljs-number\">2</span> );     <span class=\"hljs-keyword\">return</span> y * <span class=\"hljs-number\">3</span>; } </code></pre> <p>These two functions, <code>foo(..)</code> and <code>bar(..)</code>, would work as standard function declarations if they were in the same scope, because the declarations are &quot;hoisted&quot; to the whole scope and thus available to each other regardless of authoring order.</p> <p>With modules, you have declarations in entirely different scopes, so ES6 has to do extra work to help make these circular references work.</p> <p>In a rough conceptual sense, this is how circular <code>import</code> dependencies are validated and resolved:</p> <ul> <li>If the <code>&quot;A&quot;</code> module is loaded first, the first step is to scan the file and analyze all the exports, so it can register all those bindings available for import. Then it processes the <code>import .. from &quot;B&quot;</code>, which signals that it needs to go fetch <code>&quot;B&quot;</code>.</li> <li>Once the engine loads <code>&quot;B&quot;</code>, it does the same analysis of its export bindings. When it sees the <code>import .. from &quot;A&quot;</code>, it knows the API of <code>&quot;A&quot;</code> already, so it can verify the <code>import</code> is valid. Now that it knows the <code>&quot;B&quot;</code> API, it can also validate the <code>import .. from &quot;B&quot;</code> in the waiting <code>&quot;A&quot;</code> module.</li> </ul> <p>In essence, the mutual imports, along with the static verification that&#39;s done to validate both <code>import</code> statements, virtually composes the two separate module scopes (via the bindings), such that <code>foo(..)</code> can call <code>bar(..)</code> and vice versa. This is symmetric to if they had originally been declared in the same scope.</p> <p>Now let&#39;s try using the two modules together. First, we&#39;ll try <code>foo(..)</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>; foo( <span class=\"hljs-number\">25</span> );                <span class=\"hljs-comment\">// 11</span> </code></pre> <p>Or we can try <code>bar(..)</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> bar <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bar\"</span>; bar( <span class=\"hljs-number\">25</span> );                <span class=\"hljs-comment\">// 11.5</span> </code></pre> <p>By the time either the <code>foo(25)</code> or <code>bar(25)</code> calls are executed, all the analysis/compilation of all modules has completed. That means <code>foo(..)</code> internally knows directly about <code>bar(..)</code> and <code>bar(..)</code> internally knows directly about <code>foo(..)</code>.</p> <p>If all we need is to interact with <code>foo(..)</code>, then we only need to import the <code>&quot;foo&quot;</code> module. Likewise with <code>bar(..)</code> and the <code>&quot;bar&quot;</code> module.</p> <p>Of course, we <em>can</em> import and use both of them if we want to:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">import</span> foo <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"foo\"</span>; <span class=\"hljs-keyword\">import</span> bar <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">\"bar\"</span>;  foo( <span class=\"hljs-number\">25</span> );                <span class=\"hljs-comment\">// 11</span> bar( <span class=\"hljs-number\">25</span> );                <span class=\"hljs-comment\">// 11.5</span> </code></pre> <p>The static loading semantics of the <code>import</code> statement mean that a <code>&quot;foo&quot;</code> and <code>&quot;bar&quot;</code> that mutually depend on each other via <code>import</code> will ensure that both are loaded, parsed, and compiled before either of them runs. So their circular dependency is statically resolved and this works as you&#39;d expect.</p> <h3 id=\"module-loading\">Module Loading</h3> <p>We asserted at the beginning of this &quot;Modules&quot; section that the <code>import</code> statement uses a separate mechanism, provided by the hosting environment (browser, Node.js, etc.), to actually resolve the module specifier string into some useful instruction for finding and loading the desired module. That mechanism is the system <em>Module Loader</em>.</p> <p>The default module loader provided by the environment will interpret a module specifier as a URL if in the browser, and (generally) as a local filesystem path if on a server such as Node.js. The default behavior is to assume the loaded file is authored in the ES6 standard module format.</p> <p>Moreover, you will be able to load a module into the browser via an HTML tag, similar to how current script programs are loaded. At the time of this writing, it&#39;s not fully clear if this tag will be <code>&lt;script type=&quot;module&quot;&gt;</code> or <code>&lt;module&gt;</code>. ES6 doesn&#39;t control that decision, but discussions in the appropriate standards bodies are already well along in parallel of ES6.</p> <p>Whatever the tag looks like, you can be sure that under the covers it will use the default loader (or a customized one you&#39;ve pre-specified, as we&#39;ll discuss in the next section).</p> <p>Just like the tag you&#39;ll use in markup, the module loader itself is not specified by ES6. It is a separate, parallel standard (<a href=\"http://whatwg.github.io/loader/\">http://whatwg.github.io/loader/</a>) controlled currently by the WHATWG browser standards group.</p> <p>At the time of this writing, the following discussions reflect an early pass at the API design, and things are likely to change.</p> <h4 id=\"loading-modules-outside-of-modules\">Loading Modules Outside of Modules</h4> <p>One use for interacting directly with the module loader is if a non-module needs to load a module. Consider:</p> <pre><code class=\"lang-js\">// normal script loaded in browser via `<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">script</span>&gt;</span><span class=\"actionscript\">`, <span class=\"hljs-comment\">// `import` is illegal here</span>  Reflect.Loader.<span class=\"hljs-keyword\">import</span>( <span class=\"hljs-string\">\"foo\"</span> ) <span class=\"hljs-comment\">// returns a promise for `\"foo\"`</span> .then( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(foo)</span></span>{     foo.bar(); } );</span> </code></pre> <p>The <code>Reflect.Loader.import(..)</code> utility imports the entire module onto the named parameter (as a namespace), just like the <code>import * as foo ..</code> namespace import we discussed earlier.</p> <p><strong>Note:</strong> The <code>Reflect.Loader.import(..)</code> utility returns a promise that is fulfilled once the module is ready. To import multiple modules, you can compose promises from multiple <code>Reflect.Loader.import(..)</code> calls using <code>Promise.all([ .. ])</code>. For more information about Promises, see &quot;Promises&quot; in Chapter 4.</p> <p>You can also use <code>Reflect.Loader.import(..)</code> in a real module to dynamically/conditionally load a module, where <code>import</code> itself would not work. You might, for instance, choose to load a module containing a polyfill for some ES7+ feature if a feature test reveals it&#39;s not defined by the current engine.</p> <p>For performance reasons, you&#39;ll want to avoid dynamic loading whenever possible, as it hampers the ability of the JS engine to fire off early fetches from its static analysis.</p> <h4 id=\"customized-loading\">Customized Loading</h4> <p>Another use for directly interacting with the module loader is if you want to customize its behavior through configuration or even redefinition.</p> <p>At the time of this writing, there&#39;s a polyfill for the module loader API being developed (<a href=\"https://github.com/ModuleLoader/es6-module-loader\">https://github.com/ModuleLoader/es6-module-loader</a>). While details are scarce and highly subject to change, we can explore what possibilities may eventually land.</p> <p>The <code>Reflect.Loader.import(..)</code> call may support a second argument for specifying various options to customize the import/load task. For example:</p> <pre><code class=\"lang-js\">Reflect.Loader.<span class=\"hljs-keyword\">import</span>( <span class=\"hljs-string\">\"foo\"</span>, { address: <span class=\"hljs-string\">\"/path/to/foo.js\"</span> } ) .then( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(foo)</span></span>{     <span class=\"hljs-comment\">// ..</span> } ) </code></pre> <p>It&#39;s also expected that a customization will be provided (through some means) for hooking into the process of loading a module, where a translation/transpilation could occur after load but before the engine compiles the module.</p> <p>For example, you could load something that&#39;s not already an ES6-compliant module format (e.g., CoffeeScript, TypeScript, CommonJS, AMD). Your translation step could then convert it to an ES6-compliant module for the engine to then process.</p> <h2 id=\"classes\">Classes</h2> <p>From nearly the beginning of JavaScript, syntax and development patterns have all strived (read: struggled) to put on a facade of supporting class-oriented development. With things like <code>new</code> and <code>instanceof</code> and a <code>.constructor</code> property, who couldn&#39;t help but be teased that JS had classes hidden somewhere inside its prototype system?</p> <p>Of course, JS &quot;classes&quot; aren&#39;t nearly the same as classical classes. The differences are well documented, so I won&#39;t belabor that point any further here.</p> <p><strong>Note:</strong> To learn more about the patterns used in JS to fake &quot;classes,&quot; and an alternative view of prototypes called &quot;delegation,&quot; see the second half of the <em>this &amp; Object Prototypes</em> title of this series.</p> <h3 id=\"-class-\"><code>class</code></h3> <p>Although JS&#39;s prototype mechanism doesn&#39;t work like traditional classes, that doesn&#39;t stop the strong tide of demand on the language to extend the syntactic sugar so that expressing &quot;classes&quot; looks more like real classes. Enter the ES6 <code>class</code> keyword and its associated mechanism.</p> <p>This feature is the result of a highly contentious and drawn-out debate, and represents a smaller subset compromise from several strongly opposed views on how to approach JS classes. Most developers who want full classes in JS will find parts of the new syntax quite inviting, but will find important bits still missing. Don&#39;t worry, though. TC39 is already working on additional features to augment classes in the post-ES6 timeframe.</p> <p>At the heart of the new ES6 class mechanism is the <code>class</code> keyword, which identifies a <em>block</em> where the contents define the members of a function&#39;s prototype. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">class</span> Foo {     <span class=\"hljs-constructor\"><span class=\"hljs-keyword\">constructor</span>(a,b) </span>{         <span class=\"hljs-keyword\">this</span>.x = a;         <span class=\"hljs-keyword\">this</span>.y = b;     }      gimmeXY() {         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.x * <span class=\"hljs-keyword\">this</span>.y;     } } </code></pre> <p>Some things to note:</p> <ul> <li><code>class Foo</code> implies creating a (special) function of the name <code>Foo</code>, much like you did pre-ES6.</li> <li><code>constructor(..)</code> identifies the signature of that <code>Foo(..)</code> function, as well as its body contents.</li> <li>Class methods use the same &quot;concise method&quot; syntax available to object literals, as discussed in Chapter 2. This also includes the concise generator form as discussed earlier in this chapter, as well as the ES5 getter/setter syntax. However, class methods are non-enumerable whereas object methods are by default enumerable.</li> <li>Unlike object literals, there are no commas separating members in a <code>class</code> body! In fact, they&#39;re not even allowed.</li> </ul> <p>The <code>class</code> syntax definition in the previous snippet can be roughly thought of as this pre-ES6 equivalent, which probably will look fairly familiar to those who&#39;ve done prototype-style coding before:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foo</span><span class=\"hljs-params\">(a,b)</span> </span>{     <span class=\"hljs-keyword\">this</span>.x = a;     <span class=\"hljs-keyword\">this</span>.y = b; }  Foo.prototype.gimmeXY = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.x * <span class=\"hljs-keyword\">this</span>.y; } </code></pre> <p>In either the pre-ES6 form or the new ES6 <code>class</code> form, this &quot;class&quot; can now be instantiated and used just as you&#39;d expect:</p> <pre><code class=\"lang-js\">var f = <span class=\"hljs-keyword\">new</span> Foo( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">15</span> );  f.x;                        <span class=\"hljs-comment\">// 5</span> f.y;                        <span class=\"hljs-comment\">// 15</span> f.gimmeXY();                <span class=\"hljs-comment\">// 75</span> </code></pre> <p>Caution! Though <code>class Foo</code> seems much like <code>function Foo()</code>, there are important differences:</p> <ul> <li>A <code>Foo(..)</code> call of <code>class Foo</code> <em>must</em> be made with <code>new</code>, as the pre-ES6 option of <code>Foo.call( obj )</code> will <em>not</em> work.</li> <li>While <code>function Foo</code> is &quot;hoisted&quot; (see the <em>Scope &amp; Closures</em> title of this series), <code>class Foo</code> is not; the <code>extends ..</code> clause specifies an expression that cannot be &quot;hoisted.&quot; So, you must declare a <code>class</code> before you can instantiate it.</li> <li><code>class Foo</code> in the top global scope creates a lexical <code>Foo</code> identifier in that scope, but unlike <code>function Foo</code> does not create a global object property of that name.</li> </ul> <p>The established <code>instanceof</code> operator still works with ES6 classes, because <code>class</code> just creates a constructor function of the same name. However, ES6 introduces a way to customize how <code>instanceof</code> works, using <code>Symbol.hasInstance</code> (see &quot;Well-Known Symbols&quot; in Chapter 7).</p> <p>Another way of thinking about <code>class</code>, which I find more convenient, is as a <em>macro</em> that is used to automatically populate a <code>prototype</code> object. Optionally, it also wires up the <code>[[Prototype]]</code> relationship if using <code>extends</code> (see the next section).</p> <p>An ES6 <code>class</code> isn&#39;t really an entity itself, but a meta concept that wraps around other concrete entities, such as functions and properties, and ties them together.</p> <p><strong>Tip:</strong> In addition to the declaration form, a <code>class</code> can also be an expression, as in: <code>var x = class Y { .. }</code>. This is primarily useful for passing a class definition (technically, the constructor itself) as a function argument or assigning it to an object property.</p> <h3 id=\"-extends-and-super-\"><code>extends</code> and <code>super</code></h3> <p>ES6 classes also have syntactic sugar for establishing the <code>[[Prototype]]</code> delegation link between two function prototypes -- commonly mislabeled &quot;inheritance&quot; or confusingly labeled &quot;prototype inheritance&quot; -- using the class-oriented familiar terminology <code>extends</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bar</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Foo</span> {</span>     constructor(a,b,c) {         <span class=\"hljs-keyword\">super</span>( a, b );         <span class=\"hljs-keyword\">this</span>.z = c;     }      gimmeXYZ() {         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">super</span>.gimmeXY() * <span class=\"hljs-keyword\">this</span>.z;     } }  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Bar</span>( <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">25</span> );  b.x;                        <span class=\"hljs-comment\">// 5</span> b.y;                        <span class=\"hljs-comment\">// 15</span> b.z;                        <span class=\"hljs-comment\">// 25</span> b.gimmeXYZ();                <span class=\"hljs-comment\">// 1875</span> </code></pre> <p>A significant new addition is <code>super</code>, which is actually something not directly possible pre-ES6 (without some unfortunate hack trade-offs). In the constructor, <code>super</code> automatically refers to the &quot;parent constructor,&quot; which in the previous example is <code>Foo(..)</code>. In a method, it refers to the &quot;parent object,&quot; such that you can then make a property/method access off it, such as <code>super.gimmeXY()</code>.</p> <p><code>Bar extends Foo</code> of course means to link the <code>[[Prototype]]</code> of <code>Bar.prototype</code> to <code>Foo.prototype</code>. So, <code>super</code> in a method like <code>gimmeXYZ()</code> specifically means <code>Foo.prototype</code>, whereas <code>super</code> means <code>Foo</code> when used in the <code>Bar</code> constructor.</p> <p><strong>Note:</strong> <code>super</code> is not limited to <code>class</code> declarations. It also works in object literals, in much the same way we&#39;re discussing here. See &quot;Object <code>super</code>&quot; in Chapter 2 for more information.</p> <h4 id=\"there-be-super-dragons\">There Be <code>super</code> Dragons</h4> <p>It is not insignificant to note that <code>super</code> behaves differently depending on where it appears. In fairness, most of the time, that won&#39;t be a problem. But surprises await if you deviate from a narrow norm.</p> <p>There may be cases where in the constructor you would want to reference the <code>Foo.prototype</code>, such as to directly access one of its properties/methods. However, <code>super</code> in the constructor cannot be used in that way; <code>super.prototype</code> will not work. <code>super(..)</code> means roughly to call <code>new Foo(..)</code>, but isn&#39;t actually a usable reference to <code>Foo</code> itself.</p> <p>Symmetrically, you may want to reference the <code>Foo(..)</code> function from inside a non-constructor method. <code>super.constructor</code> will point at <code>Foo(..)</code> the function, but beware that this function can <em>only</em> be invoked with <code>new</code>. <code>new super.constructor(..)</code> would be valid, but it wouldn&#39;t be terribly useful in most cases, because you can&#39;t make that call use or reference the current <code>this</code> object context, which is likely what you&#39;d want.</p> <p>Also, <code>super</code> looks like it might be driven by a function&#39;s context just like <code>this</code> -- that is, that they&#39;d both be dynamically bound. However, <code>super</code> is not dynamic like <code>this</code> is. When a constructor or method makes a <code>super</code> reference inside it at declaration time (in the <code>class</code> body), that <code>super</code> is statically bound to that specific class hierarchy, and cannot be overridden (at least in ES6).</p> <p>What does that mean? It means that if you&#39;re in the habit of taking a method from one &quot;class&quot; and &quot;borrowing&quot; it for another class by overriding its <code>this</code>, say with <code>call(..)</code> or <code>apply(..)</code>, that may very well create surprises if the method you&#39;re borrowing has a <code>super</code> in it. Consider this class hierarchy:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ParentA</span> {</span>     constructor() { <span class=\"hljs-keyword\">this</span>.id = <span class=\"hljs-string\">\"a\"</span>; }     foo() { console.log( <span class=\"hljs-string\">\"ParentA:\"</span>, <span class=\"hljs-keyword\">this</span>.id ); } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ParentB</span> {</span>     constructor() { <span class=\"hljs-keyword\">this</span>.id = <span class=\"hljs-string\">\"b\"</span>; }     foo() { console.log( <span class=\"hljs-string\">\"ParentB:\"</span>, <span class=\"hljs-keyword\">this</span>.id ); } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ChildA</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">ParentA</span> {</span>     foo() {         <span class=\"hljs-keyword\">super</span>.foo();         console.log( <span class=\"hljs-string\">\"ChildA:\"</span>, <span class=\"hljs-keyword\">this</span>.id );     } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ChildB</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">ParentB</span> {</span>     foo() {         <span class=\"hljs-keyword\">super</span>.foo();         console.log( <span class=\"hljs-string\">\"ChildB:\"</span>, <span class=\"hljs-keyword\">this</span>.id );     } }  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ChildA</span>(); a.foo();                    <span class=\"hljs-comment\">// ParentA: a</span>                             <span class=\"hljs-comment\">// ChildA: a</span> <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ChildB</span>();        <span class=\"hljs-comment\">// ParentB: b</span> b.foo();                    <span class=\"hljs-comment\">// ChildB: b</span> </code></pre> <p>All seems fairly natural and expected in this previous snippet. However, if you try to borrow <code>b.foo()</code> and use it in the context of <code>a</code> -- by virtue of dynamic <code>this</code> binding, such borrowing is quite common and used in many different ways, including mixins most notably -- you may find this result an ugly surprise:</p> <pre><code class=\"lang-js\"><span class=\"hljs-comment\">// borrow `b.foo()` to use in `a` context</span> b.foo.call<span class=\"hljs-comment\">( a )</span>;            <span class=\"hljs-comment\">// ParentB: a</span>                             <span class=\"hljs-comment\">// ChildB: a</span> </code></pre> <p>As you can see, the <code>this.id</code> reference was dynamically rebound so that <code>: a</code> is reported in both cases instead of <code>: b</code>. But <code>b.foo()</code>&#39;s <code>super.foo()</code> reference wasn&#39;t dynamically rebound, so it still reported <code>ParentB</code> instead of the expected <code>ParentA</code>.</p> <p>Because <code>b.foo()</code> references <code>super</code>, it is statically bound to the <code>ChildB</code>/<code>ParentB</code> hierarchy and cannot be used against the <code>ChildA</code>/<code>ParentA</code> hierarchy. There is no ES6 solution to this limitation.</p> <p><code>super</code> seems to work intuitively if you have a static class hierarchy with no cross-pollination. But in all fairness, one of the main benefits of doing <code>this</code>-aware coding is exactly that sort of flexibility. Simply, <code>class</code> + <code>super</code> requires you to avoid such techniques.</p> <p>The choice boils down to narrowing your object design to these static hierarchies -- <code>class</code>, <code>extends</code>, and <code>super</code> will be quite nice -- or dropping all attempts to &quot;fake&quot; classes and instead embrace dynamic and flexible, classless objects and <code>[[Prototype]]</code> delegation (see the <em>this &amp; Object Prototypes</em> title of this series).</p> <h4 id=\"subclass-constructor\">Subclass Constructor</h4> <p>Constructors are not required for classes or subclasses; a default constructor is substituted in both cases if omitted. However, the default substituted constructor is different for a direct class versus an extended class.</p> <p>Specifically, the default subclass constructor automatically calls the parent constructor, and passes along any arguments. In other words, you could think of the default subclass constructor sort of like this:</p> <pre><code class=\"lang-js\"><span class=\"hljs-constructor\"><span class=\"hljs-keyword\">constructor</span>(...args) </span>{     <span class=\"hljs-keyword\">super</span>(...args); } </code></pre> <p>This is an important detail to note. Not all class languages have the subclass constructor automatically call the parent constructor. C++ does, but Java does not. But more importantly, in pre-ES6 classes, such automatic &quot;parent constructor&quot; calling does not happen. Be careful when converting to ES6 <code>class</code> if you&#39;ve been relying on such calls <em>not</em> happening.</p> <p>Another perhaps surprising deviation/limitation of ES6 subclass constructors: in a constructor of a subclass, you cannot access <code>this</code> until <code>super(..)</code> has been called. The reason is nuanced and complicated, but it boils down to the fact that the parent constructor is actually the one creating/initializing your instance&#39;s <code>this</code>. Pre-ES6, it works oppositely; the <code>this</code> object is created by the &quot;subclass constructor,&quot; and then you  call a &quot;parent constructor&quot; with the context of the &quot;subclass&quot; <code>this</code>.</p> <p>Let&#39;s illustrate. This works pre-ES6:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foo</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">this</span>.a = <span class=\"hljs-number\">1</span>; }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Bar</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">this</span>.b = <span class=\"hljs-number\">2</span>;     Foo.call( <span class=\"hljs-keyword\">this</span> ); }  <span class=\"hljs-comment\">// `Bar` \"extends\" `Foo`</span> Bar.prototype = <span class=\"hljs-built_in\">Object</span>.create( Foo.prototype ); </code></pre> <p>But this ES6 equivalent is not allowed:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">class</span> Foo {     <span class=\"hljs-constructor\"><span class=\"hljs-keyword\">constructor</span>() </span>{ <span class=\"hljs-keyword\">this</span>.a = <span class=\"hljs-number\">1</span>; } }  <span class=\"hljs-keyword\">class</span> Bar extends Foo {     <span class=\"hljs-constructor\"><span class=\"hljs-keyword\">constructor</span>() </span>{         <span class=\"hljs-keyword\">this</span>.b = <span class=\"hljs-number\">2</span>;            <span class=\"hljs-comment\">// not allowed before `super()`</span>         <span class=\"hljs-keyword\">super</span>();            <span class=\"hljs-comment\">// to fix swap these two statements</span>     } } </code></pre> <p>In this case, the fix is simple. Just swap the two statements in the subclass <code>Bar</code> constructor. However, if you&#39;ve been relying pre-ES6 on being able to skip calling the &quot;parent constructor,&quot; beware because that won&#39;t be allowed anymore.</p> <h4 id=\"-extend-ing-natives\"><code>extend</code>ing Natives</h4> <p>One of the most heralded benefits to the new <code>class</code> and <code>extend</code> design is the ability to (finally!) subclass the built-in natives, like <code>Array</code>. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCoolArray</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Array</span> {</span>     first() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>[<span class=\"hljs-number\">0</span>]; }     last() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>[<span class=\"hljs-keyword\">this</span>.length - <span class=\"hljs-number\">1</span>]; } }  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">MyCoolArray</span>( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> );  a.length;                    <span class=\"hljs-comment\">// 3</span> a;                            <span class=\"hljs-comment\">// [1,2,3]</span>  a.first();                    <span class=\"hljs-comment\">// 1</span> a.last();                    <span class=\"hljs-comment\">// 3</span> </code></pre> <p>Prior to ES6, a fake &quot;subclass&quot; of <code>Array</code> using manual object creation and linking to <code>Array.prototype</code> only partially worked. It missed out on the special behaviors of a real array, such as the automatically updating <code>length</code> property. ES6 subclasses should fully work with &quot;inherited&quot; and augmented behaviors as expected!</p> <p>Another common pre-ES6 &quot;subclass&quot; limitation is with the <code>Error</code> object, in creating custom error &quot;subclasses.&quot; When genuine <code>Error</code> objects are created, they automatically capture special <code>stack</code> information, including the line number and file where the error is created. Pre-ES6 custom error &quot;subclasses&quot; have no such special behavior, which severely limits their usefulness.</p> <p>ES6 to the rescue:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Oops</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Error</span> {</span>     constructor(reason) {         <span class=\"hljs-keyword\">this</span>.oops = reason;     } }  <span class=\"hljs-comment\">// later:</span> <span class=\"hljs-keyword\">var</span> ouch = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Oops</span>( <span class=\"hljs-string\">\"I messed up!\"</span> ); <span class=\"hljs-keyword\">throw</span> ouch; </code></pre> <p>The <code>ouch</code> custom error object in this previous snippet will behave like any other genuine error object, including capturing <code>stack</code>. That&#39;s a big improvement!</p> <h3 id=\"-new-target-\"><code>new.target</code></h3> <p>ES6 introduces a new concept called a <em>meta property</em> (see Chapter 7), in the form of <code>new.target</code>.</p> <p>If that looks strange, it is; pairing a keyword with a <code>.</code> and a property name is definitely an out-of-the-ordinary pattern for JS.</p> <p><code>new.target</code> is a new &quot;magical&quot; value available in all functions, though in normal functions it will always be <code>undefined</code>. In any constructor, <code>new.target</code> always points at the constructor that <code>new</code> actually directly invoked, even if the constructor is in a parent class and was delegated to by a <code>super(..)</code> call from a child constructor. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">class</span> Foo {     <span class=\"hljs-constructor\"><span class=\"hljs-keyword\">constructor</span>() </span>{         <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"Foo: \"</span>, <span class=\"hljs-keyword\">new</span>.target.name );     } }  <span class=\"hljs-keyword\">class</span> Bar extends Foo {     <span class=\"hljs-constructor\"><span class=\"hljs-keyword\">constructor</span>() </span>{         <span class=\"hljs-keyword\">super</span>();         <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"Bar: \"</span>, <span class=\"hljs-keyword\">new</span>.target.name );     }     baz() {         <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"baz: \"</span>, <span class=\"hljs-keyword\">new</span>.target );     } }  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> Foo(); <span class=\"hljs-comment\">// Foo: Foo</span>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> Bar(); <span class=\"hljs-comment\">// Foo: Bar   &lt;-- respects the `new` call-site</span> <span class=\"hljs-comment\">// Bar: Bar</span>  b.baz(); <span class=\"hljs-comment\">// baz: undefined</span> </code></pre> <p>The <code>new.target</code> meta property doesn&#39;t have much purpose in class constructors, except accessing a static property/method (see the next section).</p> <p>If <code>new.target</code> is <code>undefined</code>, you know the function was not called with <code>new</code>. You can then force a <code>new</code> invocation if that&#39;s necessary.</p> <h3 id=\"-static-\"><code>static</code></h3> <p>When a subclass <code>Bar</code> extends a parent class <code>Foo</code>, we already observed that <code>Bar.prototype</code> is <code>[[Prototype]]</code>-linked to <code>Foo.prototype</code>. But additionally, <code>Bar()</code> is <code>[[Prototype]]</code>-linked to <code>Foo()</code>. That part may not have such an obvious reasoning.</p> <p>However, it&#39;s quite useful in the case where you declare <code>static</code> methods (not just properties) for a class, as these are added directly to that class&#39;s function object, not to the function object&#39;s <code>prototype</code> object. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> {</span>     static cool() { console.log( <span class=\"hljs-string\">\"cool\"</span> ); }     wow() { console.log( <span class=\"hljs-string\">\"wow\"</span> ); } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bar</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Foo</span> {</span>     static awesome() {         <span class=\"hljs-keyword\">super</span>.cool();         console.log( <span class=\"hljs-string\">\"awesome\"</span> );     }     neat() {         <span class=\"hljs-keyword\">super</span>.wow();         console.log( <span class=\"hljs-string\">\"neat\"</span> );     } }  <span class=\"hljs-type\">Foo</span>.cool();                    <span class=\"hljs-comment\">// \"cool\"</span> <span class=\"hljs-type\">Bar</span>.cool();                    <span class=\"hljs-comment\">// \"cool\"</span> <span class=\"hljs-type\">Bar</span>.awesome();                <span class=\"hljs-comment\">// \"cool\"</span>                             <span class=\"hljs-comment\">// \"awesome\"</span>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Bar</span>(); b.neat();                    <span class=\"hljs-comment\">// \"wow\"</span>                             <span class=\"hljs-comment\">// \"neat\"</span>  b.awesome;                    <span class=\"hljs-comment\">// undefined</span> b.cool;                        <span class=\"hljs-comment\">// undefined</span> </code></pre> <p>Be careful not to get confused that <code>static</code> members are on the class&#39;s prototype chain. They&#39;re actually on the dual/parallel chain between the function constructors.</p> <h4 id=\"-symbol-species-constructor-getter\"><code>Symbol.species</code> Constructor Getter</h4> <p>One place where <code>static</code> can be useful is in setting the <code>Symbol.species</code> getter (known internally in the specification as <code>@@species</code>) for a derived (child) class. This capability allows a child class to signal to a parent class what constructor should be used -- when not intending the child class&#39;s constructor itself -- if any parent class method needs to vend a new instance.</p> <p>For example, many methods on <code>Array</code> create and return a new <code>Array</code> instance. If you define a derived class from <code>Array</code>, but you want those methods to continue to vend actual <code>Array</code> instances instead of from your derived class, this works:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCoolArray</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Array</span> {</span>     <span class=\"hljs-comment\">// force `species` to be parent constructor</span>     static get [<span class=\"hljs-type\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Array</span>; } }  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">MyCoolArray</span>( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> ),     b = a.map( function(v){ <span class=\"hljs-keyword\">return</span> v * <span class=\"hljs-number\">2</span>; } );  b instanceof <span class=\"hljs-type\">MyCoolArray</span>;    <span class=\"hljs-comment\">// false</span> b instanceof <span class=\"hljs-type\">Array</span>;            <span class=\"hljs-comment\">// true</span> </code></pre> <p>To illustrate how a parent class method can use a child&#39;s species declaration somewhat like <code>Array#map(..)</code> is doing, consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Foo</span> {</span>     <span class=\"hljs-comment\">// defer `species` to derived constructor</span>     static get [<span class=\"hljs-type\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>; }     spawn() {         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.constructor[<span class=\"hljs-type\">Symbol</span>.species]();     } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bar</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Foo</span> {</span>     <span class=\"hljs-comment\">// force `species` to be parent constructor</span>     static get [<span class=\"hljs-type\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Foo</span>; } }  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Foo</span>(); <span class=\"hljs-keyword\">var</span> b = a.spawn(); b instanceof <span class=\"hljs-type\">Foo</span>;                    <span class=\"hljs-comment\">// true</span>  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Bar</span>(); <span class=\"hljs-keyword\">var</span> y = x.spawn(); y instanceof <span class=\"hljs-type\">Bar</span>;                    <span class=\"hljs-comment\">// false</span> y instanceof <span class=\"hljs-type\">Foo</span>;                    <span class=\"hljs-comment\">// true</span> </code></pre> <p>The parent class <code>Symbol.species</code> does <code>return this</code> to defer to any derived class, as you&#39;d normally expect. <code>Bar</code> then overrides to manually declare <code>Foo</code> to be used for such instance creation. Of course, a derived class can still vend instances of itself using <code>new this.constructor(..)</code>.</p> <h2 id=\"review\">Review</h2> <p>ES6 introduces several new features that aid in code organization:</p> <ul> <li>Iterators provide sequential access to data or operations. They can be consumed by new language features like <code>for..of</code> and <code>...</code>.</li> <li>Generators are locally pause/resume capable functions controlled by an iterator. They can be used to programmatically (and interactively, through <code>yield</code>/<code>next(..)</code> message passing) <em>generate</em> values to be consumed via iteration.</li> <li>Modules allow private encapsulation of implementation details with a publicly exported API. Module definitions are file-based, singleton instances, and statically resolved at compile time.</li> <li>Classes provide cleaner syntax around prototype-based coding. The addition of <code>super</code> also solves tricky issues with relative references in the <code>[[Prototype]]</code> chain.</li> </ul> <p>These new tools should be your first stop when trying to improve the architecture of your JS projects by embracing ES6.</p> ","title":"You Don't Know JS: ES6 & Beyond"},"ch4":{"body":"<h1 id=\"chapter-4-async-flow-control\">Chapter 4: Async Flow Control</h1> <p>It&#39;s no secret if you&#39;ve written any significant amount of JavaScript that asynchronous programming is a required skill. The primary mechanism for managing asynchrony has been the function callback.</p> <p>However, ES6 adds a new feature that helps address significant shortcomings in the callbacks-only approach to async: <em>Promises</em>. In addition, we can revisit generators (from the previous chapter) and see a pattern for combining the two that&#39;s a major step forward in async flow control programming in JavaScript.</p> <h2 id=\"promises\">Promises</h2> <p>Let&#39;s clear up some misconceptions: Promises are not about replacing callbacks. Promises provide a trustable intermediary -- that is, between your calling code and the async code that will perform the task -- to manage callbacks.</p> <p>Another way of thinking about a Promise is as an event listener, on which you can register to listen for an event that lets you know when a task has completed. It&#39;s an event that will only ever fire once, but it can be thought of as an event nonetheless.</p> <p>Promises can be chained together, which can sequence a series of asychronously completing steps. Together with higher-level abstractions like the <code>all(..)</code> method (in classic terms, a &quot;gate&quot;) and the <code>race(..)</code> method (in classic terms, a &quot;latch&quot;), promise chains provide a mechanism for async flow control.</p> <p>Yet another way of conceptualizing a Promise is that it&#39;s a <em>future value</em>, a time-independent container wrapped around a value. This container can be reasoned about identically whether the underlying value is final or not. Observing the resolution of a Promise extracts this value once available. In other words, a Promise is said to be the async version of a sync function&#39;s return value.</p> <p>A Promise can only have one of two possible resolution outcomes: fulfilled or rejected, with an optional single value. If a Promise is fulfilled, the final value is called a fulfillment. If it&#39;s rejected, the final value is called a reason (as in, a &quot;reason for rejection&quot;). Promises can only be resolved (fulfillment or rejection) <em>once</em>. Any further attempts to fulfill or reject are simply ignored. Thus, once a Promise is resolved, it&#39;s an immutable value that cannot be changed.</p> <p>Clearly, there are several different ways to think about what a Promise is. No single perspective is fully sufficient, but each provides a separate aspect of the whole. The big takeaway is that they offer a significant improvement over callbacks-only async, namely that they provide order, predictability, and trustability.</p> <h3 id=\"making-and-using-promises\">Making and Using Promises</h3> <p>To construct a promise instance, use the <code>Promise(..)</code> constructor:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{     <span class=\"hljs-comment\">// ..</span> } ); </code></pre> <p>The <code>Promise(..)</code> constructor takes a single function (<code>pr(..)</code>), which is called immediately and receives two control functions as arguments, usually named <code>resolve(..)</code> and <code>reject(..)</code>. They are used as:</p> <ul> <li>If you call <code>reject(..)</code>, the promise is rejected, and if any value is passed to <code>reject(..)</code>, it is set as the reason for rejection.</li> <li>If you call <code>resolve(..)</code> with no value, or any non-promise value, the promise is fulfilled.</li> <li>If you call <code>resolve(..)</code> and pass another promise, this promise simply adopts the state -- whether immediate or eventual -- of the passed promise (either fulfillment or rejection).</li> </ul> <p>Here&#39;s how you&#39;d typically use a promise to refactor a callback-reliant function call. If you start out with an <code>ajax(..)</code> utility that expects to be able to call an error-first style callback:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ajax</span><span class=\"hljs-params\">(url,cb)</span> </span>{     <span class=\"hljs-comment\">// make request, eventually call `cb(..)`</span> }  <span class=\"hljs-comment\">// ..</span>  ajax( <span class=\"hljs-string\">\"http://some.url.1\"</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handler</span><span class=\"hljs-params\">(err,contents)</span></span>{     <span class=\"hljs-keyword\">if</span> (err) {         <span class=\"hljs-comment\">// handle ajax error</span>     }     <span class=\"hljs-keyword\">else</span> {         <span class=\"hljs-comment\">// handle `contents` success</span>     } } ); </code></pre> <p>You can convert it to:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">ajax</span>(<span class=\"hljs-params\">url</span>) </span>{     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{         <span class=\"hljs-comment\">// make request, eventually call</span>         <span class=\"hljs-comment\">// either `resolve(..)` or `reject(..)`</span>     } ); }  <span class=\"hljs-comment\">// ..</span>  ajax( <span class=\"hljs-string\">\"http://some.url.1\"</span> ) .then(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\">contents</span>)</span>{         <span class=\"hljs-comment\">// handle `contents` success</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span>(<span class=\"hljs-params\">reason</span>)</span>{         <span class=\"hljs-comment\">// handle ajax error reason</span>     } ); </code></pre> <p>Promises have a <code>then(..)</code> method that accepts one or two callback functions. The first function (if present) is treated as the handler to call if the promise is fulfilled successfully. The second function (if present) is treated as the handler to call if the promise is rejected explicitly, or if any error/exception is caught during resolution.</p> <p>If one of the arguments is omitted or otherwise not a valid function -- typically you&#39;ll use <code>null</code> instead -- a default placeholder equivalent is used. The default success callback passes its fulfillment value along and the default error callback propagates its rejection reason along.</p> <p>The shorthand for calling <code>then(null,handleRejection)</code> is <code>catch(handleRejection)</code>.</p> <p>Both <code>then(..)</code> and <code>catch(..)</code> automatically construct and return another promise instance, which is wired to receive the resolution from whatever the return value is from the original promise&#39;s fulfillment or rejection handler (whichever is actually called). Consider:</p> <pre><code class=\"lang-js\">ajax( <span class=\"hljs-string\">\"http://some.url.1\"</span> ) .<span class=\"hljs-keyword\">then</span>(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span><span class=\"hljs-params\">(contents)</span>{</span>         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-transposed_variable\">contents.</span>toUpperCase();     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span><span class=\"hljs-params\">(reason)</span>{</span>         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"DEFAULT VALUE\"</span>;     } ) .<span class=\"hljs-keyword\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span><span class=\"hljs-params\">(data)</span>{</span>     <span class=\"hljs-comment\">// handle data from original promise's</span>     <span class=\"hljs-comment\">// handlers</span> } ); </code></pre> <p>In this snippet, we&#39;re returning an immediate value from either <code>fulfilled(..)</code> or <code>rejected(..)</code>, which then is received on the next event turn in the second <code>then(..)</code>&#39;s <code>fulfilled(..)</code>. If we instead return a new promise, that new promise is subsumed and adopted as the resolution:</p> <pre><code class=\"lang-js\">ajax( <span class=\"hljs-string\">\"http://some.url.1\"</span> ) .<span class=\"hljs-keyword\">then</span>(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span><span class=\"hljs-params\">(contents)</span>{</span>         <span class=\"hljs-keyword\">return</span> ajax(             <span class=\"hljs-string\">\"http://some.url.2?v=\"</span> + contents         );     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span><span class=\"hljs-params\">(reason)</span>{</span>         <span class=\"hljs-keyword\">return</span> ajax(             <span class=\"hljs-string\">\"http://backup.url.3?err=\"</span> + reason         );     } ) .<span class=\"hljs-keyword\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span><span class=\"hljs-params\">(contents)</span>{</span>     <span class=\"hljs-comment\">// `contents` comes from the subsequent</span>     <span class=\"hljs-comment\">// `ajax(..)` call, whichever it was</span> } ); </code></pre> <p>It&#39;s important to note that an exception (or rejected promise) in the first <code>fulfilled(..)</code> will <em>not</em> result in the first <code>rejected(..)</code> being called, as that handler only responds to the resolution of the first original promise. Instead, the second promise, which the second <code>then(..)</code> is called against, receives that rejection.</p> <p>In this previous snippet, we are not listening for that rejection, which means it will be silently held onto for future observation. If you never observe it by calling a <code>then(..)</code> or <code>catch(..)</code>, then it will go unhandled. Some browser developer consoles may detect these unhandled rejections and report them, but this is not reliably guaranteed; you should always observe promise rejections.</p> <p><strong>Note:</strong> This was just a brief overview of Promise theory and behavior. For a much more in-depth exploration, see Chapter 3 of the <em>Async &amp; Performance</em> title of this series.</p> <h3 id=\"thenables\">Thenables</h3> <p>Promises are genuine instances of the <code>Promise(..)</code> constructor. However, there are promise-like objects called <em>thenables</em> that generally can interoperate with the Promise mechanisms.</p> <p>Any object (or function) with a <code>then(..)</code> function on it is assumed to be a thenable. Any place where the Promise mechanisms can accept and adopt the state of a genuine promise, they can also handle a thenable.</p> <p>Thenables are basically a general label for any promise-like value that may have been created by some other system than the actual <code>Promise(..)</code> constructor. In that perspective, a thenable is generally less trustable than a genuine Promise. Consider this misbehaving thenable, for example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> th = {     then: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">thener</span><span class=\"hljs-params\">( fulfilled )</span> </span>{         <span class=\"hljs-comment\">// call `fulfilled(..)` once every 100ms forever</span>         setInterval( fulfilled, <span class=\"hljs-number\">100</span> );     } }; </code></pre> <p>If you received that thenable and chained it with <code>th.then(..)</code>, you&#39;d likely be surprised that your fulfillment handler is called repeatedly, when normal Promises are supposed to only ever be resolved once.</p> <p>Generally, if you&#39;re receiving what purports to be a promise or thenable back from some other system, you shouldn&#39;t just trust it blindly. In the next section, we&#39;ll see a utility included with ES6 Promises that helps address this trust concern.</p> <p>But to further understand the perils of this issue, consider that <em>any</em> object in <em>any</em> piece of code that&#39;s ever been defined to have a method on it called <code>then(..)</code> can be potentially confused as a thenable -- if used with Promises, of course -- regardless of if that thing was ever intended to even remotely be related to Promise-style async coding.</p> <p>Prior to ES6, there was never any special reservation made on methods called <code>then(..)</code>, and as you can imagine there&#39;s been at least a few cases where that method name has been chosen prior to Promises ever showing up on the radar screen. The most likely case of mistaken thenable will be async libraries that use <code>then(..)</code> but which are not strictly Promises-compliant -- there are several out in the wild.</p> <p>The onus will be on you to guard against directly using values with the Promise mechanism that would be incorrectly assumed to be a thenable.</p> <h3 id=\"-promise-api\"><code>Promise</code> API</h3> <p>The <code>Promise</code> API also provides some static methods for working with Promises.</p> <p><code>Promise.resolve(..)</code> creates a promise resolved to the value passed in. Let&#39;s compare how it works to the more manual approach:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-built_in\">Promise</span>.resolve( <span class=\"hljs-number\">42</span> );  <span class=\"hljs-keyword\">var</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve</span>)</span>{     resolve( <span class=\"hljs-number\">42</span> ); } ); </code></pre> <p><code>p1</code> and <code>p2</code> will have essentially identical behavior. The same goes for resolving with a promise:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> theP = ajax( .. );  <span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-built_in\">Promise</span>.resolve( theP );  <span class=\"hljs-keyword\">var</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve</span>)</span>{     resolve( theP ); } ); </code></pre> <p><strong>Tip:</strong> <code>Promise.resolve(..)</code> is the solution to the thenable trust issue raised in the previous section. Any value that you are not already certain is a trustable promise -- even if it could be an immediate value -- can be normalized by passing it to <code>Promise.resolve(..)</code>. If the value is already a recognizable promise or thenable, its state/resolution will simply be adopted, insulating you from misbehavior. If it&#39;s instead an immediate value, it will be &quot;wrapped&quot; in a genuine promise, thereby normalizing its behavior to be async.</p> <p><code>Promise.reject(..)</code> creates an immediately rejected promise, the same as its <code>Promise(..)</code> constructor counterpart:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-built_in\">Promise</span>.reject( <span class=\"hljs-string\">\"Oops\"</span> );  <span class=\"hljs-keyword\">var</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{     reject( <span class=\"hljs-string\">\"Oops\"</span> ); } ); </code></pre> <p>While <code>resolve(..)</code> and <code>Promise.resolve(..)</code> can accept a promise and adopt its state/resolution, <code>reject(..)</code> and <code>Promise.reject(..)</code> do not differentiate what value they receive. So, if you reject with a promise or thenable, the promise/thenable itself will be set as the rejection reason, not its underlying value.</p> <p><code>Promise.all([ .. ])</code> accepts an array of one or more values (e.g., immediate values, promises, thenables). It returns a promise back that will be fulfilled if all the values fulfill, or reject immediately once the first of any of them rejects.</p> <p>Starting with these values/promises:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> p1 = <span class=\"hljs-built_in\">Promise</span>.resolve( <span class=\"hljs-number\">42</span> ); <span class=\"hljs-keyword\">var</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve</span>)</span>{     setTimeout( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{         resolve( <span class=\"hljs-number\">43</span> );     }, <span class=\"hljs-number\">100</span> ); } ); <span class=\"hljs-keyword\">var</span> v3 = <span class=\"hljs-number\">44</span>; <span class=\"hljs-keyword\">var</span> p4 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">pr</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{     setTimeout( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{         reject( <span class=\"hljs-string\">\"Oops\"</span> );     }, <span class=\"hljs-number\">10</span> ); } ); </code></pre> <p>Let&#39;s consider how <code>Promise.all([ .. ])</code> works with combinations of those values:</p> <pre><code class=\"lang-js\"><span class=\"hljs-built_in\">Promise</span>.all( [p1,p2,v3] ) .then( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\">vals</span>)</span>{     <span class=\"hljs-built_in\">console</span>.log( vals );            <span class=\"hljs-comment\">// [42,43,44]</span> } );  <span class=\"hljs-built_in\">Promise</span>.all( [p1,p2,v3,p4] ) .then(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\">vals</span>)</span>{         <span class=\"hljs-comment\">// never gets here</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span>(<span class=\"hljs-params\">reason</span>)</span>{         <span class=\"hljs-built_in\">console</span>.log( reason );        <span class=\"hljs-comment\">// Oops</span>     } ); </code></pre> <p>While <code>Promise.all([ .. ])</code> waits for all fulfillments (or the first rejection), <code>Promise.race([ .. ])</code> waits only for either the first fulfillment or rejection. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-comment\">// <span class=\"hljs-doctag\">NOTE:</span> re-setup all test values to</span> <span class=\"hljs-comment\">// avoid timing issues misleading you!</span>  <span class=\"hljs-built_in\">Promise</span>.race( [p2,p1,v3] ) .then( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\">val</span>)</span>{     <span class=\"hljs-built_in\">console</span>.log( val );                <span class=\"hljs-comment\">// 42</span> } );  <span class=\"hljs-built_in\">Promise</span>.race( [p2,p1,v3,p4] ) .then(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\">val</span>)</span>{         <span class=\"hljs-comment\">// never gets here</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span>(<span class=\"hljs-params\">reason</span>)</span>{         <span class=\"hljs-built_in\">console</span>.log( reason );        <span class=\"hljs-comment\">// Oops</span>     } ); </code></pre> <p><strong>Warning:</strong> While <code>Promise.all([])</code> will fulfill right away (with no values), <code>Promise.race([])</code> will hang forever. This is a strange inconsistency, and speaks to the suggestion that you should never use these methods with empty arrays.</p> <h2 id=\"generators-promises\">Generators + Promises</h2> <p>It <em>is</em> possible to express a series of promises in a chain to represent the async flow control of your program. Consider:</p> <pre><code class=\"lang-js\">step1() .<span class=\"hljs-keyword\">then</span>(     step2,     step2Failed ) .<span class=\"hljs-keyword\">then</span>(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span></span> step3(msg) {         <span class=\"hljs-keyword\">return</span> Promise.<span class=\"hljs-built_in\">all</span>( [             step3a( msg ),             step3b( msg ),             step3c( msg )         ] )     } ) .<span class=\"hljs-keyword\">then</span>(step4); </code></pre> <p>However, there&#39;s a much better option for expressing async flow control, and it will probably be much more preferable in terms of coding style than long promise chains. We can use what we learned in Chapter 3 about generators to express our async flow control.</p> <p>The important pattern to recognize: a generator can yield a promise, and that promise can then be wired to resume the generator with its fulfillment value.</p> <p>Consider the previous snippet&#39;s async flow control expressed with a generator:</p> <pre><code class=\"lang-js\">function *main() {     <span class=\"hljs-keyword\">var</span> ret = <span class=\"hljs-function\"><span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title\">step1</span>(<span class=\"hljs-params\"></span>)</span>;      <span class=\"hljs-keyword\">try</span> {         ret = <span class=\"hljs-function\"><span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title\">step2</span>(<span class=\"hljs-params\"> ret </span>)</span>;     }     <span class=\"hljs-keyword\">catch</span> (err) {         ret = <span class=\"hljs-function\"><span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title\">step2Failed</span>(<span class=\"hljs-params\"> err </span>)</span>;     }      <span class=\"hljs-comment\">// step 3</span>     ret = <span class=\"hljs-keyword\">yield</span> Promise.all( [         step3a( ret ),         step3b( ret ),         step3c( ret )     ] );      <span class=\"hljs-function\"><span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title\">step4</span>(<span class=\"hljs-params\"> ret </span>)</span>; } </code></pre> <p>On the surface, this snippet may seem more verbose than the promise chain equivalent in the earlier snippet. However, it offers a much more attractive -- and more importantly, a more understandable and reason-able -- synchronous-looking coding style (with <code>=</code> assignment of &quot;return&quot; values, etc.) That&#39;s especially true in that <code>try..catch</code> error handling can be used across those hidden async boundaries.</p> <p>Why are we using Promises with the generator? It&#39;s certainly possible to do async generator coding without Promises.</p> <p>Promises are a trustable system that uninverts the inversion of control of normal callbacks or thunks (see the <em>Async &amp; Performance</em> title of this series). So, combining the trustability of Promises and the synchronicity of code in generators effectively addresses all the major deficiencies of callbacks. Also, utilities like <code>Promise.all([ .. ])</code> are a nice, clean way to express concurrency at a generator&#39;s single <code>yield</code> step.</p> <p>So how does this magic work? We&#39;re going to need a <em>runner</em> that can run our generator, receive a <code>yield</code>ed promise, and wire it up to resume the generator with either the fulfillment success value, or throw an error into the generator with the rejection reason.</p> <p>Many async-capable utilities/libraries have such a &quot;runner&quot;; for example, <code>Q.spawn(..)</code> and my asynquence&#39;s <code>runner(..)</code> plug-in. But here&#39;s a stand-alone runner to illustrate how the process works:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(gen)</span></span> {     var args = [].slice.call( arguments, <span class=\"hljs-number\">1</span>), it;      it = gen.apply( this, args );      <span class=\"hljs-keyword\">return</span> Promise.resolve()         .<span class=\"hljs-keyword\">then</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleNext</span><span class=\"hljs-params\">(value)</span></span>{             var <span class=\"hljs-built_in\">next</span> = it.<span class=\"hljs-built_in\">next</span>( value );              <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleResult</span><span class=\"hljs-params\">(next)</span></span>{                 <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">next</span>.done) {                     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">next</span>.value;                 }                 <span class=\"hljs-keyword\">else</span> {                     <span class=\"hljs-keyword\">return</span> Promise.resolve( <span class=\"hljs-built_in\">next</span>.value )                         .<span class=\"hljs-keyword\">then</span>(                             handleNext,                             <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">handleErr</span><span class=\"hljs-params\">(err)</span></span> {                                 <span class=\"hljs-keyword\">return</span> Promise.resolve(                                     it.throw( err )                                 )                                 .<span class=\"hljs-keyword\">then</span>( handleResult );                             }                         );                 }             })( <span class=\"hljs-built_in\">next</span> );         } ); } </code></pre> <p><strong>Note:</strong> For a more prolifically commented version of this utility, see the <em>Async &amp; Performance</em> title of this series. Also, the run utilities provided with various async libraries are often more powerful/capable than what we&#39;ve shown here. For example, asynquence&#39;s <code>runner(..)</code> can handle <code>yield</code>ed promises, sequences, thunks, and immediate (non-promise) values, giving you ultimate flexibility.</p> <p>So now running <code>*main()</code> as listed in the earlier snippet is as easy as:</p> <pre><code class=\"lang-js\">run( main ) .<span class=\"hljs-keyword\">then</span>(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span><span class=\"hljs-params\">()</span>{</span>         <span class=\"hljs-comment\">// `*main()` completed successfully</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span><span class=\"hljs-params\">(reason)</span>{</span>         <span class=\"hljs-comment\">// Oops, something went wrong</span>     } ); </code></pre> <p>Essentially, anywhere that you have more than two asynchronous steps of flow control logic in your program, you can <em>and should</em> use a promise-yielding generator driven by a run utility to express the flow control in a synchronous fashion. This will make for much easier to understand and maintain code.</p> <p>This yield-a-promise-resume-the-generator pattern is going to be so common and so powerful, the next version of JavaScript after ES6 is almost certainly going to introduce a new function type that will do it automatically without needing the run utility. We&#39;ll cover <code>async function</code>s (as they&#39;re expected to be called) in Chapter 8.</p> <h2 id=\"review\">Review</h2> <p>As JavaScript continues to mature and grow in its widespread adoption, asynchronous programming is more and more of a central concern. Callbacks are not fully sufficient for these tasks, and totally fall down the more sophisticated the need.</p> <p>Thankfully, ES6 adds Promises to address one of the major shortcomings of callbacks: lack of trust in predictable behavior. Promises represent the future completion value from a potentially async task, normalizing behavior across sync and async boundaries.</p> <p>But it&#39;s the combination of Promises with generators that fully realizes the benefits of rearranging our async flow control code to de-emphasize and abstract away that ugly callback soup (aka &quot;hell&quot;).</p> <p>Right now, we can manage these interactions with the aide of various async libraries&#39; runners, but JavaScript is eventually going to support this interaction pattern with dedicated syntax alone!</p> ","title":"You Don't Know JS: ES6 & Beyond"},"ch5":{"body":"<h1 id=\"chapter-5-collections\">Chapter 5: Collections</h1> <p>Structured collection and access to data is a critical component of just about any JS program. From the beginning of the language up to this point, the array and the object have been our primary mechanism for creating data structures. Of course, many higher-level data structures have been built on top of these, as user-land libraries.</p> <p>As of ES6, some of the most useful (and performance-optimizing!) data structure abstractions have been added as native components of the language.</p> <p>We&#39;ll start this chapter first by looking at <em>TypedArrays</em>, technically contemporary to ES5 efforts several years ago, but only standardized as companions to WebGL and not JavaScript itself. As of ES6, these have been adopted directly by the language specification, which gives them first-class status.</p> <p>Maps are like objects (key/value pairs), but instead of just a string for the key, you can use any value -- even another object or map! Sets are similar to arrays (lists of values), but the values are unique; if you add a duplicate, it&#39;s ignored. There are also weak (in relation to memory/garbage collection) counterparts: WeakMap and WeakSet.</p> <h2 id=\"typedarrays\">TypedArrays</h2> <p>As we cover in the <em>Types &amp; Grammar</em> title of this series, JS does have a set of built-in types, like <code>number</code> and <code>string</code>. It&#39;d be tempting to look at a feature named &quot;typed array&quot; and assume it means an array of a specific type of values, like an array of only strings.</p> <p>However, typed arrays are really more about providing structured access to binary data using array-like semantics (indexed access, etc.). The &quot;type&quot; in the name refers to a &quot;view&quot; layered on type of the bucket of bits, which is essentially a mapping of whether the bits should be viewed as an array of 8-bit signed integers, 16-bit signed integers, and so on.</p> <p>How do you construct such a bit-bucket? It&#39;s called a &quot;buffer,&quot; and you construct it most directly with the <code>ArrayBuffer(..)</code> constructor:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> buf = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ArrayBuffer</span>( <span class=\"hljs-number\">32</span> ); buf.byteLength;                            <span class=\"hljs-comment\">// 32</span> </code></pre> <p><code>buf</code> is now a binary buffer that is 32-bytes long (256-bits), that&#39;s pre-initialized to all <code>0</code>s. A buffer by itself doesn&#39;t really allow you any interaction exception for checking its <code>byteLength</code> property.</p> <p><strong>Tip:</strong> Several web platform features use or return array buffers, such as <code>FileReader#readAsArrayBuffer(..)</code>, <code>XMLHttpRequest#send(..)</code>, and <code>ImageData</code> (canvas data).</p> <p>But on top of this array buffer, you can then layer a &quot;view,&quot; which comes in the form of a typed array. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Uint16Array</span>( buf ); arr.length;                            <span class=\"hljs-comment\">// 16</span> </code></pre> <p><code>arr</code> is a typed array of 16-bit unsigned integers mapped over the 256-bit <code>buf</code> buffer, meaning you get 16 elements.</p> <h3 id=\"endianness\">Endianness</h3> <p>It&#39;s very important to understand that the <code>arr</code> is mapped using the endian-setting (big-endian or little-endian) of the platform the JS is running on. This can be an issue if the binary data is created with one endianness but interpreted on a platform with the opposite endianness.</p> <p>Endian means if the low-order byte (collection of 8-bits) of a multi-byte number -- such as the 16-bit unsigned ints we created in the earlier snippet -- is on the right or the left of the number&#39;s bytes.</p> <p>For example, let&#39;s imagine the base-10 number <code>3085</code>, which takes 16-bits to represent. If you have just one 16-bit number container, it&#39;d be represented in binary as <code>0000110000001101</code> (hexadecimal <code>0c0d</code>) regardless of endianness.</p> <p>But if <code>3085</code> was represented with two 8-bit numbers, the endianness would significantly affect its storage in memory:</p> <ul> <li><code>0000110000001101</code> / <code>0c0d</code> (big endian)</li> <li><code>0000110100001100</code> / <code>0d0c</code> (little endian)</li> </ul> <p>If you received the bits of <code>3085</code> as <code>0000110100001100</code> from a little-endian system, but you layered a view on top of it in a big-endian system, you&#39;d instead see value <code>3340</code> (base-10) and <code>0d0c</code> (base-16).</p> <p>Little endian is the most common representation on the web these days, but there are definitely browsers where that&#39;s not true. It&#39;s important that you understand the endianness of both the producer and consumer of a chunk of binary data.</p> <p>From MDN, here&#39;s a quick way to test the endianness of your JavaScript:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> littleEndian = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> buffer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ArrayBuffer</span>( <span class=\"hljs-number\">2</span> );     <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">DataView</span>( buffer ).setInt16( <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">256</span>, <span class=\"hljs-literal\">true</span> );     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Int16Array</span>( buffer )[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-number\">256</span>; })(); </code></pre> <p><code>littleEndian</code> will be <code>true</code> or <code>false</code>; for most browsers, it should return <code>true</code>. This test uses <code>DataView(..)</code>, which allows more low-level, fine-grained control over accessing (setting/getting) the bits from the view you layer over the buffer. The third parameter of the <code>setInt16(..)</code> method in the previous snippet is for telling the <code>DataView</code> what endianness you&#39;re wanting it to use for that operation.</p> <p><strong>Warning:</strong> Do not confuse endianness of underlying binary storage in array buffers with how a given number is represented when exposed in a JS program. For example, <code>(3085).toString(2)</code> returns <code>&quot;110000001101&quot;</code>, which with an assumed leading four <code>&quot;0&quot;</code>s appears to be the big-endian representation. In fact, this representation is based on a single 16-bit view, not a view of two 8-bit bytes. The <code>DataView</code> test above is the best way to determine endianness for your JS environment.</p> <h3 id=\"multiple-views\">Multiple Views</h3> <p>A single buffer can have multiple views attached to it, such as:</p> <pre><code class=\"lang-js\">var buf = <span class=\"hljs-keyword\">new</span> ArrayBuffer( <span class=\"hljs-number\">2</span> );  var view8 = <span class=\"hljs-keyword\">new</span> Uint8Array( buf ); var view16 = <span class=\"hljs-keyword\">new</span> Uint16Array( buf );  view16[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">3085</span>; view8[<span class=\"hljs-number\">0</span>];                        <span class=\"hljs-comment\">// 13</span> view8[<span class=\"hljs-number\">1</span>];                        <span class=\"hljs-comment\">// 12</span>  view8[<span class=\"hljs-number\">0</span>].toString( <span class=\"hljs-number\">16</span> );        <span class=\"hljs-comment\">// \"d\"</span> view8[<span class=\"hljs-number\">1</span>].toString( <span class=\"hljs-number\">16</span> );        <span class=\"hljs-comment\">// \"c\"</span>  <span class=\"hljs-comment\">// swap (as if endian!)</span> var tmp = view8[<span class=\"hljs-number\">0</span>]; view8[<span class=\"hljs-number\">0</span>] = view8[<span class=\"hljs-number\">1</span>]; view8[<span class=\"hljs-number\">1</span>] = tmp;  view16[<span class=\"hljs-number\">0</span>];                        <span class=\"hljs-comment\">// 3340</span> </code></pre> <p>The typed array constructors have multiple signature variations. We&#39;ve shown so far only passing them an existing buffer. However, that form also takes two extra parameters: <code>byteOffset</code> and <code>length</code>. In other words, you can start the typed array view at a location other than <code>0</code> and you can make it span less than the full length of the buffer.</p> <p>If the buffer of binary data includes data in non-uniform size/location, this technique can be quite useful.</p> <p>For example, consider a binary buffer that has a 2-byte number (aka &quot;word&quot;) at the beginning, followed by two 1-byte numbers, followed by a 32-bit floating point number. Here&#39;s how you can access that data with multiple views on the same buffer, offsets, and lengths:</p> <pre><code class=\"lang-js\">var first = <span class=\"hljs-keyword\">new</span> Uint16Array( buf, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> )[<span class=\"hljs-number\">0</span>],     second = <span class=\"hljs-keyword\">new</span> Uint8Array( buf, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span> )[<span class=\"hljs-number\">0</span>],     third = <span class=\"hljs-keyword\">new</span> Uint8Array( buf, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span> )[<span class=\"hljs-number\">0</span>],     fourth = <span class=\"hljs-keyword\">new</span> Float32Array( buf, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span> )[<span class=\"hljs-number\">0</span>]; </code></pre> <h3 id=\"typedarray-constructors\">TypedArray Constructors</h3> <p>In addition to the <code>(buffer,[offset, [length]])</code> form examined in the previous section, typed array constructors also support these forms:</p> <ul> <li>[constructor]<code>(length)</code>: Creates a new view over a new buffer of <code>length</code> bytes</li> <li>[constructor]<code>(typedArr)</code>: Creates a new view and buffer, and copies the contents from the <code>typedArr</code> view</li> <li>[constructor]<code>(obj)</code>: Creates a new view and buffer, and iterates over the array-like or object <code>obj</code> to copy its contents</li> </ul> <p>The following typed array constructors are available as of ES6:</p> <ul> <li><code>Int8Array</code> (8-bit signed integers), <code>Uint8Array</code> (8-bit unsigned integers)<ul> <li><code>Uint8ClampedArray</code> (8-bit unsigned integers, each value clamped on setting to the <code>0</code>-<code>255</code> range)</li> </ul> </li> <li><code>Int16Array</code> (16-bit signed integers), <code>Uint16Array</code> (16-bit unsigned integers)</li> <li><code>Int32Array</code> (32-bit signed integers), <code>Uint32Array</code> (32-bit unsigned integers)</li> <li><code>Float32Array</code> (32-bit floating point, IEEE-754)</li> <li><code>Float64Array</code> (64-bit floating point, IEEE-754)</li> </ul> <p>Instances of typed array constructors are almost the same as regular native arrays. Some differences include having a fixed length and the values all being of the same &quot;type.&quot;</p> <p>However, they share most of the same <code>prototype</code> methods. As such, you likely will be able to use them as regular arrays without needing to convert.</p> <p>For example:</p> <pre><code class=\"lang-js\">var a = <span class=\"hljs-keyword\">new</span> Int32Array( <span class=\"hljs-number\">3</span> ); a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">10</span>; a[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">20</span>; a[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">30</span>;  a.<span class=\"hljs-built_in\">map</span>( function(v){     console.<span class=\"hljs-built_in\">log</span>( v ); } ); <span class=\"hljs-comment\">// 10 20 30</span>  a.join( <span class=\"hljs-string\">\"-\"</span> ); <span class=\"hljs-comment\">// \"10-20-30\"</span> </code></pre> <p><strong>Warning:</strong> You can&#39;t use certain <code>Array.prototype</code> methods with TypedArrays that don&#39;t make sense, such as the mutators (<code>splice(..)</code>, <code>push(..)</code>, etc.) and <code>concat(..)</code>.</p> <p>Be aware that the elements in TypedArrays really are constrained to the declared bit sizes. If you have a <code>Uint8Array</code> and try to assign something larger than an 8-bit value into one of its elements, the value wraps around so as to stay within the bit length.</p> <p>This could cause problems if you were trying to, for instance, square all the values in a TypedArray. Consider:</p> <pre><code class=\"lang-js\">var a = <span class=\"hljs-keyword\">new</span> Uint8Array( <span class=\"hljs-number\">3</span> ); a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">10</span>; a[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">20</span>; a[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">30</span>;  var b = a.<span class=\"hljs-built_in\">map</span>( function(v){     <span class=\"hljs-keyword\">return</span> v * v; } );  b;                <span class=\"hljs-comment\">// [100, 144, 132]</span> </code></pre> <p>The <code>20</code> and <code>30</code> values, when squared, resulted in bit overflow. To get around such a limitation, you can use the <code>TypedArray#from(..)</code> function:</p> <pre><code class=\"lang-js\">var a = <span class=\"hljs-keyword\">new</span> Uint8Array( <span class=\"hljs-number\">3</span> ); a[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">10</span>; a[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-number\">20</span>; a[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">30</span>;  var b = Uint16Array.from( a, function(v){     <span class=\"hljs-keyword\">return</span> v * v; } );  b;                <span class=\"hljs-comment\">// [100, 400, 900]</span> </code></pre> <p>See the &quot;<code>Array.from(..)</code> Static Function&quot; section in Chapter 6 for more information about the <code>Array.from(..)</code> that is shared with TypedArrays. Specifically, the &quot;Mapping&quot; section explains the mapping function accepted as its second argument.</p> <p>One interesting behavior to consider is that TypedArrays have a <code>sort(..)</code> method much like regular arrays, but this one defaults to numeric sort comparisons instead of coercing values to strings for lexicographic comparison. For example:</p> <pre><code class=\"lang-js\">var a = [ <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, ]; a.sort();                                <span class=\"hljs-comment\">// [1,10,2]</span>  var b = <span class=\"hljs-keyword\">new</span> Uint8Array( [ <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> ] ); b.sort();                                <span class=\"hljs-comment\">// [1,2,10]</span> </code></pre> <p>The <code>TypedArray#sort(..)</code> takes an optional compare function argument just like <code>Array#sort(..)</code>, which works in exactly the same way.</p> <h2 id=\"maps\">Maps</h2> <p>If you have a lot of JS experience, you know that objects are the primary mechanism for creating unordered key/value-pair data structures, otherwise known as maps. However, the major drawback with objects-as-maps is the inability to use a non-string value as the key.</p> <p>For example, consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">m</span> = {};  <span class=\"hljs-keyword\">var</span> x = { id: 1 },     y = { id: 2 };  <span class=\"hljs-keyword\">m</span>[x] = <span class=\"hljs-string\">\"foo\"</span>; <span class=\"hljs-keyword\">m</span>[y] = <span class=\"hljs-string\">\"bar\"</span>;  <span class=\"hljs-keyword\">m</span>[x];                            <span class=\"hljs-comment\">// \"bar\"</span> <span class=\"hljs-keyword\">m</span>[y];                            <span class=\"hljs-comment\">// \"bar\"</span> </code></pre> <p>What&#39;s going on here? The two objects <code>x</code> and <code>y</code> both stringify to <code>&quot;[object Object]&quot;</code>, so only that one key is being set in <code>m</code>.</p> <p>Some have implemented fake maps by maintaining a parallel array of non-string keys alongside an array of the values, such as:</p> <pre><code class=\"lang-js\">var <span class=\"hljs-keyword\">keys</span> = [], vals = [];  var <span class=\"hljs-keyword\">x</span> = { id: <span class=\"hljs-number\">1</span> },     <span class=\"hljs-keyword\">y</span> = { id: <span class=\"hljs-number\">2</span> };  <span class=\"hljs-keyword\">keys</span>.<span class=\"hljs-keyword\">push</span>( <span class=\"hljs-keyword\">x</span> ); vals.<span class=\"hljs-keyword\">push</span>( <span class=\"hljs-string\">\"foo\"</span> );  <span class=\"hljs-keyword\">keys</span>.<span class=\"hljs-keyword\">push</span>( <span class=\"hljs-keyword\">y</span> ); vals.<span class=\"hljs-keyword\">push</span>( <span class=\"hljs-string\">\"bar\"</span> );  <span class=\"hljs-keyword\">keys</span>[<span class=\"hljs-number\">0</span>] === <span class=\"hljs-keyword\">x</span>;                    <span class=\"hljs-regexp\">//</span> true vals[<span class=\"hljs-number\">0</span>];                        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">\"foo\"</span>  <span class=\"hljs-keyword\">keys</span>[<span class=\"hljs-number\">1</span>] === <span class=\"hljs-keyword\">y</span>;                    <span class=\"hljs-regexp\">//</span> true vals[<span class=\"hljs-number\">1</span>];                        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-string\">\"bar\"</span> </code></pre> <p>Of course, you wouldn&#39;t want to manage those parallel arrays yourself, so you could define a data structure with methods that automatically do the management under the covers. Besides having to do that work yourself, the main drawback is that access is no longer O(1) time-complexity, but instead is O(n).</p> <p>But as of ES6, there&#39;s no longer any need to do this! Just use <code>Map(..)</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">m</span> = new Map();  <span class=\"hljs-keyword\">var</span> x = { id: 1 },     y = { id: 2 };  <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> ); <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( y, <span class=\"hljs-string\">\"bar\"</span> );  <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-literal\">get</span>( x );                        <span class=\"hljs-comment\">// \"foo\"</span> <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-literal\">get</span>( y );                        <span class=\"hljs-comment\">// \"bar\"</span> </code></pre> <p>The only drawback is that you can&#39;t use the <code>[ ]</code> bracket access syntax for setting and retrieving values. But <code>get(..)</code> and <code>set(..)</code> work perfectly suitably instead.</p> <p>To delete an element from a map, don&#39;t use the <code>delete</code> operator, but instead use the <code>delete(..)</code> method:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> ); <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( y, <span class=\"hljs-string\">\"bar\"</span> );  <span class=\"hljs-keyword\">m</span>.delete( y ); </code></pre> <p>You can clear the entire map&#39;s contents with <code>clear()</code>. To get the length of a map (i.e., the number of keys), use the <code>size</code> property (not <code>length</code>):</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> ); <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( y, <span class=\"hljs-string\">\"bar\"</span> ); <span class=\"hljs-keyword\">m</span>.size;                            <span class=\"hljs-comment\">// 2</span>  <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">clear</span>(); <span class=\"hljs-keyword\">m</span>.size;                            <span class=\"hljs-comment\">// 0</span> </code></pre> <p>The <code>Map(..)</code> constructor can also receive an iterable (see &quot;Iterators&quot; in Chapter 3), which must produce a list of arrays, where the first item in each array is the key and the second item is the value. This format for iteration is identical to that produced by the <code>entries()</code> method, explained in the next section. That makes it easy to make a copy of a map:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> m2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>( m.entries() );  <span class=\"hljs-comment\">// same as:</span> <span class=\"hljs-keyword\">var</span> m2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Map</span>( m ); </code></pre> <p>Because a map instance is an iterable, and its default iterator is the same as <code>entries()</code>, the second shorter form is more preferable.</p> <p>Of course, you can just manually specify an <em>entries</em> list (array of key/value arrays) in the <code>Map(..)</code> constructor form:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = { id: 1 },     y = { id: 2 };  <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">m</span> = new Map( [     [ x, <span class=\"hljs-string\">\"foo\"</span> ],     [ y, <span class=\"hljs-string\">\"bar\"</span> ] ] );  <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-literal\">get</span>( x );                        <span class=\"hljs-comment\">// \"foo\"</span> <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-literal\">get</span>( y );                        <span class=\"hljs-comment\">// \"bar\"</span> </code></pre> <h3 id=\"map-values\">Map Values</h3> <p>To get the list of values from a map, use <code>values(..)</code>, which returns an iterator. In Chapters 2 and 3, we covered various ways to process an iterator sequentially (like an array), such as the <code>...</code> spread operator and the <code>for..of</code> loop. Also, &quot;Arrays&quot; in Chapter 6 covers the <code>Array.from(..)</code> method in detail. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-built_in\">var</span> m = <span class=\"hljs-literal\">new</span> <span class=\"hljs-built_in\">Map</span>();  <span class=\"hljs-built_in\">var</span> x = { id: <span class=\"hljs-number\">1</span> },     y = { id: <span class=\"hljs-number\">2</span> };  m<span class=\"hljs-built_in\">.</span><span class=\"hljs-built_in\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> ); m<span class=\"hljs-built_in\">.</span><span class=\"hljs-built_in\">set</span>( y, <span class=\"hljs-string\">\"bar\"</span> );  <span class=\"hljs-built_in\">var</span> vals = <span class=\"hljs-preprocessor\">[</span> <span class=\"hljs-attribute\">...</span>m<span class=\"hljs-built_in\">.</span>values() <span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\">;  vals;                            // </span><span class=\"hljs-preprocessor\">[</span><span class=\"hljs-string\">\"foo\"</span>,<span class=\"hljs-string\">\"bar\"</span><span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\"> Array.from( m.values() );        // </span><span class=\"hljs-preprocessor\">[</span><span class=\"hljs-string\">\"foo\"</span>,<span class=\"hljs-string\">\"bar\"</span><span class=\"hljs-preprocessor\">]</span><span class=\"hljs-markup\"></span> </code></pre> <p>As discussed in the previous section, you can iterate over a map&#39;s entries using <code>entries()</code> (or the default map iterator). Consider:</p> <pre><code class=\"lang-js\">var m = new Map();  var x = { id: 1 }, <span class=\"hljs-code\">    y = { id: 2 };</span>  m.set( x, \"foo\" ); m.set( y, \"bar\" );  var vals = [ ...m.entries() ];  vals[<span class=\"hljs-link_label\">0</span>][<span class=\"hljs-link_reference\">0</span>] === x;                // true vals[<span class=\"hljs-link_label\">0</span>][<span class=\"hljs-link_reference\">1</span>];                        // \"foo\"  vals[<span class=\"hljs-link_label\">1</span>][<span class=\"hljs-link_reference\">0</span>] === y;                // true vals[<span class=\"hljs-link_label\">1</span>][<span class=\"hljs-link_reference\">1</span>];                        // \"bar\" </code></pre> <h3 id=\"map-keys\">Map Keys</h3> <p>To get the list of keys, use <code>keys()</code>, which returns an iterator over the keys in the map:</p> <pre><code class=\"lang-js\"><span class=\"hljs-built_in\">var</span> m = new Map();  <span class=\"hljs-built_in\">var</span> x = { id: <span class=\"hljs-number\">1</span> },     y = { id: <span class=\"hljs-number\">2</span> };  m.<span class=\"hljs-built_in\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> ); m.<span class=\"hljs-built_in\">set</span>( y, <span class=\"hljs-string\">\"bar\"</span> );  <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">keys</span> = [ ...m.<span class=\"hljs-built_in\">keys</span>() ];  <span class=\"hljs-built_in\">keys</span>[<span class=\"hljs-number\">0</span>] === x;                    <span class=\"hljs-comment\">// true</span> <span class=\"hljs-built_in\">keys</span>[<span class=\"hljs-number\">1</span>] === y;                    <span class=\"hljs-comment\">// true</span> </code></pre> <p>To determine if a map has a given key, use <code>has(..)</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">m</span> = new Map();  <span class=\"hljs-keyword\">var</span> x = { id: 1 },     y = { id: 2 };  <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> );  <span class=\"hljs-keyword\">m</span>.has( x );                        <span class=\"hljs-comment\">// true</span> <span class=\"hljs-keyword\">m</span>.has( y );                        <span class=\"hljs-comment\">// false</span> </code></pre> <p>Maps essentially let you associate some extra piece of information (the value) with an object (the key) without actually putting that information on the object itself.</p> <p>While you can use any kind of value as a key for a map, you typically will use objects, as strings and other primitives are already eligible as keys of normal objects. In other words, you&#39;ll probably want to continue to use normal objects for maps unless some or all of the keys need to be objects, in which case map is more appropriate.</p> <p><strong>Warning:</strong> If you use an object as a map key and that object is later discarded (all references unset) in attempt to have garbage collection (GC) reclaim its memory, the map itself will still retain its entry. You will need to remove the entry from the map for it to be GC-eligible. In the next section, we&#39;ll see WeakMaps as a better option for object keys and GC.</p> <h2 id=\"weakmaps\">WeakMaps</h2> <p>WeakMaps are a variation on maps, which has most of the same external behavior but differs underneath in how the memory allocation (specifically its GC) works.</p> <p>WeakMaps take (only) objects as keys. Those objects are held <em>weakly</em>, which means if the object itself is GC&#39;d, the entry in the WeakMap is also removed. This isn&#39;t observable behavior, though, as the only way an object can be GC&#39;d is if there&#39;s no more references to it -- once there are no more references to it, you have no object reference to check if it exists in the WeakMap.</p> <p>Otherwise, the API for WeakMap is similar, though more limited:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">m</span> = new WeakMap();  <span class=\"hljs-keyword\">var</span> x = { id: 1 },     y = { id: 2 };  <span class=\"hljs-keyword\">m</span>.<span class=\"hljs-keyword\">set</span>( x, <span class=\"hljs-string\">\"foo\"</span> );  <span class=\"hljs-keyword\">m</span>.has( x );                        <span class=\"hljs-comment\">// true</span> <span class=\"hljs-keyword\">m</span>.has( y );                        <span class=\"hljs-comment\">// false</span> </code></pre> <p>WeakMaps do not have a <code>size</code> property or <code>clear()</code> method, nor do they expose any iterators over their keys, values, or entries. So even if you unset the <code>x</code> reference, which will remove its entry from <code>m</code> upon GC, there is no way to tell. You&#39;ll just have to take JavaScript&#39;s word for it!</p> <p>Just like Maps, WeakMaps let you soft-associate information with an object. But they are particularly useful if the object is not one you completely control, such as a DOM element. If the object you&#39;re using as a map key can be deleted and should be GC-eligible when it is, then a WeakMap is a more appropriate option.</p> <p>It&#39;s important to note that a WeakMap only holds its <em>keys</em> weakly, not its values. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> m</span> = new WeakMap();  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> x</span> = { id: <span class=\"hljs-number\">1</span> },     y = { id: <span class=\"hljs-number\">2</span> },     z = { id: <span class=\"hljs-number\">3</span> },     w = { id: <span class=\"hljs-number\">4</span> };  m.<span class=\"hljs-keyword\">set</span>( x, y );  x = <span class=\"hljs-literal\">null</span>;                        <span class=\"hljs-comment\">// { id: 1 } is GC-eligible</span> y = <span class=\"hljs-literal\">null</span>;                        <span class=\"hljs-comment\">// { id: 2 } is GC-eligible</span>                                 <span class=\"hljs-comment\">// only because { id: 1 } is</span>  m.<span class=\"hljs-keyword\">set</span>( z, w );  w = <span class=\"hljs-literal\">null</span>;                        <span class=\"hljs-comment\">// { id: 4 } is not GC-eligible</span> </code></pre> <p>For this reason, WeakMaps are in my opinion better named &quot;WeakKeyMaps.&quot;</p> <h2 id=\"sets\">Sets</h2> <p>A set is a collection of unique values (duplicates are ignored).</p> <p>The API for a set is similar to map. The <code>add(..)</code> method takes the place of the <code>set(..)</code> method (somewhat ironically), and there is no <code>get(..)</code> method.</p> <p>Consider:</p> <pre><code class=\"lang-js\">var s = <span class=\"hljs-keyword\">new</span> Set();  var x = { id: <span class=\"hljs-number\">1</span> },     y = { id: <span class=\"hljs-number\">2</span> };  s.<span class=\"hljs-built_in\">add</span>( x ); s.<span class=\"hljs-built_in\">add</span>( y ); s.<span class=\"hljs-built_in\">add</span>( x );  s.<span class=\"hljs-built_in\">size</span>;                            <span class=\"hljs-comment\">// 2</span>  s.delete( y ); s.<span class=\"hljs-built_in\">size</span>;                            <span class=\"hljs-comment\">// 1</span>  s.<span class=\"hljs-built_in\">clear</span>(); s.<span class=\"hljs-built_in\">size</span>;                            <span class=\"hljs-comment\">// 0</span> </code></pre> <p>The <code>Set(..)</code> constructor form is similar to <code>Map(..)</code>, in that it can receive an iterable, like another set or simply an array of values. However, unlike how <code>Map(..)</code> expects <em>entries</em> list (array of key/value arrays), <code>Set(..)</code> expects a <em>values</em> list (array of values):</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = { id: <span class=\"hljs-number\">1</span> },     y = { id: <span class=\"hljs-number\">2</span> };  <span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Set</span>( [x,y] ); </code></pre> <p>A set doesn&#39;t need a <code>get(..)</code> because you don&#39;t retrieve a value from a set, but rather test if it is present or not, using <code>has(..)</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">Set</span>();  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-comment\">{ id: 1 }</span>,     y = <span class=\"hljs-comment\">{ id: 2 }</span>;  s.<span class=\"hljs-keyword\">add</span>( x );  s.<span class=\"hljs-keyword\">has</span>( x );                        <span class=\"hljs-comment\">// true</span> s.<span class=\"hljs-keyword\">has</span>( y );                        <span class=\"hljs-comment\">// false</span> </code></pre> <p><strong>Note:</strong> The comparison algorithm in <code>has(..)</code> is almost identical to <code>Object.is(..)</code> (see Chapter 6), except that <code>-0</code> and <code>0</code> are treated as the same rather than distinct.</p> <h3 id=\"set-iterators\">Set Iterators</h3> <p>Sets have the same iterator methods as maps. Their behavior is different for sets, but symmetric with the behavior of map iterators. Consider:</p> <pre><code class=\"lang-js\">var s = new Set();  var x = { id: 1 }, <span class=\"hljs-code\">    y = { id: 2 };</span>  s.add( x ).add( y );  var keys = [ ...s.keys() ], <span class=\"hljs-code\">    vals = [ ...s.values() ],</span> <span class=\"hljs-code\">    entries = [ ...s.entries() ];</span>  keys[0] === x; keys[1] === y;  vals[0] === x; vals[1] === y;  entries[<span class=\"hljs-link_label\">0</span>][<span class=\"hljs-link_reference\">0</span>] === x; entries[<span class=\"hljs-link_label\">0</span>][<span class=\"hljs-link_reference\">1</span>] === x; entries[<span class=\"hljs-link_label\">1</span>][<span class=\"hljs-link_reference\">0</span>] === y; entries[<span class=\"hljs-link_label\">1</span>][<span class=\"hljs-link_reference\">1</span>] === y; </code></pre> <p>The <code>keys()</code> and <code>values()</code> iterators both yield a list of the unique values in the set. The <code>entries()</code> iterator yields a list of entry arrays, where both items of the array are the unique set value. The default iterator for a set is its <code>values()</code> iterator.</p> <p>The inherent uniqueness of a set is its most useful trait. For example:</p> <pre><code class=\"lang-js\">var s = <span class=\"hljs-keyword\">new</span> Set( [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">\"1\"</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-string\">\"5\"</span>] ),     uniques = [ ...s ];  uniques;                        <span class=\"hljs-comment\">// [1,2,3,4,\"1\",\"5\"]</span> </code></pre> <p>Set uniqueness does not allow coercion, so <code>1</code> and <code>&quot;1&quot;</code> are considered distinct values.</p> <h2 id=\"weaksets\">WeakSets</h2> <p>Whereas a WeakMap holds its keys weakly (but its values strongly), a WeakSet holds its values weakly (there aren&#39;t really keys).</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">WeakSet</span>();  <span class=\"hljs-keyword\">var</span> x = { id: <span class=\"hljs-number\">1</span> },     y = { id: <span class=\"hljs-number\">2</span> };  s.add( x ); s.add( y );  x = <span class=\"hljs-literal\">null</span>;                        <span class=\"hljs-comment\">// `x` is GC-eligible</span> y = <span class=\"hljs-literal\">null</span>;                        <span class=\"hljs-comment\">// `y` is GC-eligible</span> </code></pre> <p><strong>Warning:</strong> WeakSet values must be objects, not primitive values as is allowed with sets.</p> <h2 id=\"review\">Review</h2> <p>ES6 defines a number of useful collections that make working with data in structured ways more efficient and effective.</p> <p>TypedArrays provide &quot;view&quot;s of binary data buffers that align with various integer types, like 8-bit unsigned integers and 32-bit floats. The array access to binary data makes operations much easier to express and maintain, which enables you to more easily work with complex data like video, audio, canvas data, and so on.</p> <p>Maps are key-value pairs where the key can be an object instead of just a string/primitive. Sets are unique lists of values (of any type).</p> <p>WeakMaps are maps where the key (object) is weakly held, so that GC is free to collect the entry if it&#39;s the last reference to an object. WeakSets are sets where the value is weakly held, again so that GC can remove the entry if it&#39;s the last reference to that object.</p> ","title":"You Don't Know JS: ES6 & Beyond"},"ch6":{"body":"<h1 id=\"chapter-6-api-additions\">Chapter 6: API Additions</h1> <p>From conversions of values to mathematic calculations, ES6 adds many static properties and methods to various built-in natives and objects to help with common tasks. In addition, instances of some of the natives have new capabilities via various new prototype methods.</p> <p><strong>Note:</strong> Most of these features can be faithfully polyfilled. We will not dive into such details here, but check out &quot;ES6 Shim&quot; (<a href=\"https://github.com/paulmillr/es6-shim/\">https://github.com/paulmillr/es6-shim/</a>) for standards-compliant shims/polyfills.</p> <h2 id=\"-array-\"><code>Array</code></h2> <p>One of the most commonly extended features in JS by various user libraries is the Array type. It should be no surprise that ES6 adds a number of helpers to Array, both static and prototype (instance).</p> <h3 id=\"-array-of-static-function\"><code>Array.of(..)</code> Static Function</h3> <p>There&#39;s a well known gotcha with the <code>Array(..)</code> constructor, which is that if there&#39;s only one argument passed, and that argument is a number, instead of making an array of one element with that number value in it, it constructs an empty array with a <code>length</code> property equal to the number. This action produces the unfortunate and quirky &quot;empty slots&quot; behavior that&#39;s reviled about JS arrays.</p> <p><code>Array.of(..)</code> replaces <code>Array(..)</code> as the preferred function-form constructor for arrays, because <code>Array.of(..)</code> does not have that special single-number-argument case. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">Array</span>( <span class=\"hljs-number\">3</span> ); a.length;                        <span class=\"hljs-comment\">// 3</span> a[<span class=\"hljs-number\">0</span>];                            <span class=\"hljs-comment\">// undefined</span>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">Array</span>.<span class=\"hljs-keyword\">of</span>( <span class=\"hljs-number\">3</span> ); b.length;                        <span class=\"hljs-comment\">// 1</span> b[<span class=\"hljs-number\">0</span>];                            <span class=\"hljs-comment\">// 3</span>  <span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-keyword\">Array</span>.<span class=\"hljs-keyword\">of</span>( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> ); c.length;                        <span class=\"hljs-comment\">// 3</span> c;                                <span class=\"hljs-comment\">// [1,2,3]</span> </code></pre> <p>Under what circumstances would you want to use <code>Array.of(..)</code> instead of just creating an array with literal syntax, like <code>c = [1,2,3]</code>? There&#39;s two possible cases.</p> <p>If you have a callback that&#39;s supposed to wrap argument(s) passed to it in an array, <code>Array.of(..)</code> fits the bill perfectly. That&#39;s probably not terribly common, but it may scratch an itch for you.</p> <p>The other scenario is if you subclass <code>Array</code> (see &quot;Classes&quot; in Chapter 3) and want to be able to create and initialize elements in an instance of your subclass, such as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCoolArray</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Array</span> {</span>     sum() {         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.reduce( function reducer(acc,curr){             <span class=\"hljs-keyword\">return</span> acc + curr;         }, <span class=\"hljs-number\">0</span> );     } }  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">MyCoolArray</span>( <span class=\"hljs-number\">3</span> ); x.length;                        <span class=\"hljs-comment\">// 3 -- oops!</span> x.sum();                        <span class=\"hljs-comment\">// 0 -- oops!</span>  <span class=\"hljs-keyword\">var</span> y = [<span class=\"hljs-number\">3</span>];                    <span class=\"hljs-comment\">// Array, not MyCoolArray</span> y.length;                        <span class=\"hljs-comment\">// 1</span> y.sum();                        <span class=\"hljs-comment\">// `sum` is not a function</span>  <span class=\"hljs-keyword\">var</span> z = <span class=\"hljs-type\">MyCoolArray</span>.of( <span class=\"hljs-number\">3</span> ); z.length;                        <span class=\"hljs-comment\">// 1</span> z.sum();                        <span class=\"hljs-comment\">// 3</span> </code></pre> <p>You can&#39;t just (easily) create a constructor for <code>MyCoolArray</code> that overrides the behavior of the <code>Array</code> parent constructor, because that constructor is necessary to actually create a well-behaving array value (initializing the <code>this</code>). The &quot;inherited&quot; static <code>of(..)</code> method on the <code>MyCoolArray</code> subclass provides a nice solution.</p> <h3 id=\"-array-from-static-function\"><code>Array.from(..)</code> Static Function</h3> <p>An &quot;array-like object&quot; in JavaScript is an object that has a <code>length</code> property on it, specifically with an integer value of zero or higher.</p> <p>These values have been notoriously frustrating to work with in JS; it&#39;s been quite common to need to transform them into an actual array, so that the various <code>Array.prototype</code> methods (<code>map(..)</code>, <code>indexOf(..)</code> etc.) are available to use with it. That process usually looks like:</p> <pre><code class=\"lang-js\">//<span class=\"hljs-instruction\"> array-like </span>object var arrLike = {     length: 3,     0: <span class=\"hljs-string\">\"foo\"</span>,     1: <span class=\"hljs-string\">\"bar\"</span> };  var arr =<span class=\"hljs-function\"> Array.prototype.slice.call(</span> arr<span class=\"hljs-class\">Like );</span> </code></pre> <p>Another common task where <code>slice(..)</code> is often used is in duplicating a real array:</p> <pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> arr2</span> = arr.slice(); </code></pre> <p>In both cases, the new ES6 <code>Array.from(..)</code> method can be a more understandable and graceful -- if also less verbose -- approach:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> arr = <span class=\"hljs-keyword\">Array</span>.<span class=\"hljs-keyword\">from</span>( arrLike );  <span class=\"hljs-keyword\">var</span> arrCopy = <span class=\"hljs-keyword\">Array</span>.<span class=\"hljs-keyword\">from</span>( arr ); </code></pre> <p><code>Array.from(..)</code> looks to see if the first argument is an iterable (see &quot;Iterators&quot; in Chapter 3), and if so, it uses the iterator to produce values to &quot;copy&quot; into the returned array. Because real arrays have an iterator for those values, that iterator is automatically used.</p> <p>But if you pass an array-like object as the first argument to <code>Array.from(..)</code>, it behaves basically the same as <code>slice()</code> (no arguments!) or <code>apply(..)</code> does, which is that it simply loops over the value, accessing numerically named properties from <code>0</code> up to whatever the value of <code>length</code> is.</p> <p>Consider:</p> <pre><code class=\"lang-js\">var arrLike = {     <span class=\"hljs-attribute\">length</span>: <span class=\"hljs-number\">4</span>,     <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">\"foo\"</span> };  Array.from( arrLike ); <span class=\"hljs-regexp\">//</span> [ <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-literal\">undefined</span> ] </code></pre> <p>Because positions <code>0</code>, <code>1</code>, and <code>3</code> didn&#39;t exist on <code>arrLike</code>, the result was the <code>undefined</code> value for each of those slots.</p> <p>You could produce a similar outcome like this:</p> <pre><code class=\"lang-js\">var emptySlotsArr = []; emptySlotsArr.length = <span class=\"hljs-number\">4</span>; emptySlotsArr[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-string\">\"foo\"</span>;  Array.from( emptySlotsArr ); <span class=\"hljs-regexp\">//</span> [ <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-literal\">undefined</span> ] </code></pre> <h4 id=\"avoiding-empty-slots\">Avoiding Empty Slots</h4> <p>There&#39;s a subtle but important difference in the previous snippet between the <code>emptySlotsArr</code> and the result of the <code>Array.from(..)</code> call. <code>Array.from(..)</code> never produces empty slots.</p> <p>Prior to ES6, if you wanted to produce an array initialized to a certain length with actual <code>undefined</code> values in each slot (no empty slots!), you had to do extra work:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-built_in\">Array</span>( <span class=\"hljs-number\">4</span> );                                <span class=\"hljs-comment\">// four empty slots!</span>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-built_in\">Array</span>.apply( <span class=\"hljs-literal\">null</span>, { length: <span class=\"hljs-number\">4</span> } );        <span class=\"hljs-comment\">// four `undefined` values</span> </code></pre> <p>But <code>Array.from(..)</code> now makes this easier:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-keyword\">Array</span>.<span class=\"hljs-keyword\">from</span>( <span class=\"hljs-comment\">{ length: 4 }</span> );            <span class=\"hljs-comment\">// four `undefined` values</span> </code></pre> <p><strong>Warning:</strong> Using an empty slot array like <code>a</code> in the previous snippets would work with some array functions, but others ignore empty slots (like <code>map(..)</code>, etc.). You should never intentionally work with empty slots, as it will almost certainly lead to strange/unpredictable behavior in your programs.</p> <h4 id=\"mapping\">Mapping</h4> <p>The <code>Array.from(..)</code> utility has another helpful trick up its sleeve. The second argument, if provided, is a mapping callback (almost the same as the regular <code>Array#map(..)</code> expects) which is called to map/transform each value from the source to the returned target. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> arrLike = {     length: <span class=\"hljs-number\">4</span>,     <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">\"foo\"</span> };  <span class=\"hljs-built_in\">Array</span>.from( arrLike, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">mapper</span>(<span class=\"hljs-params\">val,idx</span>)</span>{     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> val == <span class=\"hljs-string\">\"string\"</span>) {         <span class=\"hljs-keyword\">return</span> val.toUpperCase();     }     <span class=\"hljs-keyword\">else</span> {         <span class=\"hljs-keyword\">return</span> idx;     } } ); <span class=\"hljs-comment\">// [ 0, 1, \"FOO\", 3 ]</span> </code></pre> <p><strong>Note:</strong> As with other array methods that take callbacks, <code>Array.from(..)</code> takes an optional third argument that if set will specify the <code>this</code> binding for the callback passed as the second argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p> <p>See &quot;TypedArrays&quot; in Chapter 5 for an example of using <code>Array.from(..)</code> in translating values from an array of 8-bit values to an array of 16-bit values.</p> <h3 id=\"creating-arrays-and-subtypes\">Creating Arrays and Subtypes</h3> <p>In the last couple of sections, we&#39;ve discussed <code>Array.of(..)</code> and <code>Array.from(..)</code>, both of which create a new array in a similar way to a constructor. But what do they do in subclasses? Do they create instances of the base <code>Array</code> or the derived subclass?</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCoolArray</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Array</span> </span>{     .. }  <span class=\"hljs-built_in\">Array</span>.of( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;                    <span class=\"hljs-comment\">// true</span> <span class=\"hljs-built_in\">Array</span>.from( [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>] ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;                <span class=\"hljs-comment\">// true</span>  MyCoolArray.of( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;            <span class=\"hljs-comment\">// false</span> MyCoolArray.from( [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>] ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;        <span class=\"hljs-comment\">// false</span>  MyCoolArray.of( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span> ) <span class=\"hljs-keyword\">instanceof</span> MyCoolArray;        <span class=\"hljs-comment\">// true</span> MyCoolArray.from( [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>] ) <span class=\"hljs-keyword\">instanceof</span> MyCoolArray;    <span class=\"hljs-comment\">// true</span> </code></pre> <p>Both <code>of(..)</code> and <code>from(..)</code> use the constructor that they&#39;re accessed from to construct the array. So if you use the base <code>Array.of(..)</code> you&#39;ll get an <code>Array</code> instance, but if you use <code>MyCoolArray.of(..)</code>, you&#39;ll get a <code>MyCoolArray</code> instance.</p> <p>In &quot;Classes&quot; in Chapter 3, we covered the <code>@@species</code> setting which all the built-in classes (like <code>Array</code>) have defined, which is used by any prototype methods if they create a new instance. <code>slice(..)</code> is a great example:</p> <pre><code class=\"lang-js\">var x = <span class=\"hljs-keyword\">new</span> MyCoolArray( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> );  x.slice( <span class=\"hljs-number\">1</span> ) instanceof MyCoolArray;                <span class=\"hljs-comment\">// true</span> </code></pre> <p>Generally, that default behavior will probably be desired, but as we discussed in Chapter 3, you <em>can</em> override if you want:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCoolArray</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Array</span> {</span>     <span class=\"hljs-comment\">// force `species` to be parent constructor</span>     static get [<span class=\"hljs-type\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Array</span>; } }  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">MyCoolArray</span>( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> );  x.slice( <span class=\"hljs-number\">1</span> ) instanceof <span class=\"hljs-type\">MyCoolArray</span>;                <span class=\"hljs-comment\">// false</span> x.slice( <span class=\"hljs-number\">1</span> ) instanceof <span class=\"hljs-type\">Array</span>;                        <span class=\"hljs-comment\">// true</span> </code></pre> <p>It&#39;s important to note that the <code>@@species</code> setting is only used for the prototype methods, like <code>slice(..)</code>. It&#39;s not used by <code>of(..)</code> and <code>from(..)</code>; they both just use the <code>this</code> binding (whatever constructor is used to make the reference). Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCoolArray</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Array</span> </span>{     <span class=\"hljs-comment\">// force `species` to be parent constructor</span>     static get [<span class=\"hljs-built_in\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Array</span>; } }  <span class=\"hljs-keyword\">var</span> x = <span class=\"hljs-keyword\">new</span> MyCoolArray( <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span> );  x.slice( <span class=\"hljs-number\">1</span> ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;                        <span class=\"hljs-comment\">// true</span>  MyCoolArray.from( x ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;                <span class=\"hljs-comment\">// false</span> MyCoolArray.of( [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] ) <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-built_in\">Array</span>;            <span class=\"hljs-comment\">// false</span>  MyCoolArray.from( x ) <span class=\"hljs-keyword\">instanceof</span> MyCoolArray;        <span class=\"hljs-comment\">// true</span> MyCoolArray.of( [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>] ) <span class=\"hljs-keyword\">instanceof</span> MyCoolArray;    <span class=\"hljs-comment\">// true</span> </code></pre> <h3 id=\"-copywithin-prototype-method\"><code>copyWithin(..)</code> Prototype Method</h3> <p><code>Array#copyWithin(..)</code> is a new mutator method available to all arrays (including Typed Arrays; see Chapter 5). <code>copyWithin(..)</code> copies a portion of an array to another location in the same array, overwriting whatever was there before.</p> <p>The arguments are <em>target</em> (the index to copy to), <em>start</em> (the inclusive index to start the copying from), and optionally <em>end</em> (the exclusive index to stop copying). If any of the arguments are negative, they&#39;re taken to be relative from the end of the array.</p> <p>Consider:</p> <pre><code class=\"lang-js\">[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>].copyWithin( <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span> );            <span class=\"hljs-comment\">// [1,2,3,1,2]</span>  [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>].copyWithin( <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span> );        <span class=\"hljs-comment\">// [1,2,3,1,5]</span>  [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>].copyWithin( <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">2</span> );        <span class=\"hljs-comment\">// [4,5,3,4,5]</span>  [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>].copyWithin( <span class=\"hljs-number\">0</span>, -<span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">1</span> );    <span class=\"hljs-comment\">// [4,2,3,4,5]</span> </code></pre> <p>The <code>copyWithin(..)</code> method does not extend the array&#39;s length, as the first example in the previous snippet shows. Copying simply stops when the end of the array is reached.</p> <p>Contrary to what you might think, the copying doesn&#39;t always go in left-to-right (ascending index) order. It&#39;s possible this would result in repeatedly copying an already copied value if the from and target ranges overlap, which is presumably not desired behavior.</p> <p>So internally, the algorithm avoids this case by copying in reverse order to avoid that gotcha. Consider:</p> <pre><code class=\"lang-js\">[<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>].copyWithin( <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span> );        <span class=\"hljs-comment\">// ???</span> </code></pre> <p>If the algorithm was strictly moving left to right, then the <code>2</code> should be copied to overwrite the <code>3</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite <code>4</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite <code>5</code>, and you&#39;d end up with <code>[1,2,2,2,2]</code>.</p> <p>Instead, the copying algorithm reverses direction and copies <code>4</code> to overwrite <code>5</code>, then copies <code>3</code> to overwrite <code>4</code>, then copies <code>2</code> to overwrite <code>3</code>, and the final result is <code>[1,2,2,3,4]</code>. That&#39;s probably more &quot;correct&quot; in terms of expectation, but it can be confusing if you&#39;re only thinking about the copying algorithm in a naive left-to-right fashion.</p> <h3 id=\"-fill-prototype-method\"><code>fill(..)</code> Prototype Method</h3> <p>Filling an existing array entirely (or partially) with a specified value is natively supported as of ES6 with the <code>Array#fill(..)</code> method:</p> <pre><code class=\"lang-js\">var a = Array( <span class=\"hljs-number\">4</span> ).fill( <span class=\"hljs-literal\">undefined</span> ); a; <span class=\"hljs-regexp\">//</span> [<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">undefined</span>,<span class=\"hljs-literal\">undefined</span>] </code></pre> <p><code>fill(..)</code> optionally takes <em>start</em> and <em>end</em> parameters, which indicate a subset portion of the array to fill, such as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = [ <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">null</span> ].fill( <span class=\"hljs-number\">42</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span> );  a;                                    // [<span class=\"hljs-literal\">null</span>,<span class=\"hljs-number\">42</span>,<span class=\"hljs-number\">42</span>,<span class=\"hljs-literal\">null</span>] </code></pre> <h3 id=\"-find-prototype-method\"><code>find(..)</code> Prototype Method</h3> <p>The most common way to search for a value in an array has generally been the <code>indexOf(..)</code> method, which returns the index the value is found at or <code>-1</code> if not found:</p> <pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];  (a.indexOf( <span class=\"hljs-number\">3</span> ) != -<span class=\"hljs-number\">1</span>);                <span class=\"hljs-comment\">// true</span> (a.indexOf( <span class=\"hljs-number\">7</span> ) != -<span class=\"hljs-number\">1</span>);                <span class=\"hljs-comment\">// false</span>  (a.indexOf( <span class=\"hljs-string\">\"2\"</span> ) != -<span class=\"hljs-number\">1</span>);            <span class=\"hljs-comment\">// false</span> </code></pre> <p>The <code>indexOf(..)</code> comparison requires a strict <code>===</code> match, so a search for <code>&quot;2&quot;</code> fails to find a value of <code>2</code>, and vice versa. There&#39;s no way to override the matching algorithm for <code>indexOf(..)</code>. It&#39;s also unfortunate/ungraceful to have to make the manual comparison to the <code>-1</code> value.</p> <p><strong>Tip:</strong> See the <em>Types &amp; Grammar</em> title of this series for an interesting (and controversially confusing) technique to work around the <code>-1</code> ugliness with the <code>~</code> operator.</p> <p>Since ES5, the most common workaround to have control over the matching logic has been the <code>some(..)</code> method. It works by calling a function callback for each element, until one of those calls returns a <code>true</code>/truthy value, and then it stops. Because you get to define the callback function, you have full control over how a match is made:</p> <pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];  a.some( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(v)</span></span>{     <span class=\"hljs-keyword\">return</span> v == <span class=\"hljs-string\">\"2\"</span>; } );                                <span class=\"hljs-comment\">// true</span>  a.some( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(v)</span></span>{     <span class=\"hljs-keyword\">return</span> v == <span class=\"hljs-number\">7</span>; } );                                <span class=\"hljs-comment\">// false</span> </code></pre> <p>But the downside to this approach is that you only get the <code>true</code>/<code>false</code> indicating if a suitably matched value was found, but not what the actual matched value was.</p> <p>ES6&#39;s <code>find(..)</code> addresses this. It works basically the same as <code>some(..)</code>, except that once the callback returns a <code>true</code>/truthy value, the actual array value is returned:</p> <pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];  a.find( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(v)</span></span>{     <span class=\"hljs-keyword\">return</span> v == <span class=\"hljs-string\">\"2\"</span>; } );                                <span class=\"hljs-comment\">// 2</span>  a.find( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(v)</span></span>{     <span class=\"hljs-keyword\">return</span> v == <span class=\"hljs-number\">7</span>;                    <span class=\"hljs-comment\">// undefined</span> }); </code></pre> <p>Using a custom <code>matcher(..)</code> function also lets you match against complex values like objects:</p> <pre><code class=\"lang-js\">var points = [     { x: <span class=\"hljs-number\">10</span>, y: <span class=\"hljs-number\">20</span> },     { x: <span class=\"hljs-number\">20</span>, y: <span class=\"hljs-number\">30</span> },     { x: <span class=\"hljs-number\">30</span>, y: <span class=\"hljs-number\">40</span> },     { x: <span class=\"hljs-number\">40</span>, y: <span class=\"hljs-number\">50</span> },     { x: <span class=\"hljs-number\">50</span>, y: <span class=\"hljs-number\">60</span> } ];  points.find( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(point)</span> </span>{     <span class=\"hljs-keyword\">return</span> (         point.x % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span> &amp;&amp;         point.y % <span class=\"hljs-number\">4</span> == <span class=\"hljs-number\">0</span>     ); } );                                <span class=\"hljs-comment\">// { x: 30, y: 40 }</span> </code></pre> <p><strong>Note:</strong> As with other array methods that take callbacks, <code>find(..)</code> takes an optional second argument that if set will specify the <code>this</code> binding for the callback passed as the first argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p> <h3 id=\"-findindex-prototype-method\"><code>findIndex(..)</code> Prototype Method</h3> <p>While the previous section illustrates how <code>some(..)</code> yields a boolean result for a search of an array, and <code>find(..)</code> yields the matched value itself from the array search, there&#39;s also a need for finding the positional index of the matched value.</p> <p><code>indexOf(..)</code> does that, but there&#39;s no control over its matching logic; it always uses <code>===</code> strict equality. So ES6&#39;s <code>findIndex(..)</code> is the answer:</p> <pre><code class=\"lang-js\">var points = [     { x: <span class=\"hljs-number\">10</span>, y: <span class=\"hljs-number\">20</span> },     { x: <span class=\"hljs-number\">20</span>, y: <span class=\"hljs-number\">30</span> },     { x: <span class=\"hljs-number\">30</span>, y: <span class=\"hljs-number\">40</span> },     { x: <span class=\"hljs-number\">40</span>, y: <span class=\"hljs-number\">50</span> },     { x: <span class=\"hljs-number\">50</span>, y: <span class=\"hljs-number\">60</span> } ];  points.findIndex( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(point)</span> </span>{     <span class=\"hljs-keyword\">return</span> (         point.x % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span> &amp;&amp;         point.y % <span class=\"hljs-number\">4</span> == <span class=\"hljs-number\">0</span>     ); } );                                <span class=\"hljs-comment\">// 2</span>  points.findIndex( <span class=\"hljs-function\">function <span class=\"hljs-title\">matcher</span><span class=\"hljs-params\">(point)</span> </span>{     <span class=\"hljs-keyword\">return</span> (         point.x % <span class=\"hljs-number\">6</span> == <span class=\"hljs-number\">0</span> &amp;&amp;         point.y % <span class=\"hljs-number\">7</span> == <span class=\"hljs-number\">0</span>     ); } );                                <span class=\"hljs-comment\">// -1</span> </code></pre> <p>Don&#39;t use <code>findIndex(..) != -1</code> (the way it&#39;s always been done with <code>indexOf(..)</code>) to get a boolean from the search, because <code>some(..)</code> already yields the <code>true</code>/<code>false</code> you want. And don&#39;t do <code>a[ a.findIndex(..) ]</code> to get the matched value, because that&#39;s what <code>find(..)</code> accomplishes. And finally, use <code>indexOf(..)</code> if you need the index of a strict match, or <code>findIndex(..)</code> if you need the index of a more customized match.</p> <p><strong>Note:</strong> As with other array methods that take callbacks, <code>find(..)</code> takes an optional second argument that if set will specify the <code>this</code> binding for the callback passed as the first argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p> <h3 id=\"-entries-values-keys-prototype-methods\"><code>entries()</code>, <code>values()</code>, <code>keys()</code> Prototype Methods</h3> <p>In Chapter 3, we illustrated how data structures can provide a patterned item-by-item enumeration of their values, via an iterator. We then expounded on this approach in Chapter 5, as we explored how the new ES6 collections (Map, Set, etc.) provide several methods for producing different kinds of iterations.</p> <p>Because it&#39;s not new to ES6, <code>Array</code> might not be thought of traditionally as a &quot;collection,&quot; but it is one in the sense that it provides these same iterator methods: <code>entries()</code>, <code>values()</code>, and <code>keys()</code>. Consider:</p> <pre><code class=\"lang-js\">var a = <span class=\"hljs-comment\">[1,2,3]</span>;  <span class=\"hljs-comment\">[...a.values()]</span>;                    // <span class=\"hljs-comment\">[1,2,3]</span> <span class=\"hljs-comment\">[...a.keys()]</span>;                        // <span class=\"hljs-comment\">[0,1,2]</span> <span class=\"hljs-comment\">[...a.entries()]</span>;                    // <span class=\"hljs-comment\">[ <span class=\"hljs-comment\">[0,1]</span>, <span class=\"hljs-comment\">[1,2]</span>, <span class=\"hljs-comment\">[2,3]</span> ]</span>  <span class=\"hljs-comment\">[...a<span class=\"hljs-comment\">[Symbol.iterator]</span>()]</span>;            // <span class=\"hljs-comment\">[1,2,3]</span> </code></pre> <p>Just like with <code>Set</code>, the default <code>Array</code> iterator is the same as what <code>values()</code> returns.</p> <p>In &quot;Avoiding Empty Slots&quot; earlier in this chapter, we illustrated how <code>Array.from(..)</code> treats empty slots in an array as just being present slots with <code>undefined</code> in them. That&#39;s actually because under the covers, the array iterators behave that way:</p> <pre><code class=\"lang-js\">var a = <span class=\"hljs-comment\">[]</span>; a.length = 3; a<span class=\"hljs-comment\">[1]</span> = 2;  <span class=\"hljs-comment\">[...a.values()]</span>;        // <span class=\"hljs-comment\">[undefined,2,undefined]</span> <span class=\"hljs-comment\">[...a.keys()]</span>;            // <span class=\"hljs-comment\">[0,1,2]</span> <span class=\"hljs-comment\">[...a.entries()]</span>;        // <span class=\"hljs-comment\">[ <span class=\"hljs-comment\">[0,undefined]</span>, <span class=\"hljs-comment\">[1,2]</span>, <span class=\"hljs-comment\">[2,undefined]</span> ]</span> </code></pre> <h2 id=\"-object-\"><code>Object</code></h2> <p>A few additional static helpers have been added to <code>Object</code>. Traditionally, functions of this sort have been seen as focused on the behaviors/capabilities of object values.</p> <p>However, starting with ES6, <code>Object</code> static functions will also be for general-purpose global APIs of any sort that don&#39;t already belong more naturally in some other location (i.e., <code>Array.from(..)</code>).</p> <h3 id=\"-object-is-static-function\"><code>Object.is(..)</code> Static Function</h3> <p>The <code>Object.is(..)</code> static function makes value comparisons in an even more strict fashion than the <code>===</code> comparison.</p> <p><code>Object.is(..)</code> invokes the underlying <code>SameValue</code> algorithm (ES6 spec, section 7.2.9). The <code>SameValue</code> algorithm is basically the same as the <code>===</code> Strict Equality Comparison Algorithm (ES6 spec, section 7.2.13), with two important exceptions.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> x = NaN, y = <span class=\"hljs-number\">0</span>, z = -<span class=\"hljs-number\">0</span>;  x === x;                            <span class=\"hljs-comment\">// false</span> y === z;                            <span class=\"hljs-comment\">// true</span>  <span class=\"hljs-built_in\">Object</span>.<span class=\"hljs-keyword\">is</span>( x, x );                    <span class=\"hljs-comment\">// true</span> <span class=\"hljs-built_in\">Object</span>.<span class=\"hljs-keyword\">is</span>( y, z );                    <span class=\"hljs-comment\">// false</span> </code></pre> <p>You should continue to use <code>===</code> for strict equality comparisons; <code>Object.is(..)</code> shouldn&#39;t be thought of as a replacement for the operator. However, in cases where you&#39;re trying to strictly identify a <code>NaN</code> or <code>-0</code> value, <code>Object.is(..)</code> is now the preferred option.</p> <p><strong>Note:</strong> ES6 also adds a <code>Number.isNaN(..)</code> utility (discussed later in this chapter) which may be a slightly more convenient test; you may prefer <code>Number.isNaN(x)</code> over <code>Object.is(x,NaN)</code>. You <em>can</em> accurately test for <code>-0</code> with a clumsy <code>x == 0 &amp;&amp; 1 / x === -Infinity</code>, but in this case <code>Object.is(x,-0)</code> is much better.</p> <h3 id=\"-object-getownpropertysymbols-static-function\"><code>Object.getOwnPropertySymbols(..)</code> Static Function</h3> <p>The &quot;Symbols&quot; section in Chapter 2 discusses the new Symbol primitive value type in ES6.</p> <p>Symbols are likely going to be mostly used as special (meta) properties on objects. So the <code>Object.getOwnPropertySymbols(..)</code> utility was introduced, which retrieves only the symbol properties directly on an object:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o = {     foo: <span class=\"hljs-number\">42</span>,     [ <span class=\"hljs-built_in\">Symbol</span>( <span class=\"hljs-string\">\"bar\"</span> ) ]: <span class=\"hljs-string\">\"hello world\"</span>,     baz: <span class=\"hljs-keyword\">true</span> };  <span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols( o );    <span class=\"hljs-comment\">// [ Symbol(bar) ]</span> </code></pre> <h3 id=\"-object-setprototypeof-static-function\"><code>Object.setPrototypeOf(..)</code> Static Function</h3> <p>Also in Chapter 2, we mentioned the <code>Object.setPrototypeOf(..)</code> utility, which (unsurprisingly) sets the <code>[[Prototype]]</code> of an object for the purposes of <em>behavior delegation</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o1 = {     foo() { <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"foo\"</span> ); } }; <span class=\"hljs-keyword\">var</span> o2 = {     <span class=\"hljs-comment\">// .. o2's definition ..</span> };  <span class=\"hljs-built_in\">Object</span>.setPrototypeOf( o2, o1 );  <span class=\"hljs-comment\">// delegates to `o1.foo()`</span> o2.foo();                            <span class=\"hljs-comment\">// foo</span> </code></pre> <p>Alternatively:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o1 = {     foo() { <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"foo\"</span> ); } };  <span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-built_in\">Object</span>.setPrototypeOf( {     <span class=\"hljs-comment\">// .. o2's definition ..</span> }, o1 );  <span class=\"hljs-comment\">// delegates to `o1.foo()`</span> o2.foo();                            <span class=\"hljs-comment\">// foo</span> </code></pre> <p>In both previous snippets, the relationship between <code>o2</code> and <code>o1</code> appears at the end of the <code>o2</code> definition. More commonly, the relationship between an <code>o2</code> and <code>o1</code> is specified at the top of the <code>o2</code> definition, as it is with classes, and also with <code>__proto__</code> in object literals (see &quot;Setting <code>[[Prototype]]</code>&quot; in Chapter 2).</p> <p><strong>Warning:</strong> Setting a <code>[[Prototype]]</code> right after object creation is reasonable, as shown. But changing it much later is generally not a good idea and will usually lead to more confusion than clarity.</p> <h3 id=\"-object-assign-static-function\"><code>Object.assign(..)</code> Static Function</h3> <p>Many JavaScript libraries/frameworks provide utilities for copying/mixing one object&#39;s properties into another (e.g., jQuery&#39;s <code>extend(..)</code>). There are various nuanced differences between these different utilities, such as whether a property with value <code>undefined</code> is ignored or not.</p> <p>ES6 adds <code>Object.assign(..)</code>, which is a simplified version of these algorithms. The first argument is the <em>target</em>, and any other arguments passed are the <em>sources</em>, which will be processed in listed order. For each source, its enumerable and own (e.g., not &quot;inherited&quot;) keys, including symbols, are copied as if by plain <code>=</code> assignment. <code>Object.assign(..)</code> returns the target object.</p> <p>Consider this object setup:</p> <pre><code class=\"lang-js\">var target = {},     o1 = { a: <span class=\"hljs-number\">1</span> }, o2 = { b: <span class=\"hljs-number\">2</span> },     o3 = { c: <span class=\"hljs-number\">3</span> }, o4 = { d: <span class=\"hljs-number\">4</span> };  <span class=\"hljs-comment\">// setup read-only property</span> Object.defineProperty( o3, <span class=\"hljs-string\">\"e\"</span>, {     value: <span class=\"hljs-number\">5</span>,     enumerable: <span class=\"hljs-literal\">true</span>,     writable: <span class=\"hljs-literal\">false</span>,     configurable: <span class=\"hljs-literal\">false</span> } );  <span class=\"hljs-comment\">// setup non-enumerable property</span> Object.defineProperty( o3, <span class=\"hljs-string\">\"f\"</span>, {     value: <span class=\"hljs-number\">6</span>,     enumerable: <span class=\"hljs-literal\">false</span> } );  o3[ Symbol( <span class=\"hljs-string\">\"g\"</span> ) ] = <span class=\"hljs-number\">7</span>;  <span class=\"hljs-comment\">// setup non-enumerable symbol</span> Object.defineProperty( o3, Symbol( <span class=\"hljs-string\">\"h\"</span> ), {     value: <span class=\"hljs-number\">8</span>,     enumerable: <span class=\"hljs-literal\">false</span> } );  Object.setPrototypeOf( o3, o4 ); </code></pre> <p>Only the properties <code>a</code>, <code>b</code>, <code>c</code>, <code>e</code>, and <code>Symbol(&quot;g&quot;)</code> will be copied to <code>target</code>:</p> <pre><code class=\"lang-js\">Object.assign( <span class=\"hljs-keyword\">target</span>, o1, o2, o3 );  <span class=\"hljs-keyword\">target</span>.a;                            <span class=\"hljs-comment\">// 1</span> <span class=\"hljs-keyword\">target</span>.b;                            <span class=\"hljs-comment\">// 2</span> <span class=\"hljs-keyword\">target</span>.c;                            <span class=\"hljs-comment\">// 3</span>  Object.getOwnPropertyDescriptor( <span class=\"hljs-keyword\">target</span>, <span class=\"hljs-string\">\"e\"</span> ); <span class=\"hljs-comment\">// { value: 5, writable: true, enumerable: true,</span> <span class=\"hljs-comment\">//   configurable: true }</span>  Object.getOwnPropertySymbols( <span class=\"hljs-keyword\">target</span> ); <span class=\"hljs-comment\">// [Symbol(\"g\")]</span> </code></pre> <p>The <code>d</code>, <code>f</code>, and <code>Symbol(&quot;h&quot;)</code> properties are omitted from copying; non-enumerable properties and non-owned properties are all excluded from the assignment. Also, <code>e</code> is copied as a normal property assignment, not duplicated as a read-only property.</p> <p>In an earlier section, we showed using <code>setPrototypeOf(..)</code> to set up a <code>[[Prototype]]</code> relationship between an <code>o2</code> and <code>o1</code> object. There&#39;s another form that leverages <code>Object.assign(..)</code>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o1 = {     foo() { <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"foo\"</span> ); } };  <span class=\"hljs-keyword\">var</span> o2 = <span class=\"hljs-built_in\">Object</span>.assign(     <span class=\"hljs-built_in\">Object</span>.create( o1 ),     {         <span class=\"hljs-comment\">// .. o2's definition ..</span>     } );  <span class=\"hljs-comment\">// delegates to `o1.foo()`</span> o2.foo();                            <span class=\"hljs-comment\">// foo</span> </code></pre> <p><strong>Note:</strong> <code>Object.create(..)</code> is the ES5 standard utility that creates an empty object that is <code>[[Prototype]]</code>-linked. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p> <h2 id=\"-math-\"><code>Math</code></h2> <p>ES6 adds several new mathematic utilities that fill in holes or aid with common operations. All of these can be manually calculated, but most of them are now defined natively so that in some cases the JS engine can either more optimally perform the calculations, or perform them with better decimal precision than their manual counterparts.</p> <p>It&#39;s likely that asm.js/transpiled JS code (see the <em>Async &amp; Performance</em> title of this series) is the more likely consumer of many of these utilities rather than direct developers.</p> <p>Trigonometry:</p> <ul> <li><code>cosh(..)</code> - Hyperbolic cosine</li> <li><code>acosh(..)</code> - Hyperbolic arccosine</li> <li><code>sinh(..)</code> - Hyperbolic sine</li> <li><code>asinh(..)</code> - Hyperbolic arcsine</li> <li><code>tanh(..)</code> - Hyperbolic tangent</li> <li><code>atanh(..)</code> - Hyperbolic arctangent</li> <li><code>hypot(..)</code> - The squareroot of the sum of the squares (i.e., the generalized Pythagorean theorem)</li> </ul> <p>Arithmetic:</p> <ul> <li><code>cbrt(..)</code> - Cube root</li> <li><code>clz32(..)</code> - Count leading zeros in 32-bit binary representation</li> <li><code>expm1(..)</code> - The same as <code>exp(x) - 1</code></li> <li><code>log2(..)</code> - Binary logarithm (log base 2)</li> <li><code>log10(..)</code> - Log base 10</li> <li><code>log1p(..)</code> - The same as <code>log(x + 1)</code></li> <li><code>imul(..)</code> - 32-bit integer multiplication of two numbers</li> </ul> <p>Meta:</p> <ul> <li><code>sign(..)</code> - Returns the sign of the number</li> <li><code>trunc(..)</code> - Returns only the integer part of a number</li> <li><code>fround(..)</code> - Rounds to nearest 32-bit (single precision) floating-point value</li> </ul> <h2 id=\"-number-\"><code>Number</code></h2> <p>Importantly, for your program to properly work, it must accurately handle numbers. ES6 adds some additional properties and functions to assist with common numeric operations.</p> <p>Two additions to <code>Number</code> are just references to the preexisting globals: <code>Number.parseInt(..)</code> and <code>Number.parseFloat(..)</code>.</p> <h3 id=\"static-properties\">Static Properties</h3> <p>ES6 adds some helpful numeric constants as static properties:</p> <ul> <li><code>Number.EPSILON</code> - The minimum value between any two numbers: <code>2^-52</code> (see Chapter 2 of the <em>Types &amp; Grammar</em> title of this series regarding using this value as a tolerance for imprecision in floating-point arithmetic)</li> <li><code>Number.MAX_SAFE_INTEGER</code> - The highest integer that can &quot;safely&quot; be represented unambiguously in a JS number value: <code>2^53 - 1</code></li> <li><code>Number.MIN_SAFE_INTEGER</code> - The lowest integer that can &quot;safely&quot; be represented unambiguously in a JS number value: <code>-(2^53 - 1)</code> or <code>(-2)^53 + 1</code>.</li> </ul> <p><strong>Note:</strong> See Chapter 2 of the <em>Types &amp; Grammar</em> title of this series for more information about &quot;safe&quot; integers.</p> <h3 id=\"-number-isnan-static-function\"><code>Number.isNaN(..)</code> Static Function</h3> <p>The standard global <code>isNaN(..)</code> utility has been broken since its inception, in that it returns <code>true</code> for things that are not numbers, not just for the actual <code>NaN</code> value, because it coerces the argument to a number type (which can falsely result in a NaN). ES6 adds a fixed utility <code>Number.isNaN(..)</code> that works as it should:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-literal\">NaN</span>, b = <span class=\"hljs-string\">\"NaN\"</span>, c = <span class=\"hljs-number\">42</span>;  <span class=\"hljs-built_in\">isNaN</span>( a );                            <span class=\"hljs-comment\">// true</span> <span class=\"hljs-built_in\">isNaN</span>( b );                            <span class=\"hljs-comment\">// true -- oops!</span> <span class=\"hljs-built_in\">isNaN</span>( c );                            <span class=\"hljs-comment\">// false</span>  <span class=\"hljs-built_in\">Number</span>.isNaN( a );                    <span class=\"hljs-comment\">// true</span> <span class=\"hljs-built_in\">Number</span>.isNaN( b );                    <span class=\"hljs-comment\">// false -- fixed!</span> <span class=\"hljs-built_in\">Number</span>.isNaN( c );                    <span class=\"hljs-comment\">// false</span> </code></pre> <h3 id=\"-number-isfinite-static-function\"><code>Number.isFinite(..)</code> Static Function</h3> <p>There&#39;s a temptation to look at a function name like <code>isFinite(..)</code> and assume it&#39;s simply &quot;not infinite&quot;. That&#39;s not quite correct, though. There&#39;s more nuance to this new ES6 utility. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-literal\">NaN</span>, b = <span class=\"hljs-literal\">Infinity</span>, c = <span class=\"hljs-number\">42</span>;  <span class=\"hljs-built_in\">Number</span>.isFinite( a );                <span class=\"hljs-comment\">// false</span> <span class=\"hljs-built_in\">Number</span>.isFinite( b );                <span class=\"hljs-comment\">// false</span>  <span class=\"hljs-built_in\">Number</span>.isFinite( c );                <span class=\"hljs-comment\">// true</span> </code></pre> <p>The standard global <code>isFinite(..)</code> coerces its argument, but <code>Number.isFinite(..)</code> omits the coercive behavior:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-string\">\"42\"</span>;  <span class=\"hljs-built_in\">isFinite</span>( a );                        <span class=\"hljs-comment\">// true</span> <span class=\"hljs-built_in\">Number</span>.isFinite( a );                <span class=\"hljs-comment\">// false</span> </code></pre> <p>You may still prefer the coercion, in which case using the global <code>isFinite(..)</code> is a valid choice. Alternatively, and perhaps more sensibly, you can use <code>Number.isFinite(+x)</code>, which explicitly coerces <code>x</code> to a number before passing it in (see Chapter 4 of the <em>Types &amp; Grammar</em> title of this series).</p> <h3 id=\"integer-related-static-functions\">Integer-Related Static Functions</h3> <p>JavaScript number valuess are always floating point (IEE-754). So the notion of determining if a number is an &quot;integer&quot; is not about checking its type, because JS makes no such distinction.</p> <p>Instead, you need to check if there&#39;s any non-zero decimal portion of the value. The easiest way to do that has commonly been:</p> <pre><code class=\"lang-js\">x === Math.<span class=\"hljs-built_in\">floor</span>( x )<span class=\"hljs-comment\">;</span> </code></pre> <p>ES6 adds a <code>Number.isInteger(..)</code> helper utility that potentially can determine this quality slightly more efficiently:</p> <pre><code class=\"lang-js\">Number.isInteger( <span class=\"hljs-number\">4</span> );                <span class=\"hljs-comment\">// true</span> Number.isInteger( <span class=\"hljs-number\">4.2</span> );            <span class=\"hljs-comment\">// false</span> </code></pre> <p><strong>Note:</strong> In JavaScript, there&#39;s no difference between <code>4</code>, <code>4.</code>, <code>4.0</code>, or <code>4.0000</code>. All of these would be considered an &quot;integer&quot;, and would thus yield <code>true</code> from <code>Number.isInteger(..)</code>.</p> <p>In addition, <code>Number.isInteger(..)</code> filters out some clearly not-integer values that <code>x === Math.floor(x)</code> could potentially mix up:</p> <pre><code class=\"lang-js\"><span class=\"hljs-built_in\">Number</span>.isInteger( <span class=\"hljs-literal\">NaN</span> );            <span class=\"hljs-comment\">// false</span> <span class=\"hljs-built_in\">Number</span>.isInteger( <span class=\"hljs-literal\">Infinity</span> );        <span class=\"hljs-comment\">// false</span> </code></pre> <p>Working with &quot;integers&quot; is sometimes an important bit of information, as it can simplify certain kinds of algorithms. JS code by itself will not run faster just from filtering for only integers, but there are optimization techniques the engine can take (e.g., asm.js) when only integers are being used.</p> <p>Because of <code>Number.isInteger(..)</code>&#39;s handling of <code>NaN</code> and <code>Infinity</code> values, defining a <code>isFloat(..)</code> utility would not be just as simple as <code>!Number.isInteger(..)</code>. You&#39;d need to do something like:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">isFloat</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Number</span>.isFinite( x ) &amp;&amp; !<span class=\"hljs-built_in\">Number</span>.isInteger( x ); }  isFloat( <span class=\"hljs-number\">4.2</span> );                        <span class=\"hljs-comment\">// true</span> isFloat( <span class=\"hljs-number\">4</span> );                        <span class=\"hljs-comment\">// false</span>  isFloat( <span class=\"hljs-literal\">NaN</span> );                        <span class=\"hljs-comment\">// false</span> isFloat( <span class=\"hljs-literal\">Infinity</span> );                <span class=\"hljs-comment\">// false</span> </code></pre> <p><strong>Note:</strong> It may seem strange, but Infinity should neither be considered an integer nor a float.</p> <p>ES6 also defines a <code>Number.isSafeInteger(..)</code> utility, which checks to make sure the value is both an integer and within the range of <code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code> (inclusive).</p> <pre><code class=\"lang-js\">var x = Math.<span class=\"hljs-built_in\">pow</span>( <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">53</span> ),     y = Math.<span class=\"hljs-built_in\">pow</span>( -<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">53</span> );  Number.isSafeInteger( x - <span class=\"hljs-number\">1</span> );        <span class=\"hljs-comment\">// true</span> Number.isSafeInteger( y + <span class=\"hljs-number\">1</span> );        <span class=\"hljs-comment\">// true</span>  Number.isSafeInteger( x );            <span class=\"hljs-comment\">// false</span> Number.isSafeInteger( y );            <span class=\"hljs-comment\">// false</span> </code></pre> <h2 id=\"-string-\"><code>String</code></h2> <p>Strings already have quite a few helpers prior to ES6, but even more have been added to the mix.</p> <h3 id=\"unicode-functions\">Unicode Functions</h3> <p>&quot;Unicode-Aware String Operations&quot; in Chapter 2 discusses <code>String.fromCodePoint(..)</code>, <code>String#codePointAt(..)</code>, and <code>String#normalize(..)</code> in detail. They have been added to improve Unicode support in JS string values.</p> <pre><code class=\"lang-js\">String.fromCodePoint( <span class=\"hljs-number\">0x1d49e</span> );            <span class=\"hljs-comment\">// \"\"</span>  <span class=\"hljs-string\">\"abd\"</span>.codePointAt( <span class=\"hljs-number\">2</span> ).toString( <span class=\"hljs-number\">16</span> );        <span class=\"hljs-comment\">// \"1d49e\"</span> </code></pre> <p>The <code>normalize(..)</code> string prototype method is used to perform Unicode normalizations that either combine characters with adjacent &quot;combining marks&quot; or decompose combined characters.</p> <p>Generally, the normalization won&#39;t create a visible effect on the contents of the string, but will change the contents of the string, which can affect how things like the <code>length</code> property are reported, as well as how character access by position behave:</p> <pre><code class=\"lang-js\"><span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> s1</span> = <span class=\"hljs-string\">\"e\\u0301\"</span>; s1.length;                            <span class=\"hljs-comment\">// 2</span>  <span class=\"hljs-variable\"><span class=\"hljs-keyword\">var</span> s2</span> = s1.normalize(); s2.length;                            <span class=\"hljs-comment\">// 1</span> s2 === <span class=\"hljs-string\">\"\\xE9\"</span>;                        <span class=\"hljs-comment\">// true</span> </code></pre> <p><code>normalize(..)</code> takes an optional argument that specifies the normalization form to use. This argument must be one of the following four values: <code>&quot;NFC&quot;</code> (default), <code>&quot;NFD&quot;</code>, <code>&quot;NFKC&quot;</code>, or <code>&quot;NFKD&quot;</code>.</p> <p><strong>Note:</strong> Normalization forms and their effects on strings is well beyond the scope of what we&#39;ll discuss here. See &quot;Unicode Normalization Forms&quot; (<a href=\"http://www.unicode.org/reports/tr15/\">http://www.unicode.org/reports/tr15/</a>) for more information.</p> <h3 id=\"-string-raw-static-function\"><code>String.raw(..)</code> Static Function</h3> <p>The <code>String.raw(..)</code> utility is provided as a built-in tag function to use with template string literals (see Chapter 2) for obtaining the raw string value without any processing of escape sequences.</p> <p>This function will almost never be called manually, but will be used with tagged template literals:</p> <pre><code class=\"lang-js\">var str = <span class=\"hljs-string\">\"bc\"</span><span class=\"hljs-comment\">;</span>  String.raw<span class=\"hljs-escape\">`\\</span>ta${str}d\\xE9<span class=\"hljs-escape\">`;</span> // <span class=\"hljs-string\">\"\\tabcd\\xE9\"</span>, <span class=\"hljs-literal\">not</span> <span class=\"hljs-string\">\"    abcd\"</span> </code></pre> <p>In the resultant string, <code>\\</code> and <code>t</code> are separate raw characters, not the one escape sequence character <code>\\t</code>. The same is true with the Unicode escape sequence.</p> <h3 id=\"-repeat-prototype-function\"><code>repeat(..)</code> Prototype Function</h3> <p>In languages like Python and Ruby, you can repeat a string as:</p> <pre><code class=\"lang-js\"><span class=\"hljs-string\">\"foo\"</span> * <span class=\"hljs-number\">3</span>;                            <span class=\"hljs-comment\">// \"foofoofoo\"</span> </code></pre> <p>That doesn&#39;t work in JS, because <code>*</code> multiplication is only defined for numbers, and thus <code>&quot;foo&quot;</code> coerces to the <code>NaN</code> number.</p> <p>However, ES6 defines a string prototype method <code>repeat(..)</code> to accomplish the task:</p> <pre><code class=\"lang-js\"><span class=\"hljs-string\">\"foo\"</span>.<span class=\"hljs-keyword\">repeat</span><span class=\"hljs-comment\">( 3 )</span>;                    <span class=\"hljs-comment\">// \"foofoofoo\"</span> </code></pre> <h3 id=\"string-inspection-functions\">String Inspection Functions</h3> <p>In addition to <code>String#indexOf(..)</code> and <code>String#lastIndexOf(..)</code> from prior to ES6, three new methods for searching/inspection have been added: <code>startsWith(..)</code>, <code>endsWidth(..)</code>, and <code>includes(..)</code>.</p> <pre><code class=\"lang-js\">var palindrome = <span class=\"hljs-string\">\"step on no pets\"</span>;  palindrome.startsWith( <span class=\"hljs-string\">\"step on\"</span> );    <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span> palindrome.startsWith( <span class=\"hljs-string\">\"on\"</span>, <span class=\"hljs-number\">5</span> );    <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span>  palindrome.endsWith( <span class=\"hljs-string\">\"no pets\"</span> );    <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span> palindrome.endsWith( <span class=\"hljs-string\">\"no\"</span>, <span class=\"hljs-number\">10</span> );    <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span>  palindrome.includes( <span class=\"hljs-string\">\"on\"</span> );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">true</span> palindrome.includes( <span class=\"hljs-string\">\"on\"</span>, <span class=\"hljs-number\">6</span> );        <span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">false</span> </code></pre> <p>For all the string search/inspection methods, if you look for an empty string <code>&quot;&quot;</code>, it will either be found at the beginning or the end of the string.</p> <p><strong>Warning:</strong> These methods will not by default accept a regular expression for the search string. See &quot;Regular Expression Symbols&quot; in Chapter 7 for information about disabling the <code>isRegExp</code> check that is performed on this first argument.</p> <h2 id=\"review\">Review</h2> <p>ES6 adds many extra API helpers on the various built-in native objects:</p> <ul> <li><code>Array</code> adds <code>of(..)</code> and <code>from(..)</code> static functions, as well as prototype functions like <code>copyWithin(..)</code> and <code>fill(..)</code>.</li> <li><code>Object</code> adds static functions like <code>is(..)</code> and <code>assign(..)</code>.</li> <li><code>Math</code> adds static functions like <code>acosh(..)</code> and <code>clz32(..)</code>.</li> <li><code>Number</code> adds static properties like <code>Number.EPSILON</code>, as well as static functions like <code>Number.isFinite(..)</code>.</li> <li><code>String</code> adds static functions like <code>String.fromCodePoint(..)</code> and <code>String.raw(..)</code>, as well as prototype functions like <code>repeat(..)</code> and <code>includes(..)</code>.</li> </ul> <p>Most of these additions can be polyfilled (see ES6 Shim), and were inspired by utilities in common JS libraries/frameworks.</p> ","title":"You Don't Know JS: ES6 & Beyond"},"ch7":{"body":"<h1 id=\"chapter-7-meta-programming\">Chapter 7: Meta Programming</h1> <p>Meta programming is programming where the operation targets the behavior of the program itself. In other words, it&#39;s programming the programming of your program. Yeah, a mouthful, huh?</p> <p>For example, if you probe the relationship between one object <code>a</code> and another <code>b</code> -- are they <code>[[Prototype]]</code> linked? -- using <code>a.isPrototype(b)</code>, this is commonly referred to as introspection, a form of meta programming. Macros (which don&#39;t exist in JS, yet) --  where the code modifies itself at compile time -- are another obvious example of meta programming. Enumerating the keys of an object with a <code>for..in</code> loop, or checking if an object is an <em>instance of</em> a &quot;class constructor&quot;, are other common meta programming tasks.</p> <p>Meta programming focuses on one or more of the following: code inspecting itself, code modifying itself, or code modifying default language behavior so other code is affected.</p> <p>The goal of meta programming is to leverage the language&#39;s own intrinsic capabilities to make the rest of your code more descriptive, expressive, and/or flexible. Because of the <em>meta</em> nature of meta programming, it&#39;s somewhat difficult to put a more precise definition on it than that. The best way to understand meta programming is to see it through examples.</p> <p>ES6 adds several new forms/features for meta programming on top of what JS already had.</p> <h2 id=\"function-names\">Function Names</h2> <p>There are cases where your code may want to introspect on itself and ask what the name of some function is. If you ask what a function&#39;s name is, the answer is surprisingly somewhat ambiguous. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">daz</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-comment\">// ..</span> }  <span class=\"hljs-keyword\">var</span> obj = {     foo: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{         <span class=\"hljs-comment\">// ..</span>     },     bar: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">baz</span><span class=\"hljs-params\">()</span> </span>{         <span class=\"hljs-comment\">// ..</span>     },     bam: daz,     zim() {         <span class=\"hljs-comment\">// ..</span>     } }; </code></pre> <p>In this previous snippet, &quot;what is the name of <code>obj.foo()</code>&quot; is slightly nuanced. Is it <code>&quot;foo&quot;</code>, <code>&quot;&quot;</code>, or <code>undefined</code>? And what about <code>obj.bar()</code> -- is it named <code>&quot;bar&quot;</code> or <code>&quot;baz&quot;</code>? Is <code>obj.bam()</code> named <code>&quot;bam&quot;</code> or <code>&quot;daz&quot;</code>? What about <code>obj.zim()</code>?</p> <p>Moreover, what about functions which are passed as callbacks, like:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(cb)</span> </span>{     <span class=\"hljs-comment\">// what is the name of `cb()` here?</span> }  foo( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span></span>{     <span class=\"hljs-comment\">// I'm anonymous!</span> } ); </code></pre> <p>There are quite a few ways that functions can be expressed in programs, and it&#39;s not always clear and unambiguous what the &quot;name&quot; of that function should be.</p> <p>More importantly, we need to distinguish whether the &quot;name&quot; of a function refers to its <code>name</code> property -- yes, functions have a property called <code>name</code> -- or whether it refers to the lexical binding name, such as <code>bar</code> in <code>function bar() { .. }</code>.</p> <p>The lexical binding name is what you use for things like recursion:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span><span class=\"hljs-params\">(i)</span> {</span>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">i</span> &lt; <span class=\"hljs-number\">10</span>) <span class=\"hljs-keyword\">return</span> foo( <span class=\"hljs-built_in\">i</span> * <span class=\"hljs-number\">2</span> );     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">i</span>; } </code></pre> <p>The <code>name</code> property is what you&#39;d use for meta programming purposes, so that&#39;s what we&#39;ll focus on in this discussion.</p> <p>The confusion comes because by default, the lexical name a function has (if any) is also set as its <code>name</code> property. Actually there was no official requirement for that behavior by the ES5 (and prior) specifications. The setting of the <code>name</code> property was nonstandard but still fairly reliable. As of ES6, it has been standardized.</p> <p><strong>Tip:</strong> If a function has a <code>name</code> value assigned, that&#39;s typically the name used in stack traces in developer tools.</p> <h3 id=\"inferences\">Inferences</h3> <p>But what happens to the <code>name</code> property if a function has no lexical name?</p> <p>As of ES6, there are now inference rules which can determine a sensible <code>name</code> property value to assign a function even if that function doesn&#39;t have a lexical name to use.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> abc = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> </span>{     <span class=\"hljs-comment\">// ..</span> };  abc.name;                <span class=\"hljs-comment\">// \"abc\"</span> </code></pre> <p>Had we given the function a lexical name like <code>abc = function def() { .. }</code>, the <code>name</code> property would of course be <code>&quot;def&quot;</code>. But in the absence of the lexical name, intuitively the <code>&quot;abc&quot;</code> name seems appropriate.</p> <p>Here are other forms that will infer a name (or not) in ES6:</p> <pre><code class=\"lang-js\">(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ .. });                    <span class=\"hljs-comment\">// name:</span> (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>)</span>{ .. });                <span class=\"hljs-comment\">// name:</span> <span class=\"hljs-built_in\">window</span>.foo = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ .. };        <span class=\"hljs-comment\">// name:</span>  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Awesome</span> </span>{     constructor() { .. }            <span class=\"hljs-comment\">// name: Awesome</span>     funny() { .. }                    <span class=\"hljs-comment\">// name: funny</span> }  <span class=\"hljs-keyword\">var</span> c = <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Awesome</span> </span>{ .. };        <span class=\"hljs-comment\">// name: Awesome</span>  <span class=\"hljs-keyword\">var</span> o = {     foo() { .. },                    <span class=\"hljs-comment\">// name: foo</span>     *bar() { .. },                    <span class=\"hljs-comment\">// name: bar</span>     baz: () =&gt; { .. },                <span class=\"hljs-comment\">// name: baz</span>     bam: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ .. },            <span class=\"hljs-comment\">// name: bam</span>     get qux() { .. },                <span class=\"hljs-comment\">// name: get qux</span>     set fuz() { .. },                <span class=\"hljs-comment\">// name: set fuz</span>     [<span class=\"hljs-string\">\"b\"</span> + <span class=\"hljs-string\">\"iz\"</span>]:         <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ .. },            <span class=\"hljs-comment\">// name: biz</span>     [<span class=\"hljs-built_in\">Symbol</span>( <span class=\"hljs-string\">\"buz\"</span> )]:         <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ .. }            <span class=\"hljs-comment\">// name: [buz]</span> };  <span class=\"hljs-keyword\">var</span> x = o.foo.bind( o );            <span class=\"hljs-comment\">// name: bound foo</span> (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{ .. }).bind( o );        <span class=\"hljs-comment\">// name: bound</span>  <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{ .. }    <span class=\"hljs-comment\">// name: default</span>  <span class=\"hljs-keyword\">var</span> y = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Function</span>();                <span class=\"hljs-comment\">// name: anonymous</span> <span class=\"hljs-keyword\">var</span> GeneratorFunction =     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>*(<span class=\"hljs-params\"></span>)</span>{}.__proto__.constructor; <span class=\"hljs-keyword\">var</span> z = <span class=\"hljs-keyword\">new</span> GeneratorFunction();    <span class=\"hljs-comment\">// name: anonymous</span> </code></pre> <p>The <code>name</code> property is not writable by default, but it is configurable, meaning you can use <code>Object.defineProperty(..)</code> to manually change it if so desired.</p> <h2 id=\"meta-properties\">Meta Properties</h2> <p>In the &quot;<code>new.target</code>&quot; section of Chapter 3, we introduced a concept new to JS in ES6: the meta property. As the name suggests, meta properties are intended to provide special meta information in the form of a property access that would otherwise not have been possible.</p> <p>In the case of <code>new.target</code>, the keyword <code>new</code> serves as the context for a property access. Clearly <code>new</code> is itself not an object, which makes this capability special. However, when <code>new.target</code> is used inside a constructor call (a function/method invoked with <code>new</code>), <code>new</code> becomes a virtual context, so that <code>new.target</code> can refer to the target constructor that <code>new</code> invoked.</p> <p>This is a clear example of a meta programming operation, as the intent is to determine from inside a constructor call what the original <code>new</code> target was, generally for the purposes of introspection (examining typing/structure) or static property access.</p> <p>For example, you may want to have different behavior in a constructor depending on if it&#39;s directly invoked or invoked via a child class:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Parent</span> {</span>     constructor() {         <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">new</span>.target === <span class=\"hljs-type\">Parent</span>) {             console.log( <span class=\"hljs-string\">\"Parent instantiated\"</span> );         }         <span class=\"hljs-keyword\">else</span> {             console.log( <span class=\"hljs-string\">\"A child instantiated\"</span> );         }     } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Child</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Parent</span> {</span>}  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Parent</span>(); <span class=\"hljs-comment\">// Parent instantiated</span>  <span class=\"hljs-keyword\">var</span> b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Child</span>(); <span class=\"hljs-comment\">// A child instantiated</span> </code></pre> <p>There&#39;s a slight nuance here, which is that the <code>constructor()</code> inside the <code>Parent</code> class definition is actually given the lexical name of the class (<code>Parent</code>), even though the syntax implies that the class is a separate entity from the constructor.</p> <p><strong>Warning:</strong> As with all meta programming techniques, be careful of creating code that&#39;s too clever for your future self or others maintaining your code to understand. Use these tricks with caution.</p> <h2 id=\"well-known-symbols\">Well Known Symbols</h2> <p>In the &quot;Symbols&quot; section of Chapter 2, we covered the new ES6 primitive type <code>symbol</code>. In addition to symbols you can define in your own program, JS predefines a number of built-in symbols, referred to as <em>Well Known Symbols</em> (WKS).</p> <p>These symbol values are defined primarily to expose special meta properties that are being exposed to your JS programs to give you more control over JS&#39;s behavior.</p> <p>We&#39;ll briefly introduce each and discuss their purpose.</p> <h3 id=\"-symbol-iterator-\"><code>Symbol.iterator</code></h3> <p>In Chapters 2 and 3, we introduced and used the <code>@@iterator</code> symbol, automatically used by <code>...</code> spreads and <code>for..of</code> loops. We also saw <code>@@iterator</code> as defined on the new ES6 collections as defined in Chapter 5.</p> <p><code>Symbol.iterator</code> represents the special location (property) on any object where the language mechanisms automatically look to find a method that will construct an iterator instance for consuming that object&#39;s values. Many objects come with a default one defined.</p> <p>However, we can define our own iterator logic for any object value by setting the <code>Symbol.iterator</code> property, even if that&#39;s overriding the default iterator. The meta programming aspect is that we are defining behavior which other parts of JS (namely, operators and looping constructs) use when processing an object value we define.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> arr = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">9</span>];  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> arr) {     console.log( v ); } // <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span>  // define <span class=\"hljs-keyword\">iterator</span> that only produces values // <span class=\"hljs-keyword\">from</span> odd indexes arr[<span class=\"hljs-type\">Symbol</span>.<span class=\"hljs-keyword\">iterator</span>] = function*() {     <span class=\"hljs-keyword\">var</span> idx = <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">do</span> {         <span class=\"hljs-keyword\">yield</span> this[idx];     } <span class=\"hljs-keyword\">while</span> ((idx += <span class=\"hljs-number\">2</span>) &lt; this.length); };  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">of</span> arr) {     console.log( v ); } // <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">9</span> </code></pre> <h3 id=\"-symbol-tostringtag-and-symbol-hasinstance-\"><code>Symbol.toStringTag</code> and <code>Symbol.hasInstance</code></h3> <p>One of the most common meta programming tasks is to introspect on a value to find out what <em>kind</em> it is, usually to decide what operations are appropriate to perform on it. With objects, the two most common inspection techniques are <code>toString()</code> and <code>instanceof</code>.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foo</span><span class=\"hljs-params\">()</span> </span>{}  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> Foo();  a.toString();                <span class=\"hljs-comment\">// [object Object]</span> a <span class=\"hljs-keyword\">instanceof</span> Foo;            <span class=\"hljs-comment\">// true</span> </code></pre> <p>As of ES6, you can control the behavior of these operations:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Foo</span>(<span class=\"hljs-params\">greeting</span>) </span>{     <span class=\"hljs-keyword\">this</span>.greeting = greeting; }  Foo.prototype[<span class=\"hljs-built_in\">Symbol</span>.toStringTag] = <span class=\"hljs-string\">\"Foo\"</span>;  <span class=\"hljs-built_in\">Object</span>.defineProperty( Foo, <span class=\"hljs-built_in\">Symbol</span>.hasInstance, {     value: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">inst</span>) </span>{         <span class=\"hljs-keyword\">return</span> inst.greeting == <span class=\"hljs-string\">\"hello\"</span>;     } } );  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> Foo( <span class=\"hljs-string\">\"hello\"</span> ),     b = <span class=\"hljs-keyword\">new</span> Foo( <span class=\"hljs-string\">\"world\"</span> );  b[<span class=\"hljs-built_in\">Symbol</span>.toStringTag] = <span class=\"hljs-string\">\"cool\"</span>;  a.toString();                <span class=\"hljs-comment\">// [object Foo]</span> <span class=\"hljs-built_in\">String</span>( b );                <span class=\"hljs-comment\">// [object cool]</span>  a <span class=\"hljs-keyword\">instanceof</span> Foo;            <span class=\"hljs-comment\">// true</span> b <span class=\"hljs-keyword\">instanceof</span> Foo;            <span class=\"hljs-comment\">// false</span> </code></pre> <p>The <code>@@toStringTag</code> symbol on the prototype (or instance itself) specifies a string value to use in the <code>[object ___]</code> stringification.</p> <p>The <code>@@hasInstance</code> symbol is a method on the constructor function which receives the instance object value and lets you decide by returning <code>true</code> or <code>false</code> if the value should be considered an instance or not.</p> <p><strong>Note:</strong> To set <code>@@hasInstance</code> on a function, you must use <code>Object.defineProperty(..)</code>, as the default one on <code>Function.prototype</code> is <code>writable: false</code>. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</p> <h3 id=\"-symbol-species-\"><code>Symbol.species</code></h3> <p>In &quot;Classes&quot; in Chapter 3, we introduced the <code>@@species</code> symbol, which controls which constructor is used by built-in methods of a class that needs to spawn new instances.</p> <p>The most common example is when subclassing <code>Array</code> and wanting to define which constructor (<code>Array(..)</code> or your subclass) inherited methods like <code>slice(..)</code> should use. By default, <code>slice(..)</code> called on an instance of a subclass of <code>Array</code> would produce a new instance of that subclass, which is frankly what you&#39;ll likely often want.</p> <p>However, you can meta program by overriding a class&#39;s default <code>@@species</code> definition:</p> <pre><code class=\"lang-js\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cool</span> {</span>     <span class=\"hljs-comment\">// defer `@@species` to derived constructor</span>     static get [<span class=\"hljs-type\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>; }      again() {         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">this</span>.constructor[<span class=\"hljs-type\">Symbol</span>.species]();     } }  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Fun</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Cool</span> {</span>}  <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Awesome</span> <span class=\"hljs-keyword\"><span class=\"hljs-keyword\">extends</span></span> <span class=\"hljs-title\">Cool</span> {</span>     <span class=\"hljs-comment\">// force `@@species` to be parent constructor</span>     static get [<span class=\"hljs-type\">Symbol</span>.species]() { <span class=\"hljs-keyword\">return</span> <span class=\"hljs-type\">Cool</span>; } }  <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Fun</span>(),     b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Awesome</span>(),     c = a.again(),     d = b.again();  c instanceof <span class=\"hljs-type\">Fun</span>;            <span class=\"hljs-comment\">// true</span> d instanceof <span class=\"hljs-type\">Awesome</span>;        <span class=\"hljs-comment\">// false</span> d instanceof <span class=\"hljs-type\">Cool</span>;            <span class=\"hljs-comment\">// true</span> </code></pre> <p>The <code>Symbol.species</code> setting defaults on the built-in native constructors to the <code>return this</code> behavior as illustrated in the previous snippet in the <code>Cool</code> definition. It has no default on user classes, but as shown that behaivor is easy to emulate.</p> <p>If you need to define methods that generate new instances, use the meta programming of the <code>new this.constructor[Symbol.species](..)</code> pattern instead of the hard-wiring of <code>new this.constructor(..)</code> or <code>new XYZ(..)</code>. Derived classes will then be able to customize <code>Symbol.species</code> to control which constructor vends those instances.</p> <h3 id=\"-symbol-toprimitive-\"><code>Symbol.toPrimitive</code></h3> <p>In the <em>Types &amp; Grammar</em> title of this series, we discussed the <code>ToPrimitive</code> abstract coercion operation, which is used when an object must be coerced to a primitive value for some operation (such as <code>==</code> comparison or <code>+</code> addition). Prior to ES6, there was no way to control this behavior.</p> <p>As of ES6, the <code>@@toPrimitive</code> symbol as a property on any object value can customize that <code>ToPrimitive</code> coercion by specifying a method.</p> <p>Consider:</p> <pre><code class=\"lang-js\">var arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>];  arr + <span class=\"hljs-number\">10</span>;                <span class=\"hljs-comment\">// 1,2,3,4,510</span>  arr[Symbol.toPrimitive] = function(hint) {     <span class=\"hljs-keyword\">if</span> (hint == <span class=\"hljs-string\">\"default\"</span> || hint == <span class=\"hljs-string\">\"number\"</span>) {         <span class=\"hljs-comment\">// sum all numbers</span>         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.reduce( function(acc,curr){             <span class=\"hljs-keyword\">return</span> acc + curr;         }, <span class=\"hljs-number\">0</span> );     } };  arr + <span class=\"hljs-number\">10</span>;                <span class=\"hljs-comment\">// 25</span> </code></pre> <p>The <code>Symbol.toPrimitive</code> method will be provided with a <em>hint</em> of <code>&quot;string&quot;</code>, <code>&quot;number&quot;</code>, or <code>&quot;default&quot;</code> (which should be interpreted as <code>&quot;number&quot;</code>), depending on what type the operation invoking <code>ToPrimitive</code> is expecting. In the previous snippet, the additive <code>+</code> operation has no hint (<code>&quot;default&quot;</code> is passed). A multiplicative <code>*</code> operation would hint <code>&quot;number&quot;</code> and a <code>String(arr)</code> would hint <code>&quot;string&quot;</code>.</p> <p><strong>Warning:</strong> The <code>==</code> operator will invoke the <code>ToPrimitive</code> operation with no hint -- the <code>@@toPrimitive</code> method, if any is called with hint <code>&quot;default&quot;</code> -- on an object if the other value being compared is not an object. However, if both comparison values are objects, the behavior of <code>==</code> is identical to <code>===</code>, which is that the references themselves are directly compared. In this case, <code>@@toPrimitive</code> is not invoked at all. See the <em>Types &amp; Grammar</em> title of this series for more information about coercion and the abstract operations.</p> <h3 id=\"regular-expression-symbols\">Regular Expression Symbols</h3> <p>There are four well known symbols that can be overridden for regular expression objects, which control how those regular expressions are used by the four corresponding <code>String.prototype</code> functions of the same name:</p> <ul> <li><p><code>@@match</code>: The <code>Symbol.match</code> value of a regular expression is the method used to match all or part of a string value with the given regular expression. It&#39;s used by <code>String.prototype.match(..)</code> if you pass it a regular expression for the pattern matching.</p> <p> The default algorithm for matching is laid out in section 21.2.5.6 of the ES6 specification (<a href=\"https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@match\">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@match</a>). You could override this default algorithm and provide extra regex features, such as look-behind assertions.</p> <p> <code>Symbol.match</code> is also used by the <code>isRegExp</code> abstract operation (see the note in &quot;String Inspection Functions&quot; in Chapter 6) to determine if an object is intended to be used as a regular expression. To force this check to fail for an object so it&#39;s not treated as a regular expression, set the <code>Symbol.match</code> value to <code>false</code> (or something falsy).</p> </li> <li><p><code>@@replace</code>: The <code>Symbol.replace</code> value of a regular expression is the method used by <code>String.prototype.replace(..)</code> to replace within a string one or all occurrences of character sequences that match the given regular expression pattern.</p> <p> The default algorithm for replacing is laid out in section 21.2.5.8 of the ES6 specification (<a href=\"https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@replace\">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@replace</a>).</p> <p> One cool use for overriding the default algorithm is to provide additional <code>replacer</code> argument options, such as supporting <code>&quot;abaca&quot;.replace(/a/g,[1,2,3])</code> producing <code>&quot;1b2c3&quot;</code> by consuming the iterable for successive replacement values.</p> </li> <li><p><code>@@search</code>: The <code>Symbol.search</code> value of a regular expression is the method used by <code>String.prototype.search(..)</code> to search for a sub-string within another string as matched by the given regular expression.</p> <p> The default algorithm for searching is laid out in section 21.2.5.9 of the ES6 specification (<a href=\"https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@search\">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@search</a>).</p> </li> <li><p><code>@@split</code>: The <code>Symbol.split</code> value of a regular expression is the method used by <code>String.prototype.split(..)</code> to split a string into sub-strings at the location(s) of the delimiter as matched by the given regular expression.</p> <p> The default algorithm for splitting is laid out in section 21.2.5.11 of the ES6 specification (<a href=\"https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@split\">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-regexp.prototype-@@split</a>).</p> </li> </ul> <p>Overriding the built-in regular expression algorithms is not for the faint of heart! JS ships with a highly optimized regular expression engine, so your own user code will likely be a lot slower. This kind of meta programming is neat and powerful, but it should only be used in cases where it&#39;s really necessary or beneficial.</p> <h3 id=\"-symbol-isconcatspreadable-\"><code>Symbol.isConcatSpreadable</code></h3> <p>The <code>@@isConcatSpreadable</code> symbol can be defined as a boolean property (<code>Symbol.isConcatSpreadable</code>) on any object (like an array or other iterable) to indicate if it should be <em>spread out</em> if passed to an array <code>concat(..)</code>.</p> <p>Consider:</p> <pre><code class=\"lang-js\">var a = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>],     b = [<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">6</span>];  b[Symbol.isConcatSpreadable] = <span class=\"hljs-literal\">false</span>;  [].concat( a, b );        <span class=\"hljs-comment\">// [1,2,3,[4,5,6]]</span> </code></pre> <h3 id=\"-symbol-unscopables-\"><code>Symbol.unscopables</code></h3> <p>The <code>@@unscopables</code> symbol can be defined as an object property (<code>Symbol.unscopables</code>) on any object to indicate which properties can and cannot be exposed as lexical variables in a <code>with</code> statement.</p> <p>Consider:</p> <pre><code class=\"lang-js\">var o = { a:<span class=\"hljs-number\">1</span>, b:<span class=\"hljs-number\">2</span>, c:<span class=\"hljs-number\">3</span> },     a = <span class=\"hljs-number\">10</span>, b = <span class=\"hljs-number\">20</span>, c = <span class=\"hljs-number\">30</span>;  o[Symbol.unscopables] = {     a: <span class=\"hljs-literal\">false</span>,     b: <span class=\"hljs-literal\">true</span>,     c: <span class=\"hljs-literal\">false</span> };  with (o) {     console.<span class=\"hljs-built_in\">log</span>( a, b, c );        <span class=\"hljs-comment\">// 1 20 3</span> } </code></pre> <p>A <code>true</code> in the <code>@@unscopables</code> object indicates the property should be <em>unscopable</em>, and thus filtered out from the lexical scope variables. <code>false</code> means it&#39;s OK to be included in the lexical scope variables.</p> <p><strong>Warning:</strong> The <code>with</code> statement is disallowed entirely in <code>strict</code> mode, and as such should be considered deprecated from the language. Don&#39;t use it. See the <em>Scope &amp; Closures</em> title of this series for more information. Because <code>with</code> should be avoided, the <code>@@unscopables</code> symbol is also moot.</p> <h2 id=\"proxies\">Proxies</h2> <p>One of the most obviously meta programming features added to ES6 is the <code>Proxy</code> feature.</p> <p>A proxy is a special kind of object you create that &quot;wraps&quot; -- or sits in front of -- another normal object. You can register special handlers (aka <em>traps</em>) on the proxy object which are called when various operations are performed against the proxy. These handlers have the opportunity to perform extra logic in addition to <em>forwarding</em> the operations on to the original target/wrapped object.</p> <p>One example of the kind of <em>trap</em> handler you can define on a proxy is <code>get</code> that intercepts the <code>[[Get]]</code> operation -- performed when you try to access a property on an object. Consider:</p> <pre><code class=\"lang-js\">var obj = { a: <span class=\"hljs-number\">1</span> },     handlers = {         <span class=\"hljs-built_in\">get</span>(target,<span class=\"hljs-variable\">key</span>,context) {             <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">note:</span> target === obj,</span>             <span class=\"hljs-comment\">// context === pobj</span>             console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"accessing: \"</span>, <span class=\"hljs-variable\">key</span> );             <span class=\"hljs-keyword\">return</span> Reflect.<span class=\"hljs-built_in\">get</span>(                 target, <span class=\"hljs-variable\">key</span>, context             );         }     },     pobj = <span class=\"hljs-keyword\">new</span> Proxy( obj, handlers );  obj.a; <span class=\"hljs-comment\">// 1</span>  pobj.a; <span class=\"hljs-comment\">// accessing: a</span> <span class=\"hljs-comment\">// 1</span> </code></pre> <p>We declare a <code>get(..)</code> handler as a named method on the <em>handler</em> object (second argument to <code>Proxy(..)</code>), which receives a reference to the <em>target</em> object (<code>obj</code>), the <em>key</em> property name (<code>&quot;a&quot;</code>), and the <code>self</code>/receiver/proxy (<code>pobj</code>).</p> <p>After the <code>console.log(..)</code> tracing statement, we &quot;forward&quot; the operation onto <code>obj</code> via <code>Reflect.get(..)</code>. We will cover the <code>Reflect</code> API in the next section, but note that each available proxy trap has a corresponding <code>Reflect</code> function of the same name.</p> <p>These mappings are symmetric on purpose. The proxy handlers each intercept when a respective meta programming task is performed, and the <code>Reflect</code> utilities each perform the respective meta programming task on an object. Each proxy handler has a default definition that automatically calls the corresponding <code>Reflect</code> utility. You will almost certainly use both <code>Proxy</code> and <code>Reflect</code> in tandem.</p> <p>Here&#39;s a list of handlers you can define on a proxy for a <em>target</em> object/function, and how/when they are triggered:</p> <ul> <li><code>get(..)</code>: via <code>[[Get]]</code>, a property is accessed on the proxy (<code>Reflect.get(..)</code>, <code>.</code> property operator, or <code>[ .. ]</code> property operator)</li> <li><code>set(..)</code>: via <code>[[Set]]</code>, a property value is set on the proxy (<code>Reflect.set(..)</code>, the <code>=</code> assignment operator, or destructuring assignment if it targets an object property)</li> <li><code>deleteProperty(..)</code>: via <code>[[Delete]]</code>, a property is deleted from the proxy (<code>Reflect.deleteProperty(..)</code> or <code>delete</code>)</li> <li><code>apply(..)</code> (if <em>target</em> is a function): via <code>[[Call]]</code>, the proxy is invoked as a normal function/method (<code>Reflect.apply(..)</code>, <code>call(..)</code>, <code>apply(..)</code>, or the <code>(..)</code> call operator)</li> <li><code>construct(..)</code> (if <em>target</em> is a constructor function): via <code>[[Construct]]</code>, the proxy is invoked as a constructor function (<code>Reflect.construct(..)</code> or <code>new</code>)</li> <li><code>getOwnPropertyDescriptor(..)</code>: via <code>[[GetOwnProperty]]</code>, a property descriptor is retrieved from the proxy (<code>Object.getOwnPropertyDescriptor(..)</code> or <code>Reflect.getOwnPropertyDescriptor(..)</code>)</li> <li><code>defineProperty(..)</code>: via <code>[[DefineOwnProperty]]</code>, a property descriptor is set on the proxy (<code>Object.defineProperty(..)</code> or <code>Reflect.defineProperty(..)</code>)</li> <li><code>getPrototypeOf(..)</code>: via <code>[[GetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is retrieved (<code>Object.getPrototypeOf(..)</code>, <code>Reflect.getPrototypeOf(..)</code>, <code>__proto__</code>, <code>Object#isPrototypeOf(..)</code>, or <code>instanceof</code>)</li> <li><code>setPrototypeOf(..)</code>: via <code>[[SetPrototypeOf]]</code>, the <code>[[Prototype]]</code> of the proxy is set (<code>Object.setPrototypeOf(..)</code>, <code>Reflect.setPrototypeOf(..)</code>, or <code>__proto__</code>)</li> <li><code>preventExtensions(..)</code>: via <code>[[PreventExtensions]]</code>, the proxy is made non-extensible (<code>Object.preventExtensions(..)</code> or <code>Reflect.preventExtensions(..)</code>)</li> <li><code>isExtensible(..)</code>: via <code>[[IsExtensible]]</code>, the extensibility of the proxy is probed (<code>Object.isExtensible(..)</code> or <code>Reflect.isExtensible(..)</code>)</li> <li><code>ownKeys(..)</code>: via <code>[[OwnPropertyKeys]]</code>, the set of owned properties and/or owned symbol properties of the proxy is retrieved (<code>Object.keys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, <code>Object.getOwnSymbolProperties(..)</code>, <code>Reflect.ownKeys(..)</code>, or <code>JSON.stringify(..)</code>)</li> <li><code>enumerate(..)</code>: via <code>[[Enumerate]]</code>, an iterator is requested for the proxy&#39;s enumerable owned and &quot;inherited&quot; properties (<code>Reflect.enumerate(..)</code> or <code>for..in</code>)</li> <li><code>has(..)</code>: via <code>[[HasProperty]]</code>, the proxy is probed to see if it has an owned or &quot;inherited&quot; property (<code>Reflect.has(..)</code>, <code>Object#hasOwnProperty(..)</code>, or <code>&quot;prop&quot; in obj</code>)</li> </ul> <p><strong>Tip:</strong> For more information about each of these meta programming tasks, see the &quot;<code>Reflect</code> API&quot; section later in this chapter.</p> <p>In addition to the notations in the preceding list about actions that will trigger the various traps, some traps are triggered indirectly by the default actions of another trap. For example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> handlers = {         getOwnPropertyDescriptor(target,<span class=\"hljs-keyword\">prop</span>) {             console.<span class=\"hljs-literal\">log</span>(                 <span class=\"hljs-string\">\"getOwnPropertyDescriptor\"</span>             );             <span class=\"hljs-keyword\">return</span> Object.getOwnPropertyDescriptor(                 target, <span class=\"hljs-keyword\">prop</span>             );         },         defineProperty(target,<span class=\"hljs-keyword\">prop</span>,<span class=\"hljs-keyword\">desc</span>){             console.<span class=\"hljs-literal\">log</span>( <span class=\"hljs-string\">\"defineProperty\"</span> );             <span class=\"hljs-keyword\">return</span> Object.defineProperty(                 target, <span class=\"hljs-keyword\">prop</span>, <span class=\"hljs-keyword\">desc</span>             );         }     },     proxy = new Proxy( {}, handlers );  proxy.a = 2; <span class=\"hljs-comment\">// getOwnPropertyDescriptor</span> <span class=\"hljs-comment\">// defineProperty</span> </code></pre> <p>The <code>getOwnPropertyDescriptor(..)</code> and <code>defineProperty(..)</code> handlers are triggered by the default <code>set(..)</code> handler&#39;s steps when setting a property value (whether newly adding or updating). If you also define your own <code>set(..)</code> handler, you may or may not make the corresponding calls against <code>context</code> (not <code>target</code>!) which would trigger these proxy traps.</p> <h3 id=\"proxy-limitations\">Proxy Limitations</h3> <p>These meta programming handlers trap a wide array of fundamental operations you can perform against an object. However, there are some operations which are not (yet, at least) available to intercept.</p> <p>For example, none of these operations are trapped and forwarded from <code>pobj</code> proxy to <code>obj</code> target:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> obj = { a:<span class=\"hljs-number\">1</span>, b:<span class=\"hljs-number\">2</span> },     handlers = { .. },     pobj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>( obj, handlers );  <span class=\"hljs-keyword\">typeof</span> obj; <span class=\"hljs-built_in\">String</span>( obj ); obj + <span class=\"hljs-string\">\"\"</span>; obj == pobj; obj === pobj </code></pre> <p>Perhaps in the future, more of these underlying fundamental operations in the language will be interceptable, giving us even more power to extend JavaScript from within itself.</p> <p><strong>Warning:</strong> There are certain <em>invariants</em> -- behaviors which cannot be overridden -- that apply to the use of proxy handlers. For example, the result from the <code>isExtensible(..)</code> handler is always coerced to a <code>boolean</code>. These invariants restrict some of your ability to customize behaviors with proxies, but they do so only to prevent you from creating strange and unusual (or inconsistent) behavior. The conditions for these invariants are complicated so we won&#39;t fully go into them here, but this post (<a href=\"http://www.2ality.com/2014/12/es6-proxies.html#invariants\">http://www.2ality.com/2014/12/es6-proxies.html#invariants</a>) does a great job of covering them.</p> <h3 id=\"revocable-proxies\">Revocable Proxies</h3> <p>A regular proxy always traps for the target object, and cannot be modified after creation -- as long as a reference is kept to the proxy, proxying remains possible. However, there may be cases where you want to create a proxy that can be disabled when you want to stop allowing it to proxy. The solution is to create a <em>revocable proxy</em>:</p> <pre><code class=\"lang-js\">var obj = { a: <span class=\"hljs-number\">1</span> },     handlers = {         <span class=\"hljs-built_in\">get</span>(target,<span class=\"hljs-variable\">key</span>,context) {             <span class=\"hljs-comment\">// <span class=\"hljs-doctag\">note:</span> target === obj,</span>             <span class=\"hljs-comment\">// context === pobj</span>             console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"accessing: \"</span>, <span class=\"hljs-variable\">key</span> );             <span class=\"hljs-keyword\">return</span> target[<span class=\"hljs-variable\">key</span>];         }     },     { proxy: pobj, revoke: prevoke } =         Proxy.revocable( obj, handlers );  pobj.a; <span class=\"hljs-comment\">// accessing: a</span> <span class=\"hljs-comment\">// 1</span>  <span class=\"hljs-comment\">// later:</span> prevoke();  pobj.a; <span class=\"hljs-comment\">// TypeError</span> </code></pre> <p>A revocable proxy is created with <code>Proxy.revocable(..)</code>, which is a regular function, not a constructor like <code>Proxy(..)</code>. Otherwise, it takes the same two arguments: <em>target</em> and <em>handlers</em>.</p> <p>The return value of <code>Proxy.revocable(..)</code> is not the proxy itself as with <code>new Proxy(..)</code>. Instead, it&#39;s an object with two properties: <em>proxy</em> and <em>revoke</em> -- we used object destructuring (see &quot;Destructuring&quot; in Chapter 2) to assign these properties to <code>pobj</code> and <code>prevoke()</code> variables, respectively.</p> <p>Once a revocable proxy is revoked, any attempts to access it (trigger any of its traps) will throw a <code>TypeError</code>.</p> <p>An example of using a revocable proxy might be handing out a proxy to another party in your application that manages data in your model, instead of giving them a reference to the real model object itself. If your model object changes or is replaced, you want to invalidate the proxy you handed out so the other party knows (via the errors!) to request an updated reference to the model.</p> <h3 id=\"using-proxies\">Using Proxies</h3> <p>The meta programming benefits of these Proxy handlers should be obvious. We can almost fully intercept (and thus override) the behavior of objects, meaning we can extend object behavior beyond core JS in some very powerful ways. We&#39;ll look at a few example patterns to explore the possibilities.</p> <h4 id=\"proxy-first-proxy-last\">Proxy First, Proxy Last</h4> <p>As we mentioned earlier, you typically think of a proxy as &quot;wrapping&quot; the target object. In that sense, the proxy becomes the primary object that the code interfaces with, and the actual target object remains hidden/protected.</p> <p>You might do this because you want to pass the object somewhere that can&#39;t be fully &quot;trusted,&quot; and so you need to enforce special rules around its access rather than passing the object itself.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> messages = [],     handlers = {         get(target,key) {             <span class=\"hljs-comment\">// string value?</span>             <span class=\"hljs-keyword\">if</span> (typeof target[key] == <span class=\"hljs-string\">\"string\"</span>) {                 <span class=\"hljs-comment\">// filter out punctuation</span>                 <span class=\"hljs-keyword\">return</span> target[key]                     .replace( /[^\\w]/g, <span class=\"hljs-string\">\"\"</span> );             }              <span class=\"hljs-comment\">// pass everything else through</span>             <span class=\"hljs-keyword\">return</span> target[key];         },         set(target,key,<span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>) {</span>             <span class=\"hljs-comment\">// only set unique strings, lowercased</span>             <span class=\"hljs-keyword\">if</span> (typeof <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span> <span class=\"hljs-title\">==</span> \"<span class=\"hljs-title\">string</span>\") {</span>                 <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span> =</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>.<span class=\"hljs-title\">toLowerCase</span>(</span>);                 <span class=\"hljs-keyword\">if</span> (target.indexOf( <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span> ) <span class=\"hljs-title\">==</span> <span class=\"hljs-title\">-1</span>) {</span>                     target.push(                         <span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>.<span class=\"hljs-title\">toLowerCase</span>(</span>)                     );                 }             }             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;         }     },     messages_proxy =         <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Proxy</span>( messages, handlers );  <span class=\"hljs-comment\">// elsewhere:</span> messages_proxy.push(     <span class=\"hljs-string\">\"heLLo...\"</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-string\">\"wOrlD!!\"</span>, <span class=\"hljs-string\">\"WoRld!!\"</span> );  messages_proxy.forEach( function(<span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>){</span>     console.log(<span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>);</span> } ); <span class=\"hljs-comment\">// hello world</span>  messages.forEach( function(<span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>){</span>     console.log(<span class=\"hljs-function\"><span class=\"hljs-keyword\">val</span>);</span> } ); <span class=\"hljs-comment\">// hello... world!!</span> </code></pre> <p>I call this <em>proxy first</em> design, as we interact first (primarily, entirely) with the proxy.</p> <p>We enforce some special rules on interacting with <code>messages_proxy</code> that aren&#39;t enforced for <code>messages</code> itself. We only add elements if the value is a string and is also unique; we also lowercase the value. When retrieving values from <code>messages_proxy</code>, we filter out any punctuation in the strings.</p> <p>Alternatively, we can completely invert this pattern, where the target interacts with the proxy instead of the proxy interacting with the target. Thus, code really only interacts with the main object. The easiest way to accomplish this fallback is to have the proxy object in the <code>[[Prototype]]</code> chain of the main object.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> handlers = {         get(target,key,context) {             <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) </span>{                 context.speak(key + <span class=\"hljs-string\">\"!\"</span>);             };         }     },     catchall = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>( {}, handlers ),     greeter = {         speak(who = <span class=\"hljs-string\">\"someone\"</span>) {             <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"hello\"</span>, who );         }     };  <span class=\"hljs-comment\">// setup `greeter` to fall back to `catchall`</span> <span class=\"hljs-built_in\">Object</span>.setPrototypeOf( greeter, catchall );  greeter.speak();                <span class=\"hljs-comment\">// hello someone</span> greeter.speak( <span class=\"hljs-string\">\"world\"</span> );        <span class=\"hljs-comment\">// hello world</span>  greeter.everyone();                <span class=\"hljs-comment\">// hello everyone!</span> </code></pre> <p>We interact directly with <code>greeter</code> instead of <code>catchall</code>. When we call <code>speak(..)</code>, it&#39;s found on <code>greeter</code> and used directly. But when we try to access a method like <code>everyone()</code>, that function doesn&#39;t exist on <code>greeter</code>.</p> <p>The default object property behavior is to check up the <code>[[Prototype]]</code> chain (see the <em>this &amp; Object Prototypes</em> title of this series), so <code>catchall</code> is consulted for an <code>everyone</code> property. The proxy <code>get()</code> handler then kicks in and returns a function that calls <code>speak(..)</code> with the name of the property being accessed (<code>&quot;everyone&quot;</code>).</p> <p>I call this pattern <em>proxy last</em>, as the proxy is used only as a last resort.</p> <h4 id=\"-no-such-property-method-\">&quot;No Such Property/Method&quot;</h4> <p>A common complaint about JS is that objects aren&#39;t by default very defensive in the situation where you try to access or set a property that doesn&#39;t already exist. You may wish to predefine all the properties/methods for an object, and have an error thrown if a nonexistent property name is subsequently used.</p> <p>We can accomplish this with a proxy, either in <em>proxy first</em> or <em>proxy last</em> design. Let&#39;s consider both.</p> <pre><code class=\"lang-js\">var obj = {         a: <span class=\"hljs-number\">1</span>,         foo() {             console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"a:\"</span>, <span class=\"hljs-keyword\">this</span>.a );         }     },     handlers = {         <span class=\"hljs-built_in\">get</span>(target,<span class=\"hljs-variable\">key</span>,context) {             <span class=\"hljs-keyword\">if</span> (Reflect.has( target, <span class=\"hljs-variable\">key</span> )) {                 <span class=\"hljs-keyword\">return</span> Reflect.<span class=\"hljs-built_in\">get</span>(                     target, <span class=\"hljs-variable\">key</span>, context                 );             }             <span class=\"hljs-keyword\">else</span> {                 <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">\"No such property/method!\"</span>;             }         },         <span class=\"hljs-built_in\">set</span>(target,<span class=\"hljs-variable\">key</span>,val,context) {             <span class=\"hljs-keyword\">if</span> (Reflect.has( target, <span class=\"hljs-variable\">key</span> )) {                 <span class=\"hljs-keyword\">return</span> Reflect.<span class=\"hljs-built_in\">set</span>(                     target, <span class=\"hljs-variable\">key</span>, val, context                 );             }             <span class=\"hljs-keyword\">else</span> {                 <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-string\">\"No such property/method!\"</span>;             }         }     },     pobj = <span class=\"hljs-keyword\">new</span> Proxy( obj, handlers );  pobj.a = <span class=\"hljs-number\">3</span>; pobj.foo();            <span class=\"hljs-comment\">// a: 3</span>  pobj.b = <span class=\"hljs-number\">4</span>;            <span class=\"hljs-comment\">// Error: No such property/method!</span> pobj.bar();            <span class=\"hljs-comment\">// Error: No such property/method!</span> </code></pre> <p>For both <code>get(..)</code> and <code>set(..)</code>, we only forward the operation if the target object&#39;s property already exists; error thrown otherwise. The proxy object (<code>pobj</code>) is the main object code should interact with, as it intercepts these actions to provide the protections.</p> <p>Now, let&#39;s consider inverting with <em>proxy last</em> design:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> handlers = {         get() {             throw <span class=\"hljs-string\">\"No such property/method!\"</span>;         },         <span class=\"hljs-type\">set</span>() {             throw <span class=\"hljs-string\">\"No such property/method!\"</span>;         }     },     pobj = new <span class=\"hljs-type\">Proxy</span>( {}, handlers ),     obj = {         a: <span class=\"hljs-number\">1</span>,         foo() {             console.log( <span class=\"hljs-string\">\"a:\"</span>, this.a );         }     };  // setup `obj` to fall back to `pobj` <span class=\"hljs-type\">Object</span>.setPrototypeOf( obj, pobj );  obj.a = <span class=\"hljs-number\">3</span>; obj.foo();            // a: <span class=\"hljs-number\">3</span>  obj.b = <span class=\"hljs-number\">4</span>;            // <span class=\"hljs-type\">Error</span>: <span class=\"hljs-type\">No</span> such property/<span class=\"hljs-keyword\">method</span>! obj.bar();            // <span class=\"hljs-type\">Error</span>: <span class=\"hljs-type\">No</span> such property/<span class=\"hljs-keyword\">method</span>! </code></pre> <p>The <em>proxy last</em> design here is a fair bit simpler with respect to how the handlers are defined. Instead of needing to intercept the <code>[[Get]]</code> and <code>[[Set]]</code> operations and only forward them if the target property exists, we instead rely on the fact that if either <code>[[Get]]</code> or <code>[[Set]]</code> get to our <code>pobj</code> fallback, the action has already traversed the whole <code>[[Prototype]]</code> chain and not found a matching property. We are free at that point to unconditionally throw the error. Cool, huh?</p> <h4 id=\"proxy-hacking-the-prototype-chain\">Proxy Hacking the <code>[[Prototype]]</code> Chain</h4> <p>The <code>[[Get]]</code> operation is the primary channel by which the <code>[[Prototype]]</code> mechanism is invoked. When a property is not found on the immediate object, <code>[[Get]]</code> automatically hands off the operation to the <code>[[Prototype]]</code> object.</p> <p>That means you can use the <code>get(..)</code> trap of a proxy to emulate or extend the notion of this <code>[[Prototype]]</code> mechanism.</p> <p>The first hack we&#39;ll consider is creating two objects which are circularly linked via <code>[[Prototype]]</code> (or, at least it appears that way!). You cannot actually create a real circular <code>[[Prototype]]</code> chain, as the engine will throw an error. But a proxy can fake it!</p> <p>Consider:</p> <pre><code class=\"lang-js\">var handlers = {         <span class=\"hljs-built_in\">get</span>(target,<span class=\"hljs-variable\">key</span>,context) {             <span class=\"hljs-keyword\">if</span> (Reflect.has( target, <span class=\"hljs-variable\">key</span> )) {                 <span class=\"hljs-keyword\">return</span> Reflect.<span class=\"hljs-built_in\">get</span>(                     target, <span class=\"hljs-variable\">key</span>, context                 );             }             <span class=\"hljs-comment\">// fake circular `[[Prototype]]`</span>             <span class=\"hljs-keyword\">else</span> {                 <span class=\"hljs-keyword\">return</span> Reflect.<span class=\"hljs-built_in\">get</span>(                     target[                         Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"[[Prototype]]\"</span> )                     ],                     <span class=\"hljs-variable\">key</span>,                     context                 );             }         }     },     obj1 = <span class=\"hljs-keyword\">new</span> Proxy(         {             name: <span class=\"hljs-string\">\"obj-1\"</span>,             foo() {                 console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"foo:\"</span>, <span class=\"hljs-keyword\">this</span>.name );             }         },         handlers     ),     obj2 = <span class=\"hljs-keyword\">Object</span>.assign(         <span class=\"hljs-keyword\">Object</span>.create( obj1 ),         {             name: <span class=\"hljs-string\">\"obj-2\"</span>,             bar() {                 console.<span class=\"hljs-built_in\">log</span>( <span class=\"hljs-string\">\"bar:\"</span>, <span class=\"hljs-keyword\">this</span>.name );                 <span class=\"hljs-keyword\">this</span>.foo();             }         }     );  <span class=\"hljs-comment\">// fake circular `[[Prototype]]` link</span> obj1[ Symbol.<span class=\"hljs-keyword\">for</span>( <span class=\"hljs-string\">\"[[Prototype]]\"</span> ) ] = obj2;  obj1.bar(); <span class=\"hljs-comment\">// bar: obj-1 &lt;-- through proxy faking [[Prototype]]</span> <span class=\"hljs-comment\">// foo: obj-1 &lt;-- `this` context still preserved</span>  obj2.foo(); <span class=\"hljs-comment\">// foo: obj-2 &lt;-- through [[Prototype]]</span> </code></pre> <p><strong>Note:</strong> We didn&#39;t need to proxy/forward <code>[[Set]]</code> in this example, so we kept things simpler. To be fully <code>[[Prototype]]</code> emulation compliant, you&#39;d want to implement a <code>set(..)</code> handler that searches the <code>[[Prototype]]</code> chain for a matching property and respects its descriptor behavior (e.g., set, writable). See the <em>this &amp; Object Prototypes</em> title of this series.</p> <p>In the previous snippet, <code>obj2</code> is <code>[[Prototype]]</code> linked to <code>obj1</code> by virtue of the <code>Object.create(..)</code> statement. But to create the reverse (circular) linkage, we create property on <code>obj1</code> at the symbol location <code>Symbol.for(&quot;[[Prototype]]&quot;)</code> (see &quot;Symbols&quot; in Chapter 2). This symbol may look sort of special/magical, but it isn&#39;t. It just allows me a conveniently named hook that semantically appears related to the task I&#39;m performing.</p> <p>Then, the proxy&#39;s <code>get(..)</code> handler looks first to see if a requested <code>key</code> is on the proxy. If not, the operation is manually handed off to the object reference stored in the <code>Symbol.for(&quot;[[Prototype]]&quot;)</code> location of <code>target</code>.</p> <p>One important advantage of this pattern is that the definitions of <code>obj1</code> and <code>obj2</code> are mostly not intruded by the setting up of this circular relationship between them. Although the previous snippet has all the steps intertwined for brevity&#39;s sake, if you look closely, the proxy handler logic is entirely generic (doesn&#39;t know about <code>obj1</code> or <code>obj2</code> specifically). So, that logic could be pulled out into a simple helper that wires them up, like a <code>setCircularPrototypeOf(..)</code> for example. We&#39;ll leave that as an exercise for the reader.</p> <p>Now that we&#39;ve seen how we can use <code>get(..)</code> to emulate a <code>[[Prototype]]</code> link, let&#39;s push the hackery a bit further. Instead of a circular <code>[[Prototype]]</code>, what about multiple <code>[[Prototype]]</code> linkages (aka &quot;multiple inheritance&quot;)? This turns out to be fairly straightforward:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> obj1 = {         name: <span class=\"hljs-string\">\"obj-1\"</span>,         foo() {             <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"obj1.foo:\"</span>, <span class=\"hljs-keyword\">this</span>.name );         },     },     obj2 = {         name: <span class=\"hljs-string\">\"obj-2\"</span>,         foo() {             <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"obj2.foo:\"</span>, <span class=\"hljs-keyword\">this</span>.name );         },         bar() {             <span class=\"hljs-built_in\">console</span>.log( <span class=\"hljs-string\">\"obj2.bar:\"</span>, <span class=\"hljs-keyword\">this</span>.name );         }     },     handlers = {         get(target,key,context) {             <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Reflect</span>.has( target, key )) {                 <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.get(                     target, key, context                 );             }             <span class=\"hljs-comment\">// fake multiple `[[Prototype]]`</span>             <span class=\"hljs-keyword\">else</span> {                 <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> P <span class=\"hljs-keyword\">of</span> target[                     <span class=\"hljs-built_in\">Symbol</span>.for( <span class=\"hljs-string\">\"[[Prototype]]\"</span> )                 ]) {                     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">Reflect</span>.has( P, key )) {                         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Reflect</span>.get(                             P, key, context                         );                     }                 }             }         }     },     obj3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Proxy</span>(         {             name: <span class=\"hljs-string\">\"obj-3\"</span>,             baz() {                 <span class=\"hljs-keyword\">this</span>.foo();                 <span class=\"hljs-keyword\">this</span>.bar();             }         },         handlers     );  <span class=\"hljs-comment\">// fake multiple `[[Prototype]]` links</span> obj3[ <span class=\"hljs-built_in\">Symbol</span>.for( <span class=\"hljs-string\">\"[[Prototype]]\"</span> ) ] = [     obj1, obj2 ];  obj3.baz(); <span class=\"hljs-comment\">// obj1.foo: obj-3</span> <span class=\"hljs-comment\">// obj2.bar: obj-3</span> </code></pre> <p><strong>Note:</strong> As mentioned in the note after the earlier circular <code>[[Prototype]]</code> example, we didn&#39;t implement the <code>set(..)</code> handler, but it would be necessary for a complete solution that emulates <code>[[Set]]</code> actions as normal <code>[[Prototype]]</code>s behave.</p> <p><code>obj3</code> is set up to multiple-delegate to both <code>obj1</code> and <code>obj2</code>. In <code>obj3.baz()</code>, the <code>this.foo()</code> call ends up pulling <code>foo()</code> from <code>obj1</code> (first-come, first-served, even though there&#39;s also a <code>foo()</code> on <code>obj2</code>). If we reordered the linkage as <code>obj2, obj1</code>, the <code>obj2.foo()</code> would have been found and used.</p> <p>But as is, the <code>this.bar()</code> call doesn&#39;t find a <code>bar()</code> on <code>obj1</code>, so it falls over to check <code>obj2</code>, where it finds a match.</p> <p><code>obj1</code> and <code>obj2</code> represent two parallel <code>[[Prototype]]</code> chains of <code>obj3</code>. <code>obj1</code> and/or <code>obj2</code> could themselves have normal <code>[[Prototype]]</code> delegation to other objects, or either could themself be a proxy (like <code>obj3</code> is) that can multiple-delegate.</p> <p>Just as with the circular <code>[[Prototype]]</code> example earlier, the definitions of <code>obj1</code>, <code>obj2</code>, and <code>obj3</code> are almost entirely separate from the generic proxy logic that handles the multiple-delegation. It would be trivial to define a utility like <code>setPrototypesOf(..)</code> (notice the &quot;s&quot;!) that takes a main object and a list of objects to fake the multiple <code>[[Prototype]]</code> linkage to. Again, we&#39;ll leave that as an exercise for the reader.</p> <p>Hopefully the power of proxies is now becoming clearer after these various examples. There are many other powerful meta programming tasks that proxies enable.</p> <h2 id=\"-reflect-api\"><code>Reflect</code> API</h2> <p>The <code>Reflect</code> object is a plain object (like <code>Math</code>), not a function/constructor like the other built-in natives.</p> <p>It holds static functions which correspond to various meta programming tasks that you can control. These functions correspond one-to-one with the handler methods (<em>traps</em>) that Proxies can define.</p> <p>Some of the functions will look familiar as functions of the same names on <code>Object</code>:</p> <ul> <li><code>Reflect.getOwnPropertyDescriptor(..)</code></li> <li><code>Reflect.defineProperty(..)</code></li> <li><code>Reflect.getPrototypeOf(..)</code></li> <li><code>Reflect.setPrototypeOf(..)</code></li> <li><code>Reflect.preventExtensions(..)</code></li> <li><code>Reflect.isExtensible(..)</code></li> </ul> <p>These utilities in general behave the same as their <code>Object.*</code> counterparts. However, one difference is that the <code>Object.*</code> counterparts attempt to coerce their first argument (the target object) to an object if it&#39;s not already one. The <code>Reflect.*</code> methods simply throw an error in that case.</p> <p>An object&#39;s keys can be accessed/inspected using these utilities:</p> <ul> <li><code>Reflect.ownKeys(..)</code>: Returns the list of all owned keys (not &quot;inherited&quot;), as returned by both <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>. See the &quot;Property Enumeration Order&quot; section for information about the order of keys.</li> <li><code>Reflect.enumerate(..)</code>: Returns an iterator that produces the set of all non-symbol keys (owned and &quot;inherited&quot;) that are <em>enumerable</em> (see the <em>this &amp; Object Prototypes</em> title of this series). Essentially, this set of keys is the same as those processed by a <code>for..in</code> loop. See the &quot;Property Enumeration Order&quot; section for information about the order of keys.</li> <li><code>Reflect.has(..)</code>: Essentially the same as the <code>in</code> operator for checking if a property is on an object or its <code>[[Prototype]]</code> chain. For example, <code>Reflect.has(o,&quot;foo&quot;)</code> essentially performs <code>&quot;foo&quot; in o</code>.</li> </ul> <p>Function calls and constructor invocations can be performed manually, separate of the normal syntax (e.g., <code>(..)</code> and <code>new</code>) using these utilities:</p> <ul> <li><code>Reflect.apply(..)</code>: For example, <code>Reflect.apply(foo,thisObj,[42,&quot;bar&quot;])</code> calls the <code>foo(..)</code> function with <code>thisObj</code> as its <code>this</code>, and passes in the <code>42</code> and <code>&quot;bar&quot;</code> arguments.</li> <li><code>Reflect.construct(..)</code>: For example, <code>Reflect.construct(foo,[42,&quot;bar&quot;])</code> essentially calls <code>new foo(42,&quot;bar&quot;)</code>.</li> </ul> <p>Object property access, setting, and deletion can be performed manually using these utilities:</p> <ul> <li><code>Reflect.get(..)</code>: For example, <code>Reflect.get(o,&quot;foo&quot;)</code> retrieves <code>o.foo</code>.</li> <li><code>Reflect.set(..)</code>: For example, <code>Reflect.set(o,&quot;foo&quot;,42)</code> essentially performs <code>o.foo = 42</code>.</li> <li><code>Reflect.deleteProperty(..)</code>: For example, <code>Reflect.deleteProperty(o,&quot;foo&quot;)</code> essentially performs <code>delete o.foo</code>.</li> </ul> <p>The meta programming capabilities of <code>Reflect</code> give you programmtic equivalents to emulate various syntactic features, exposing previously hidden-only abstract operations. For example, you can use these capabilities to extend features and APIs for <em>domain specific languages</em> (DSLs).</p> <h3 id=\"property-ordering\">Property Ordering</h3> <p>Prior to ES6, the order used to list an object&#39;s keys/properties was implementation dependent and undefined by the specification. Generally, most engines have enumerated them in creation order, though developers have been strongly encouraged not to ever rely on this ordering.</p> <p>As of ES6, the order for listing owned properties is now defined (ES6 specification, section 9.1.12) by the <code>[[OwnPropertyKeys]]</code> algorithm, which produces all owned properties (strings or symbols), regardless of enumerability. This ordering is only guaranteed for <code>Reflect.ownKeys(..)</code> (and by extension, <code>Object.getOwnPropertyNames(..)</code> and <code>Object.getOwnPropertySymbols(..)</code>).</p> <p>The ordering is:</p> <ol> <li>First, enumerate any owned properties that are integer indexes, in ascending numeric order.</li> <li>Next, enumerate the rest of the owned string property names in creation order.</li> <li>Finally, enumerate owned symbol properities in creation order.</li> </ol> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o = {};  o[<span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">\"c\"</span>)] = <span class=\"hljs-string\">\"yay\"</span>; o[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-literal\">true</span>; o[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>; o.b = <span class=\"hljs-string\">\"awesome\"</span>; o.a = <span class=\"hljs-string\">\"cool\"</span>;  <span class=\"hljs-built_in\">Reflect</span>.ownKeys( o );                <span class=\"hljs-comment\">// [1,2,\"b\",\"a\",Symbol(c)]</span> <span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames( o );    <span class=\"hljs-comment\">// [1,2,\"b\",\"a\"]</span> <span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols( o );    <span class=\"hljs-comment\">// [Symbol(c)]</span> </code></pre> <p>On the other hand, the <code>[[Enumerate]]</code> algorithm (ES6 specification, section 9.1.11) produces only enumerable properties, from the target object as well as its <code>[[Prototype]]</code> chain. It is used by both <code>Reflect.enumerate(..)</code> and <code>for..in</code>. The observable ordering is implementation dependent and not controlled by the specification.</p> <p>By contrast, <code>Object.keys(..)</code> invokes the <code>[[OwnPropertyKeys]]</code> algorithm to get a list of all owned keys. However, it filters out non-enumerable properties and then reorders the list to match legacy implementation-dependent behavior, specifically with <code>JSON.stringify(..)</code> and <code>for..in</code>. So, by extension the ordering <em>also</em> matches that of <code>Reflect.enumerate(..)</code>.</p> <p>In other words, all four mechanisms (<code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, <code>for..in</code>, and <code>JSON.stringify(..)</code>) will  match with the same implementation-dependent ordering, though they technically get there in different ways.</p> <p>Implementations are allowed to match these four to the ordering of <code>[[OwnPropertyKeys]]</code>, but are not required to. Nevertheless, you will likely observe the following ordering behavior from them:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o = { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> }; <span class=\"hljs-keyword\">var</span> p = <span class=\"hljs-built_in\">Object</span>.create( o ); p.c = <span class=\"hljs-number\">3</span>; p.d = <span class=\"hljs-number\">4</span>;  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> prop <span class=\"hljs-keyword\">of</span> <span class=\"hljs-built_in\">Reflect</span>.enumerate( p )) {     <span class=\"hljs-built_in\">console</span>.log( prop ); } <span class=\"hljs-comment\">// c d a b</span>  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> prop <span class=\"hljs-keyword\">in</span> p) {     <span class=\"hljs-built_in\">console</span>.log( prop ); } <span class=\"hljs-comment\">// c d a b</span>  <span class=\"hljs-built_in\">JSON</span>.stringify( p ); <span class=\"hljs-comment\">// {\"c\":3,\"d\":4}</span>  <span class=\"hljs-built_in\">Object</span>.keys( p ); <span class=\"hljs-comment\">// [\"c\",\"d\"]</span> </code></pre> <p>Boiling this all down: as of ES6, <code>Reflect.ownKeys(..)</code>, <code>Object.getOwnPropertyNames(..)</code>, and <code>Object.getOwnPropertySymbols(..)</code> all have predictable and reliable ordering guaranteed by the specification. So it&#39;s safe to build code that relies on this ordering.</p> <p><code>Reflect.enumerate(..)</code>, <code>Object.keys(..)</code>, and <code>for..in</code> (as well as <code>JSON.stringification(..)</code> by extension) continue to share an observable ordering with each other, as they always have. But that ordering will not necessarily be the same as that of <code>Reflect.ownKeys(..)</code>. Care should still be taken in relying on their implementation-dependent ordering.</p> <h2 id=\"feature-testing\">Feature Testing</h2> <p>What is a feature test? It&#39;s a test that you run to determine if a feature is available or not. Sometimes, the test is not just for existence, but for conformance to specified behavior -- features can exist but be buggy.</p> <p>This is a meta programming technique, to test the environment your program runs in to then determine how your program should behave.</p> <p>The most common use of feature tests in JS is checking for the existence of an API and if it&#39;s not present, defining a polyfill (see Chapter 1). For example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">Number</span>.isNaN) {     <span class=\"hljs-built_in\">Number</span>.isNaN = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{         <span class=\"hljs-keyword\">return</span> x !== x;     }; } </code></pre> <p>The <code>if</code> statement in this snippet is meta programming: we&#39;re probing our program and its runtime environment to determine if and how we should proceed.</p> <p>But what about testing for features that involve new syntax?</p> <p>You might try something like:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">try</span> { <span class=\"hljs-function\">    <span class=\"hljs-title\">a</span> = <span class=\"hljs-params\">()</span> =&gt;</span> {};     ARROW_FUNCS_ENABLED = <span class=\"hljs-literal\">true</span>; } <span class=\"hljs-keyword\">catch</span> (err) {     ARROW_FUNCS_ENABLED = <span class=\"hljs-literal\">false</span>; } </code></pre> <p>Unfortunately, this doesn&#39;t work, because our JS programs are compiled. Thus, the engine will choke on the <code>() =&gt; {}</code> syntax if it is not already supporting ES6 arrow functions. Having a syntax error in your program prevents it from running, which prevents your program from subsequently responding differently if the feature is supported or not.</p> <p>To meta program with feature tests around syntax-related features, we need a way to insulate the test from the initial compile step our program runs through. For instance, if we could store the code for the test in a string, then the JS engine wouldn&#39;t by default try to compile the contents of that string, until we asked it to.</p> <p>Did your mind just jump to using <code>eval(..)</code>?</p> <p>Not so fast. See the <em>Scope &amp; Closures</em> title of this series for why <code>eval(..)</code> is a bad idea. But there&#39;s another option with less downsides: the <code>Function(..)</code> constructor.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">try</span> {     <span class=\"hljs-keyword\">new</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">Function</span><span class=\"hljs-params\">( <span class=\"hljs-string\">\"( () =&gt; {} )\"</span> )</span></span>;     ARROW_FUNCS_ENABLED = <span class=\"hljs-keyword\">true</span>; } <span class=\"hljs-keyword\">catch</span> (err) {     ARROW_FUNCS_ENABLED = <span class=\"hljs-keyword\">false</span>; } </code></pre> <p>OK, so now we&#39;re meta programming by determining if a feature like arrow functions <em>can</em> compile in the current engine or not. You might then wonder, what would we do with this information?</p> <p>With existence checks for APIs, and defining fallback API polyfills, there&#39;s a clear path for what to do with either test success or failure. But what can we do with the information that we get from <code>ARROW_FUNCS_ENABLED</code> being <code>true</code> or <code>false</code>?</p> <p>Because the syntax can&#39;t appear in a file if the engine doesn&#39;t support that feature, you can&#39;t just have different functions defined in the file with and without the syntax in question.</p> <p>What you can do is use the test to determine which of a set of JS files you should load. For example, if you had a set of these feature tests in a bootstrapper for your JS application, it could then test the environment to determine if your ES6 code can be loaded and run directly, or if you need to load a transpiled version of your code (see Chapter 1).</p> <p>This technique is called <em>split delivery</em>.</p> <p>It recognizes the reality that your ES6 authored JS programs will sometimes be able to entirely run &quot;natively&quot; in ES6+ browsers, but other times need transpilation to run in pre-ES6 browsers. If you always load and use the transpiled code, even in the new ES6-compliant environments, you&#39;re running suboptimal code at least some of the time. This is not ideal.</p> <p>Split delivery is more complicated and sophisticated, but it represents a more mature and robust approach to bridging the gap between the code you write and the feature support in browsers your programs must run in.</p> <h3 id=\"featuretests-io\">FeatureTests.io</h3> <p>Defining feature tests for all of the ES6+ syntax, as well as the semantic behaviors, is a daunting task you probably don&#39;t want to tackle yourself. Because these tests require dynamic compilation (<code>new Function(..)</code>), there&#39;s some unfortunate performance cost.</p> <p>Moreover, running these tests every single time your app runs is probably wasteful, as on average a user&#39;s browser only updates once in a several week period at most, and even then, new features aren&#39;t necessarily showing up with every update.</p> <p>Finally, managing the list of feature tests that apply to your specific code base -- rarely will your programs use the entirety of ES6 -- is unruly and error-prone.</p> <p>The &quot;<a href=\"https://featuretests.io\">https://featuretests.io</a>&quot; feature-tests-as-a-service offers solutions to these frustrations.</p> <p>You can load the service&#39;s library into your page, and it loads the latest test definitions and runs all the feature tests. It does so using background processing with Web Workers, if possible, to reduce the performance overhead. It also uses LocalStorage persistence to cache the results in a way that can be shared across all sites you visit which use the service, which drastically reduces how often the tests need to run on each browser instance.</p> <p>You get runtime feature tests in each of your users&#39; browsers, and you can use those tests results dynamically to serve users the most appropriate code (no more, no less) for their environments.</p> <p>Moreover, the service provides tools and APIs to scan your files to determine what features you need, so you can fully automate your split delivery build processes.</p> <p>FeatureTests.io makes it practical to use feature tests for all parts of ES6 and beyond to make sure that only the best code is ever loaded and run for any given environment.</p> <h2 id=\"tail-call-optimization-tco-\">Tail Call Optimization (TCO)</h2> <p>Normally, when a function call is made from inside another function, a second <em>stack frame</em> is allocated to separately manage the variables/state of that other function invocation. Not only does this allocation cost some processing time, but it also takes up some extra memory.</p> <p>A call stack chain typically has at most 10-15 jumps from one function to another and another. In those scenarios, the memory usage is not likely any kind of practical problem.</p> <p>However, when you consider recursive programming (a function calling itself repeatedly) -- or mutual recursion with two or more functions calling each other -- the call stack could easily be hundreds, thousands, or more levels deep. You can probably see the problems that could cause, if memory usage grows unbounded.</p> <p>JavaScript engines have to set an arbitrary limit to prevent such programming techniques from crashing by running the browser and device out of memory. That&#39;s why we get the frustrating &quot;RangeError: Maximum call stack size exceeded&quot; thrown if the limit is hit.</p> <p><strong>Warning:</strong> The limit of call stack depth is not controlled by the specification. It&#39;s implementation dependent, and will vary between browsers and devices. You should never code with strong assumptions of exact observable limits, as they may very well change from release to release.</p> <p>Certain patterns of function calls, called <em>tail calls</em>, can be optimized in a way to avoid the extra allocation of stack frames. If the extra allocation can be avoided, there&#39;s no reason to arbitrarily limit the call stack depth, so the engines can let them run unbounded.</p> <p>A tail call is a <code>return</code> statement with a function call, where nothing has to happen after the call except returning its value.</p> <p>This optimization can only be applied in <code>strict</code> mode. Yet another reason to always be writing all your code as <code>strict</code>!</p> <p>Here&#39;s a function call that is <em>not</em> in tail position:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-comment\">// not a tail call</span>     <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> + foo( x ); }  bar( <span class=\"hljs-number\">10</span> );                <span class=\"hljs-comment\">// 21</span> </code></pre> <p><code>1 + ..</code> has to be performed after the <code>foo(x)</code> call completes, so the state of that <code>bar(..)</code> invocation needs to be preserved.</p> <p>But the following snippet demonstrates calls to <code>foo(..)</code> and <code>bar(..)</code> where both <em>are</em> in tail position, as they&#39;re the last thing to happen in their code path (other than the <code>return</code>):</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-keyword\">return</span> x * <span class=\"hljs-number\">2</span>; }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">bar</span>(<span class=\"hljs-params\">x</span>) </span>{     x = x + <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">10</span>) {         <span class=\"hljs-keyword\">return</span> foo( x );     }     <span class=\"hljs-keyword\">else</span> {         <span class=\"hljs-keyword\">return</span> bar( x + <span class=\"hljs-number\">1</span> );     } }  bar( <span class=\"hljs-number\">5</span> );                <span class=\"hljs-comment\">// 24</span> bar( <span class=\"hljs-number\">15</span> );                <span class=\"hljs-comment\">// 32</span> </code></pre> <p>In this program, <code>bar(..)</code> is clearly recursive, but <code>foo(..)</code> is just a regular function call. In both cases, the function calls are in <em>proper tail position</em>. The <code>x + 1</code> is evaluated before the <code>bar(..)</code> call, and whenever that call finishes, all that happens is the <code>return</code>.</p> <p>Proper Tail Calls (PTC) of these forms can be optimized -- called tail call optimization (TCO) -- so that the extra stack frame allocation is unnecessary. Instead of creating a new stack frame for the next function call, the engine just reuses the existing stack frame. That works because a function doesn&#39;t need to preserve any of the current state, as nothing happens with that state after the PTC.</p> <p>TCO means there&#39;s practically no limit to how deep the call stack can be. That trick slightly improves regular function calls in normal programs, but more importantly opens the door to using recursion for program expression even if the call stack could be tens of thousands of calls deep.</p> <p>We&#39;re no longer relegated to simply theorizing about recursion for problem solving, but can actually use it in real JavaScript programs!</p> <p>As of ES6, all PTC should be optimizable in this way, recursion or not.</p> <h3 id=\"tail-call-rewrite\">Tail Call Rewrite</h3> <p>The hitch, however, is that only PTC can be optimized; non-PTC will still work of course, but will cause stack frame allocation as they always did. You&#39;ll have to be careful about structuring your functions with PTC if you expect the optimizations to kick in.</p> <p>If you have a function that&#39;s not written with PTC, you may find the need to manually rearrange your code to be eligible for TCO.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-keyword\">if</span> (x &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">return</span> (x / <span class=\"hljs-number\">2</span>) + foo( x - <span class=\"hljs-number\">1</span> ); }  foo( <span class=\"hljs-number\">123456</span> );            <span class=\"hljs-comment\">// RangeError</span> </code></pre> <p>The call to <code>foo(x-1)</code> isn&#39;t a PTC because its result has to be added to <code>(x / 2)</code> before <code>return</code>ing.</p> <p>However, to make this code eligible for TCO in an ES6 engine, we can rewrite it as follows:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-keyword\">var</span> foo = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_foo</span>(<span class=\"hljs-params\">acc,x</span>) </span>{         <span class=\"hljs-keyword\">if</span> (x &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> acc;         <span class=\"hljs-keyword\">return</span> _foo( (x / <span class=\"hljs-number\">2</span>) + acc, x - <span class=\"hljs-number\">1</span> );     }      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{         <span class=\"hljs-keyword\">return</span> _foo( <span class=\"hljs-number\">1</span>, x );     }; })();  foo( <span class=\"hljs-number\">123456</span> );            <span class=\"hljs-comment\">// 3810376848.5</span> </code></pre> <p>If you run the previous snippet in an ES6 engine that implements TCO, you&#39;ll get the <code>3810376848.5</code> answer as shown. However, it&#39;ll still fail with a <code>RangeError</code> in non-TCO engines.</p> <h3 id=\"non-tco-optimizations\">Non-TCO Optimizations</h3> <p>There are other techniques to rewrite the code so that the call stack isn&#39;t growing with each call.</p> <p>One such technique is called <em>trampolining</em>, which amounts to having each partial result represented as a function that either returns another partial result function or the final result. Then you can simply loop until you stop getting a function, and you&#39;ll have the result. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">trampoline</span>(<span class=\"hljs-params\"> res </span>) </span>{     <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-keyword\">typeof</span> res == <span class=\"hljs-string\">\"function\"</span>) {         res = res();     }     <span class=\"hljs-keyword\">return</span> res; }  <span class=\"hljs-keyword\">var</span> foo = (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_foo</span>(<span class=\"hljs-params\">acc,x</span>) </span>{         <span class=\"hljs-keyword\">if</span> (x &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> acc;         <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">partial</span>(<span class=\"hljs-params\"></span>)</span>{             <span class=\"hljs-keyword\">return</span> _foo( (x / <span class=\"hljs-number\">2</span>) + acc, x - <span class=\"hljs-number\">1</span> );         };     }      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">x</span>) </span>{         <span class=\"hljs-keyword\">return</span> trampoline( _foo( <span class=\"hljs-number\">1</span>, x ) );     }; })();  foo( <span class=\"hljs-number\">123456</span> );            <span class=\"hljs-comment\">// 3810376848.5</span> </code></pre> <p>This reworking required minimal changes to factor out the recursion into the loop in <code>trampoline(..)</code>:</p> <ol> <li>First, we wrapped the <code>return _foo ..</code> line in the <code>return partial() { ..</code> function expression.</li> <li>Then we wrapped the <code>_foo(1,x)</code> call in the <code>trampoline(..)</code> call.</li> </ol> <p>The reason this technique doesn&#39;t suffer the call stack limitiation is that each of those inner <code>partial(..)</code> functions is just returned back to the <code>while</code> loop in <code>trampoline(..)</code>, which runs it and then loop iterates again. In other words, <code>partial(..)</code> doesn&#39;t recursively call itself, it just returns another function. The stack depth remains constant, so it can run as long as it needs to.</p> <p>Trampolining expressed in this way uses the closure that the inner <code>partial()</code> function has over the <code>x</code> and <code>acc</code> variables to keep the state from iteration to iteration. The advantage is that the looping logic is pulled out into a reusable <code>trampoline(..)</code> utility function, which many libraries provide versions of. You can reuse <code>trampoline(..)</code> multiple times in your program with different trampolined algorithms.</p> <p>Of course, if you really wanted to deeply optimize (and the reusability wasn&#39;t a concern), you could discard the closure state and inline the state tracking of <code>acc</code> into just one function&#39;s scope along with a loop. This technique is generally called <em>recursion unrolling</em>:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-keyword\">var</span> acc = <span class=\"hljs-number\">1</span>;     <span class=\"hljs-keyword\">while</span> (x &gt; <span class=\"hljs-number\">1</span>) {         acc = (x / <span class=\"hljs-number\">2</span>) + acc;         x = x - <span class=\"hljs-number\">1</span>;     }     <span class=\"hljs-keyword\">return</span> acc; }  foo( <span class=\"hljs-number\">123456</span> );            <span class=\"hljs-comment\">// 3810376848.5</span> </code></pre> <p>This expression of the algorithm is simpler to read, and will likely perform the best (strictly speaking) of the various forms we&#39;ve explored. That may seem like a clear winner, and you may wonder why you would ever try the other approaches.</p> <p>There are some reasons why you might not want to always manually unroll your recursions:</p> <ul> <li>Instead of factoring out the trampolining (loop) logic for reusability, we&#39;ve inlined it. This works great when there&#39;s only one example to consider, but as soon as you have a half dozen or more of these in your program, there&#39;s a good chance you&#39;ll want some reusabilty to keep things shorter and more manageable.</li> <li><p>The example here is deliberately simple enough to illustrate the different forms. In practice, there are many more complications in recursion algorithms, such as mutual recursion (more than just one function calling itself).</p> <p> The farther you go down this rabbit hole, the more manual and intricate the <em>unrolling</em> optimizations are. You&#39;ll quickly lose all the perceived value of readability. The primary advantage of recursion, even in the PTC form, is that it preserves the algorithm readability, and offloads the performance optimization to the engine.</p> </li> </ul> <p>If you write your algorithms with PTC, the ES6 engine will apply TCO to let your code run in constant stack depth (by reusing stack frames). You get the readability of recursion with most of the performance benefits and no limitations of run length.</p> <h3 id=\"meta-\">Meta?</h3> <p>What does TCO have to do with meta programming?</p> <p>As we covered in the &quot;Feature Testing&quot; section earlier, you can determine at runtime what features an engine supports. This includes TCO, though determining it is quite brute force. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-keyword\">try</span> {     (<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>)</span>{         <span class=\"hljs-keyword\">if</span> (x &lt; <span class=\"hljs-number\">5E5</span>) <span class=\"hljs-keyword\">return</span> foo( x + <span class=\"hljs-number\">1</span> );     })( <span class=\"hljs-number\">1</span> );      TCO_ENABLED = <span class=\"hljs-literal\">true</span>; } <span class=\"hljs-keyword\">catch</span> (err) {     TCO_ENABLED = <span class=\"hljs-literal\">false</span>; } </code></pre> <p>In a non-TCO engine, the recursive loop will fail out eventually, throwing an exception caught by the <code>try..catch</code>. Otherwise, the loop completes easily thanks to TCO.</p> <p>Yuck, right?</p> <p>But how could meta programming around the TCO feature (or rather, the lack thereof) benefit our code? The simple answer is that you could use such a feature test to decide to load a version of your application&#39;s code that uses recursion, or an alternative one that&#39;s been converted/transpiled to not need recursion.</p> <h4 id=\"self-adjusting-code\">Self-Adjusting Code</h4> <p>But here&#39;s another way of looking at the problem:</p> <pre><code class=\"lang-js\"><span class=\"hljs-pi\">\"use strict\"</span>;  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">foo</span>(<span class=\"hljs-params\">x</span>) </span>{     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">_foo</span>(<span class=\"hljs-params\"></span>) </span>{         <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">1</span>) {             acc = acc + (x / <span class=\"hljs-number\">2</span>);             x = x - <span class=\"hljs-number\">1</span>;             <span class=\"hljs-keyword\">return</span> _foo();         }     }      <span class=\"hljs-keyword\">var</span> acc = <span class=\"hljs-number\">1</span>;      <span class=\"hljs-keyword\">while</span> (x &gt; <span class=\"hljs-number\">1</span>) {         <span class=\"hljs-keyword\">try</span> {             _foo();         }         <span class=\"hljs-keyword\">catch</span> (err) { }     }      <span class=\"hljs-keyword\">return</span> acc; }  foo( <span class=\"hljs-number\">123456</span> );            <span class=\"hljs-comment\">// 3810376848.5</span> </code></pre> <p>This algorithm works by attempting to do as much of the work with recursion as possible, but keeping track of the progress via scoped variables <code>x</code> and <code>acc</code>. If the entire problem can be solved with recursion without an error, great. If the engine kills the recursion at some point, we simply catch that with the <code>try..catch</code> and then try again, picking up where we left off.</p> <p>I consider this a form of meta programming in that you are probing during runtime the ability of the engine to fully (recursively) finish the task, and working around any (non-TCO) engine limitations that may restrict you.</p> <p>At first (or even second!) glance, my bet is this code seems much uglier to you compared to some of the earlier versions. It also runs a fair bit slower (on larger runs in a non-TCO environment).</p> <p>The primary advantage, other than it being able to complete any size task even in non-TCO engines, is that this &quot;solution&quot; to the recursion stack limitation is much more flexible than the trampolining or manual unrolling techniques shown previously.</p> <p>Essentially, <code>_foo()</code> in this case is a sort of stand-in for practically any recursive task, even mutual recursion. The rest is the boilerplate that should work for just about any algorithm.</p> <p>The only &quot;catch&quot; is that to be able to resume in the event of a recursion limit being hit, the state of the recursion must be in scoped variables that exist outside the recursive function(s). We did that by leaving <code>x</code> and <code>acc</code> outside of the <code>_foo()</code> function, instead of passing them as arguments to <code>_foo()</code> as earlier.</p> <p>Almost any recursive algorithm can be adapted to work this way. That means it&#39;s the most widely applicable way of leveraging TCO with recursion in your programs, with minimal rewriting.</p> <p>This approach still uses a PTC, meaning that this code will <em>progressively enhance</em> from running using the loop many times (recursion batches) in an older browser to fully leveraging TCO&#39;d recursion in an ES6+ environment. I think that&#39;s pretty cool!</p> <h2 id=\"review\">Review</h2> <p>Meta programming is when you turn the logic of your program to focus on itself (or its runtime environment), either to inspect its own structure or to modify it. The primary value of meta programming is to extend the normal mechanisms of the language to provide additional capabilities.</p> <p>Prior to ES6, JavaScript already had quite a bit of meta programming capability, but ES6 significantly ramps that up with several new features.</p> <p>From function name inferences for anonymous functions to meta properties that give you information about things like how a constructor was invoked, you can inspect the program structure while it runs more than ever before. Well Known Symbols let you override intrinsic behaviors, such as coercion of an object to a primitive value. Proxies can intercept and customize various low-level operations on objects, and <code>Reflect</code> provides utilities to emulate them.</p> <p>Feature testing, even for subtle semantic behaviors like Tail Call Optimization, shifts the meta programming focus from your program to the JS engine capabilities itself. By knowing more about what the environment can do, your programs can adjust themselves to the best fit as they run.</p> <p>Should you meta program? My advice is: first focus on learning how the core mechanics of the language really work. But once you fully know what JS itself can do, it&#39;s time to start leveraging these powerful meta programming capabilities to push the language further!</p> ","title":"You Don't Know JS: ES6 & Beyond"},"ch8":{"body":"<h1 id=\"chapter-8-beyond-es6\">Chapter 8: Beyond ES6</h1> <p>At the time of this writing, the final draft of ES6 (<em>ECMAScript 2015</em>) is shortly headed toward its final official vote of approval by ECMA. But even as ES6 is being finalized, the TC39 committee is already hard at work at on features for ES7/2016 and beyond.</p> <p>As we discussed in Chapter 1, it&#39;s expected that the cadence of progress for JS is going to accelerate from updating once every several years to having an official version update once per year (hence the year-based naming). That alone is going to radically change how JS developers learn about and keep up with the language.</p> <p>But even more importantly, the committee is actually going to work feature by feature. As soon as a feature is spec-complete and has its kinks worked out through implementation experiments in a few browsers, that feature will be considered stable enough to start using. We&#39;re all strongly encouraged to adopt features once they&#39;re ready instead of waiting for some official standards vote. If you haven&#39;t already learned ES6, the time is <em>past due</em> to get on board!</p> <p>As the time of this writing, a list of future proposals and their status can be seen here (<a href=\"https://github.com/tc39/ecma262#current-proposals\">https://github.com/tc39/ecma262#current-proposals</a>).</p> <p>Transpilers and polyfills are how we&#39;ll bridge to these new features even before all browsers we support have implemented them. Babel, Traceur, and several other major transpilers already have support for some of the post-ES6 features that are most likely to stabilize.</p> <p>With that in mind, it&#39;s already time for us to look at some of them. Let&#39;s jump in!</p> <p><strong>Warning:</strong> These features are all in various stages of development. While they&#39;re likely to land, and probably will look similar, take the contents of this chapter with more than a few grains of salt. This chapter will evolve in future editions of this title as these (and other!) features finalize.</p> <h2 id=\"-async-function-s\"><code>async function</code>s</h2> <p>In &quot;Generators + Promises&quot; in Chapter 4, we mentioned that there&#39;s a proposal for direct syntactic support for the pattern of generators <code>yield</code>ing promises to a runner-like utility that will resume it on promise completion. Let&#39;s take a brief look at that proposed feature, called <code>async function</code>.</p> <p>Recall this generator example from Chapter 4:</p> <pre><code class=\"lang-js\">run( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> *<span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> ret = <span class=\"hljs-keyword\">yield</span> step1();      <span class=\"hljs-keyword\">try</span> {         ret = <span class=\"hljs-keyword\">yield</span> step2( ret );     }     <span class=\"hljs-keyword\">catch</span> (err) {         ret = <span class=\"hljs-keyword\">yield</span> step2Failed( err );     }      ret = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-built_in\">Promise</span>.all([         step3a( ret ),         step3b( ret ),         step3c( ret )     ]);      <span class=\"hljs-keyword\">yield</span> step4( ret ); } ) .then(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\"></span>)</span>{         <span class=\"hljs-comment\">// `*main()` completed successfully</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span>(<span class=\"hljs-params\">reason</span>)</span>{         <span class=\"hljs-comment\">// Oops, something went wrong</span>     } ); </code></pre> <p>The proposed <code>async function</code> syntax can express this same flow control logic without needing the <code>run(..)</code> utility, because JS will automatically know how to look for promises to wait and resume. Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\"></span>) </span>{     <span class=\"hljs-keyword\">var</span> ret = <span class=\"hljs-keyword\">await</span> step1();      <span class=\"hljs-keyword\">try</span> {         ret = <span class=\"hljs-keyword\">await</span> step2( ret );     }     <span class=\"hljs-keyword\">catch</span> (err) {         ret = <span class=\"hljs-keyword\">await</span> step2Failed( err );     }      ret = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-built_in\">Promise</span>.all( [         step3a( ret ),         step3b( ret ),         step3c( ret )     ] );      <span class=\"hljs-keyword\">await</span> step4( ret ); }  main() .then(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\"></span>)</span>{         <span class=\"hljs-comment\">// `main()` completed successfully</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span>(<span class=\"hljs-params\">reason</span>)</span>{         <span class=\"hljs-comment\">// Oops, something went wrong</span>     } ); </code></pre> <p>Instead of the <code>function *main() { ..</code> declaration, we declare with the <code>async function main() { ..</code> form. And instead of <code>yield</code>ing a promise, we <code>await</code> the promise. The call to run the function <code>main()</code> actually returns a promise that we can directly observe. That&#39;s the equivalent to the promise that we get back from a <code>run(main)</code> call.</p> <p>Do you see the symmetry? <code>async function</code> is essentially syntactic sugar for the generators + promises + <code>run(..)</code> pattern; under the covers, it operates the same!</p> <p>If you&#39;re a C# developer and this <code>async</code>/<code>await</code> looks familiar, it&#39;s because this feature is directly inspired by C#&#39;s feature. It&#39;s nice to see language precedence informing convergence!</p> <p>Babel, Traceur and other transpilers already have early support for the current status of <code>async function</code>s, so you can start using them already. However, in the next section &quot;Caveats&quot;, we&#39;ll see why you perhaps shouldn&#39;t jump on that ship quite yet.</p> <p><strong>Note:</strong> There&#39;s also a proposal for <code>async function*</code>, which would be called an &quot;async generator.&quot; You can both <code>yield</code> and <code>await</code> in the same code, and even combine those operations in the same statement: <code>x = await yield y</code>. The &quot;async generator&quot; proposal seems to be more in flux -- namely, its return value is not fully worked out yet. Some feel it should be an <em>observable</em>, which is kind of like the combination of an iterator and a promise. For now, we won&#39;t go further into that topic, but stay tuned as it evolves.</p> <h3 id=\"caveats\">Caveats</h3> <p>One unresolved point of contention with <code>async function</code> is that because it only returns a promise, there&#39;s no way from the outside to <em>cancel</em> an <code>async function</code> instance that&#39;s currently running. This can be a problem if the async operation is resource intensive, and you want to free up the resources as soon as you&#39;re sure the result won&#39;t be needed.</p> <p>For example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">request</span>(<span class=\"hljs-params\">url</span>) </span>{     <span class=\"hljs-keyword\">var</span> resp = <span class=\"hljs-keyword\">await</span> (         <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>( <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">resolve,reject</span>)</span>{             <span class=\"hljs-keyword\">var</span> xhr = <span class=\"hljs-keyword\">new</span> XMLHttpRequest();             xhr.open( <span class=\"hljs-string\">\"GET\"</span>, url );             xhr.onreadystatechange = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>)</span>{                 <span class=\"hljs-keyword\">if</span> (xhr.readyState == <span class=\"hljs-number\">4</span>) {                     <span class=\"hljs-keyword\">if</span> (xhr.status == <span class=\"hljs-number\">200</span>) {                         resolve( xhr );                     }                     <span class=\"hljs-keyword\">else</span> {                         reject( xhr.statusText );                     }                 }             };             xhr.send();         } )     );      <span class=\"hljs-keyword\">return</span> resp.responseText; }  <span class=\"hljs-keyword\">var</span> pr = request( <span class=\"hljs-string\">\"http://some.url.1\"</span> );  pr.then(     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">fulfilled</span>(<span class=\"hljs-params\">responseText</span>)</span>{         <span class=\"hljs-comment\">// ajax success</span>     },     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">rejected</span>(<span class=\"hljs-params\">reason</span>)</span>{         <span class=\"hljs-comment\">// Oops, something went wrong</span>     } ); </code></pre> <p>This <code>request(..)</code> that I&#39;ve conceived is somewhat like the <code>fetch(..)</code> utility that&#39;s recently been proposed for inclusion into the web platform. So the concern is, what happens if you want to use the <code>pr</code> value to somehow indicate that you want to cancel a long-running Ajax request, for example?</p> <p>Promises are not cancelable (at the time of writing, anyway). In my opinion, as well as many others, they never should be (see the <em>Async &amp; Performance</em> title of this series). And even if a promise did have a <code>cancel()</code> method on it, does that necessarily mean that calling <code>pr.cancel()</code> should actually propagate a cancelation signal all the way back up the promise chain to the <code>async function</code>?</p> <p>Several possible resolutions to this debate have surfaced:</p> <ul> <li><code>async function</code>s won&#39;t be cancelable at all (status quo)</li> <li>A &quot;cancel token&quot; can be passed to an async function at call time</li> <li>Return value changes to a cancelable-promise type that&#39;s added</li> <li>Return value changes to something else non-promise (e.g., observable, or control token with promise and cancel capabilities)</li> </ul> <p>At the time of this writing, <code>async function</code>s return regular promises, so it&#39;s less likely that the return value will entirely change. But it&#39;s too early to tell where things will land. Keep an eye on this discussion.</p> <h2 id=\"-object-observe-\"><code>Object.observe(..)</code></h2> <p>One of the holy grails of front-end web development is data binding -- listening for updates to a data object and syncing the DOM representation of that data. Most JS frameworks provide some mechanism for these sorts of operations.</p> <p>It appears likely that post ES6, we&#39;ll see support added directly to the language, via a utility called <code>Object.observe(..)</code>. Essentially, the idea is that you can set up a listener to observe an object&#39;s changes, and have a callback called any time a change occurs. You can then update the DOM accordingly, for instance.</p> <p>There are six types of changes that you can observe:</p> <ul> <li>add</li> <li>update</li> <li>delete</li> <li>reconfigure</li> <li>setPrototype</li> <li>preventExtensions</li> </ul> <p>By default, you&#39;ll be notified of all these change types, but you can filter down to only the ones you care about.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> obj = { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };  <span class=\"hljs-built_in\">Object</span>.observe(     obj,     <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">changes</span>)</span>{         <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> change <span class=\"hljs-keyword\">of</span> changes) {             <span class=\"hljs-built_in\">console</span>.log( change );         }     },     [ <span class=\"hljs-string\">\"add\"</span>, <span class=\"hljs-string\">\"update\"</span>, <span class=\"hljs-string\">\"delete\"</span> ] );  obj.c = <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// { name: \"c\", object: obj, type: \"add\" }</span>  obj.a = <span class=\"hljs-number\">42</span>; <span class=\"hljs-comment\">// { name: \"a\", object: obj, type: \"update\", oldValue: 1 }</span>  <span class=\"hljs-keyword\">delete</span> obj.b; <span class=\"hljs-comment\">// { name: \"b\", object: obj, type: \"delete\", oldValue: 2 }</span> </code></pre> <p>In addition to the main <code>&quot;add&quot;</code>, <code>&quot;update&quot;</code>, and <code>&quot;delete&quot;</code> change types:</p> <ul> <li>The <code>&quot;reconfigure&quot;</code> change event is fired if one of the object&#39;s properties is reconfigured with <code>Object.defineProperty(..)</code>, such as changing its <code>writable</code> attribute. See the <em>this &amp; Object Prototypes</em> title of this series for more information.</li> <li><p>The <code>&quot;preventExtensions&quot;</code> change event is fired if the object is made non-extensible via <code>Object.preventExtensions(..)</code>.</p> <p> Because both <code>Object.seal(..)</code> and <code>Object.freeze(..)</code> also imply <code>Object.preventExtensions(..)</code>, they&#39;ll also fire its corresponding change event. In addition, <code>&quot;reconfigure&quot;</code> change events will also be fired for each property on the object.</p> </li> <li>The <code>&quot;setPrototype&quot;</code> change event is fired if the <code>[[Prototype]]</code> of an object is changed, either by setting it with the <code>__proto__</code> setter, or using <code>Object.setPrototypeOf(..)</code>.</li> </ul> <p>Notice that these change events are notified immediately after said change. Don&#39;t confuse this with proxies (see Chapter 7) where you can intercept the actions before they occur. Object observation lets you respond after a change (or set of changes) occurs.</p> <h3 id=\"custom-change-events\">Custom Change Events</h3> <p>In addition to the six built-in change event types, you can also listen for and fire custom change events.</p> <p>Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">observer</span>(<span class=\"hljs-params\">changes</span>)</span>{     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> change <span class=\"hljs-keyword\">of</span> changes) {         <span class=\"hljs-keyword\">if</span> (change.type == <span class=\"hljs-string\">\"recalc\"</span>) {             change.object.c =                 change.object.oldValue +                 change.object.a +                 change.object.b;         }     } }  <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">changeObj</span>(<span class=\"hljs-params\">a,b</span>) </span>{     <span class=\"hljs-keyword\">var</span> notifier = <span class=\"hljs-built_in\">Object</span>.getNotifier( obj );      obj.a = a * <span class=\"hljs-number\">2</span>;     obj.b = b * <span class=\"hljs-number\">3</span>;      <span class=\"hljs-comment\">// queue up change events into a set</span>     notifier.notify( {         type: <span class=\"hljs-string\">\"recalc\"</span>,         name: <span class=\"hljs-string\">\"c\"</span>,         oldValue: obj.c     } ); }  <span class=\"hljs-keyword\">var</span> obj = { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span>, c: <span class=\"hljs-number\">3</span> };  <span class=\"hljs-built_in\">Object</span>.observe(     obj,     observer,     [<span class=\"hljs-string\">\"recalc\"</span>] );  changeObj( <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">11</span> );  obj.a;            <span class=\"hljs-comment\">// 12</span> obj.b;            <span class=\"hljs-comment\">// 30</span> obj.c;            <span class=\"hljs-comment\">// 3</span> </code></pre> <p>The change set (<code>&quot;recalc&quot;</code> custom event) has been queued for delivery to the observer, but not delivered yet, which is why <code>obj.c</code> is still <code>3</code>.</p> <p>The changes are by default delivered at the end of the current event loop (see the <em>Async &amp; Performance</em> title of this series). If you want to deliver them immediately, use <code>Object.deliverChangeRecords(observer)</code>. Once the change events are delivered, you can observe <code>obj.c</code> updated as expected:</p> <pre><code class=\"lang-js\">obj.<span class=\"hljs-built_in\">c</span>;            <span class=\"hljs-comment\">// 42</span> </code></pre> <p>In the previous example, we called <code>notifier.notify(..)</code> with the complete change event record. An alternative form for queuing change records is to use <code>performChange(..)</code>, which separates specifying the type of the event from the rest of event record&#39;s properties (via a function callback). Consider:</p> <pre><code class=\"lang-js\"><span class=\"hljs-tag\">notifier</span><span class=\"hljs-class\">.performChange</span>( <span class=\"hljs-string\">\"recalc\"</span>, <span class=\"hljs-function\">function</span>(){     <span class=\"hljs-tag\">return</span> {         <span class=\"hljs-attribute\">name</span>: <span class=\"hljs-string\">\"c\"</span>,         <span class=\"hljs-comment\">// `this` is the object under observation</span>         <span class=\"hljs-attribute\">oldValue</span>: this.c     }; } ); </code></pre> <p>In certain circumstances, this separation of concerns may map more cleanly to your usage pattern.</p> <h3 id=\"ending-observation\">Ending Observation</h3> <p>Just like with normal event listeners, you may wish to stop observing an object&#39;s change events. For that, you use <code>Object.unobserve(..)</code>.</p> <p>For example:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> obj = { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> };  <span class=\"hljs-built_in\">Object</span>.observe( obj, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">observer</span>(<span class=\"hljs-params\">changes</span>) </span>{     <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> change <span class=\"hljs-keyword\">of</span> changes) {         <span class=\"hljs-keyword\">if</span> (change.type == <span class=\"hljs-string\">\"setPrototype\"</span>) {             <span class=\"hljs-built_in\">Object</span>.unobserve(                 change.object, observer             );             <span class=\"hljs-keyword\">break</span>;         }     } } ); </code></pre> <p>In this trivial example, we listen for change events until we see the <code>&quot;setPrototype&quot;</code> event come through, at which time we stop observing any more change events.</p> <h2 id=\"exponentiation-operator\">Exponentiation Operator</h2> <p>An operator has been proposed for JavaScript to perform exponentiation in the same way that <code>Math.pow(..)</code> does. Consider:</p> <pre><code class=\"lang-js\">var a = <span class=\"hljs-number\">2</span>;  a ** <span class=\"hljs-number\">4</span>;            <span class=\"hljs-comment\">// Math.pow( a, 4 ) == 16</span>  a **= <span class=\"hljs-number\">3</span>;        <span class=\"hljs-comment\">// a = Math.pow( a, 3 )</span> a;                <span class=\"hljs-comment\">// 8</span> </code></pre> <p><strong>Note:</strong> <code>**</code> is essentially the same as it appears in Python, Ruby, Perl, and others.</p> <h2 id=\"objects-properties-and-\">Objects Properties and <code>...</code></h2> <p>As we saw in the &quot;Too Many, Too Few, Just Enough&quot; section of Chapter 2, the <code>...</code> operator is pretty obvious in how it relates to spreading or gathering arrays. But what about objects?</p> <p>Such a feature was considered for ES6, but was deferred to be considered after ES6 (aka &quot;ES7&quot; or &quot;ES2016&quot; or ...). Here&#39;s how it might work in that &quot;beyond ES6&quot; timeframe:</p> <pre><code class=\"lang-js\">var o1 = { a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> },     o2 = { c: <span class=\"hljs-number\">3</span> },     o3 = { ...o1, ...o2, d: <span class=\"hljs-number\">4</span> };  console.<span class=\"hljs-built_in\">log</span>( o3.a, o3.b, o3.c, o3.d ); <span class=\"hljs-comment\">// 1 2 3 4</span> </code></pre> <p>The <code>...</code> operator might also be used to gather an object&#39;s destructured properties back into an object:</p> <pre><code class=\"lang-js\"><span class=\"hljs-keyword\">var</span> o1 = { b: 2, c: 3, <span class=\"hljs-keyword\">d</span>: 4 }; <span class=\"hljs-keyword\">var</span> { b, ...o2 } = o1;  console.<span class=\"hljs-literal\">log</span>( b, o2.c, o2.<span class=\"hljs-keyword\">d</span> );        <span class=\"hljs-comment\">// 2 3 4</span> </code></pre> <p>Here, the <code>...o2</code> re-gathers the destructured <code>c</code> and <code>d</code> properties back into an <code>o2</code> object (<code>o2</code> does not have a <code>b</code> property like <code>o1</code> does).</p> <p>Again, these are just proposals under consideration beyond ES6. But it&#39;ll be cool if they do land.</p> <h2 id=\"-array-includes-\"><code>Array#includes(..)</code></h2> <p>One extremely common task JS developers need to perform is searching for a value inside an array of values. The way this has always been done is:</p> <pre><code class=\"lang-js\">var vals = [ <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-string\">\"baz\"</span> ];  <span class=\"hljs-keyword\">if</span> (vals.indexOf( <span class=\"hljs-number\">42</span> ) &gt;= <span class=\"hljs-number\">0</span>) {     <span class=\"hljs-comment\">// found it!</span> } </code></pre> <p>The reason for the <code>&gt;= 0</code> check is because <code>indexOf(..)</code> returns a numeric value of <code>0</code> or greater if found, or <code>-1</code> if not found. In other words, we&#39;re using an index-returning function in a boolean context. But because <code>-1</code> is truthy instead of falsy, we have to be more manual with our checks.</p> <p>In the <em>Types &amp; Grammar</em> title of this series, I explored another pattern that I slightly prefer:</p> <pre><code class=\"lang-js\">var vals = [ <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-string\">\"baz\"</span> ];  <span class=\"hljs-keyword\">if</span> (~vals.indexOf( <span class=\"hljs-number\">42</span> )) {     <span class=\"hljs-comment\">// found it!</span> } </code></pre> <p>The <code>~</code> operator here conforms the return value of <code>indexOf(..)</code> to a value range that is suitably boolean coercible. That is, <code>-1</code> produces <code>0</code> (falsy), and anything else produces a non-zero (truthy) value, which is what we for deciding if we found the value or not.</p> <p>While I think that&#39;s an improvement, others strongly disagree. However, no one can argue that <code>indexOf(..)</code>&#39;s searching logic is perfect. It fails to find <code>NaN</code> values in the array, for example.</p> <p>So a proposal has surfaced and gained a lot of support for adding a real boolean-returning array search method, called <code>includes(..)</code>:</p> <pre><code class=\"lang-js\">var vals = [ <span class=\"hljs-string\">\"foo\"</span>, <span class=\"hljs-string\">\"bar\"</span>, <span class=\"hljs-number\">42</span>, <span class=\"hljs-string\">\"baz\"</span> ];  <span class=\"hljs-keyword\">if</span> (vals.includes( <span class=\"hljs-number\">42</span> )) {     <span class=\"hljs-comment\">// found it!</span> } </code></pre> <p><strong>Note:</strong> <code>Array#includes(..)</code> uses matching logic that will find <code>NaN</code> values, but will not distinguish between <code>-0</code> and <code>0</code> (see the <em>Types &amp; Grammar</em> title of this series). If you don&#39;t care about <code>-0</code> values in your programs, this will likely be exactly what you&#39;re hoping for. If you <em>do</em> care about <code>-0</code>, you&#39;ll need to do your own searching logic, likely using the <code>Object.is(..)</code> utility (see Chapter 6).</p> <h2 id=\"simd\">SIMD</h2> <p>We cover Single Instruction, Multiple Data (SIMD) in more detail in the <em>Async &amp; Performance</em> title of this series, but it bears a brief mention here, as it&#39;s one of the next likely features to land in a future JS.</p> <p>The SIMD API exposes various low-level (CPU) instructions that can operate on more than a single number value at a time. For example, you&#39;ll be able to specify two <em>vectors</em> of 4 or 8 numbers each, and multiply the respective elements all at once (data parallelism!).</p> <p>Consider:</p> <pre><code class=\"lang-js\">var v1 = SIMD.float32x4( <span class=\"hljs-number\">3.14159</span>, <span class=\"hljs-number\">21.0</span>, <span class=\"hljs-number\">32.3</span>, <span class=\"hljs-number\">55.55</span> ); var v2 = SIMD.float32x4( <span class=\"hljs-number\">2.1</span>, <span class=\"hljs-number\">3.2</span>, <span class=\"hljs-number\">4.3</span>, <span class=\"hljs-number\">5.4</span> );  SIMD.float32x4.mul( v1, v2 ); <span class=\"hljs-comment\">// [ 6.597339, 67.2, 138.89, 299.97 ]</span> </code></pre> <p>SIMD will include several other operations besides <code>mul(..)</code> (multiplication), such as <code>sub()</code>, <code>div()</code>, <code>abs()</code>, <code>neg()</code>, <code>sqrt()</code>, and many more.</p> <p>Parallel math operations are critical for the next generations of high performance JS applications.</p> <h2 id=\"webassembly-wasm-\">WebAssembly (WASM)</h2> <p>Brendan Eich made a late breaking announcement near the completion of the first edition of this title that has the potential to significantly impact the future path of JavaScript: WebAssembly (WASM). We will not be able to cover WASM in detail here, as it&#39;s extremely early at the time of this writing. But this title would be incomplete without at least a brief mention of it.</p> <p>One of the strongest pressures on the recent (and near future) design changes of the JS language has been the desire that it become a more suitable target for transpilation/cross-compilation from other languages (like C/C++, ClojureScript, etc.). Obviously, performance of code running as JavaScript has been a primary concern.</p> <p>As discussed in the <em>Async &amp; Performance</em> title of this series, a few years ago a group of developers at Mozilla introduced an idea to JavaScript called ASM.js. ASM.js is a subset of valid JS that most signficantly restricts certain actions that make code hard for the JS engine to optimize. The result is that ASM.js compatible code running in an ASM-aware engine can run remarkably faster, nearly on par with native optimized C equivalents. Many viewed ASM.js as the most likely backbone on which performance-hungry applications would ride in JavaScript.</p> <p>In other words, all roads to running code in the browser <em>lead through JavaScript</em>.</p> <p>That is, until the WASM announcement. WASM provides an alternate path for other languages to target the browser&#39;s runtime environment without having to first pass through JavaScript. Essentially, if WASM takes off, JS engines will grow an extra capability to execute a binary format of code that can be seen as somewhat similar to a bytecode (like that which runs on the JVM).</p> <p>WASM proposes a format for a binary representation of a highly compressed AST (syntax tree) of code, which can then give instructions directly to the JS engine and its underpinnings, without having to be parsed by JS, or even behave by the rules of JS. Languages like C or C++ can be compiled directly to the WASM format instead of ASM.js, and gain an extra speed advantage by skipping the JS parsing.</p> <p>The near term for WASM is to have parity with ASM.js and indeed JS. But eventually, it&#39;s expected that WASM would grow new capabilities that surpass anything JS could do. For example, the pressure for JS to evolve radical features like threads -- a change that would certainly send major shockwaves through the JS ecosystem -- has a more hopeful future as a future WASM extension, relieving the pressure to change JS.</p> <p>In fact, this new roadmap opens up many new roads for many languages to target the web runtime. That&#39;s an exciting new future path for the web platform!</p> <p>What does it mean for JS? Will JS become irrelevant or &quot;die&quot;? Absolutely not. ASM.js will likely not see much of a future beyond the next couple of years, but the majority of JS is quite safely anchored in the web platform story.</p> <p>Proponents of WASM suggest its success will mean that the design of JS will be protected from pressures that would have eventually stretched it beyond assumed breaking points of reasonability. It is projected that WASM will become the preferred target for high-performance parts of applications, as authored in any of a myriad of different languages.</p> <p>Interestingly, JavaScript is one of the lesser likely languages to target WASM in the future. There may be future changes that carve out subsets of JS that might be tenable for such targeting, but that path doesn&#39;t seem high on the priority list.</p> <p>While JS likely won&#39;t be much of a WASM funnel, JS code and WASM code will be able to interoperate in the most significant ways, just as naturally as current module interactions. You can imagine calling a JS function like <code>foo()</code> and having that actually invoke a WASM function of that name with the power to run well outside the constraints of the rest of your JS.</p> <p>Things which are currently written in JS will probably continue to always be written in JS, at least for the foreseeable future. Things which are transpiled to JS will probably eventually at least consider targeting WASM instead. For things which need the utmost in performance with minimal tolerance for layers of abstraction, the likely choice will be to find a suitable non-JS language to author in, then targeting WASM.</p> <p>There&#39;s a good chance this shift will be slow, and will be years in the making. WASM landing in all the major browser platforms is probably a few years out at best. In the meantime, the WASM project (<a href=\"https://github.com/WebAssembly\">https://github.com/WebAssembly</a>) has an early polyfill to demonstrate proof-of-concept for its basic tenets.</p> <p>But as time goes on, and as WASM learns new non-JS tricks, it&#39;s not too much a stretch of imagination to see some currently-JS things being refactored to a WASM-targetable language. For example, the performance sensitive parts of frameworks, game engines, and other heavily used tools might very well benefit from such a shift. Developers using these tools in their web applications likely won&#39;t notice much difference in usage or integration, but will just automatically take advantage of the performance and capabilities.</p> <p>What&#39;s certain is that the more real WASM becomes over time, the more it means to the trajectory and design of JavaScript. It&#39;s perhaps one of the most important &quot;beyond ES6&quot; topics developers should keep an eye on.</p> <h2 id=\"review\">Review</h2> <p>If all the other books in this series essentially propose this challenge, &quot;you (may) not know JS (as much as you thought),&quot; this book has instead suggested, &quot;you don&#39;t know JS anymore.&quot; The book has covered a ton of new stuff added to the language in ES6. It&#39;s an exciting collection of new language features and paradigms that will forever improve our JS programs.</p> <p>But JS is not done with ES6! Not even close. There&#39;s already quite a few features in various stages of development for the &quot;beyond ES6&quot; timeframe. In this chapter, we briefly looked at some of the most likely candidates to land in JS very soon.</p> <p><code>async function</code>s are powerful syntactic sugar on top of the generators + promises pattern (see Chapter 4). <code>Object.observe(..)</code> adds direct native support for observing object change events, which is critical for implementing data binding. The <code>**</code> exponentiation operator, <code>...</code> for object properties, and <code>Array#includes(..)</code> are all simple but helpful improvements to existing mechanisms. Finally, SIMD ushers in a new era in the evolution of high performance JS.</p> <p>Clich as it sounds, the future of JS is really bright! The challenge of this series, and indeed of this book, is incumbent on every reader now. What are you waiting for? It&#39;s time to get learning and exploring!</p> ","title":"You Don't Know JS: ES6 & Beyond"},"foreword":{"body":"<h1 id=\"foreword\">Foreword</h1> <p>Kyle Simpson is a thorough pragmatist.</p> <p>I can&#39;t think of higher praise than this. To me, these are two of the most important qualities that a software developer must have. That&#39;s right: <em>must</em>, not <em>should</em>. Kyle&#39;s keen ability to tease apart layers of the JavaScript programming language and present them in understandable and meaningful portions is second to none.</p> <p><em>ES6 &amp; Beyond</em> will be familiar to readers of the <em>You Don&#39;t Know JS</em> series:  they can expect to be deeply immersed in everything from the obvious, to the very subtle -- revealing semantics that were either taken for granted or never even considered. Until now, the <em>You Don&#39;t Know JS</em> book series has covered material that has at least some degree of familiarity to its readers. They have either seen or heard about the subject matter; they may even have experience with it. This volume covers material that only a very small portion of the JavaScript developer community has been exposed to: the  evolutionary changes to the language introduced in the ECMAScript 2015 Language Specification.</p> <p>Over the last couple years, I&#39;ve witnessed Kyle&#39;s tireless efforts to familiarize himself with this material to a level of expertise that is rivaled by only a handful of his professional peers. That&#39;s quite a feat, considering that at the time of this writing, the language specification document hasn&#39;t been formally published! But what I&#39;ve said is true, and I&#39;ve read every word that Kyle&#39;s written for this book. I&#39;ve followed every change, and each time, the content only gets better and provides yet a deeper level of understanding.</p> <p>This book is about shaking up your sense of understanding by exposing you to the new and unknown. The intention is to evolve your knowledge in step with your tools by bestowing you with new capabilities. It exists to give you the confidence to fully embrace the next major era of JavaScript programming.</p> <p>Rick Waldron<br> <a href=\"http://twitter.com/rwaldron\">@rwaldron</a><br> Open Web Engineer at Bocoup<br> Ecma/TC39 Representative for jQuery</p> ","title":"You Don't Know JS: ES6 & Beyond"},"toc":{"body":"<h2 id=\"table-of-contents\">Table of Contents</h2> <ul> <li>Foreword</li> <li>Preface</li> <li>Chapter 1: ES? Now &amp; Future<ul> <li>Versioning</li> <li>Transpiling</li> </ul> </li> <li>Chapter 2: Syntax<ul> <li>Block-Scoped Declarations</li> <li>Spread / Rest</li> <li>Default Parameter Values</li> <li>Destructuring</li> <li>Object Literal Extensions</li> <li>Template Literals</li> <li>Arrow Functions</li> <li><code>for..of</code> Loops</li> <li>Regular Expression Extensions</li> <li>Number Literal Extensions</li> <li>Unicode</li> <li>Symbols</li> </ul> </li> <li>Chapter 3: Organization<ul> <li>Iterators</li> <li>Generators</li> <li>Modules</li> <li>Classes</li> </ul> </li> <li>Chapter 4: Async Flow Control<ul> <li>Promises</li> <li>Generators + Promises</li> </ul> </li> <li>Chapter 5: Collections<ul> <li>TypedArrays</li> <li>Maps</li> <li>WeakMaps</li> <li>Sets</li> <li>WeakSets</li> </ul> </li> <li>Chapter 6: API Additions<ul> <li><code>Array</code></li> <li><code>Object</code></li> <li><code>Math</code></li> <li><code>Number</code></li> <li><code>String</code></li> </ul> </li> <li>Chapter 7: Meta Programming<ul> <li>Function Names</li> <li>Meta Properties</li> <li>Well Known Symbols</li> <li>Proxies</li> <li><code>Reflect</code> API</li> <li>Feature Testing</li> <li>Tail Call Optimization (TCO)</li> </ul> </li> <li>Chapter 8: Beyond ES6<ul> <li><code>async function</code>s</li> <li><code>Object.observe(..)</code></li> <li>Exponentiation Operator</li> <li>Object Properties and <code>...</code></li> <li><code>Array#includes(..)</code></li> <li>SIMD</li> </ul> </li> <li>Appendix A: Acknowledgments</li> </ul> ","title":"You Don't Know JS: ES6 & Beyond"}}